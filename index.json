[{"categories":["K8S"],"content":"k8s1.20 kubelet的volume manager源码分析","date":"2021-02-09","objectID":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","tags":["K8S"],"title":"kubelet volume manager源码分析","uri":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"kubelet volume manager组件源码分析 k8s版本：1.20.0 ","date":"2021-02-09","objectID":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:0:0","tags":["K8S"],"title":"kubelet volume manager源码分析","uri":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"总体 ","date":"2021-02-09","objectID":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:1:0","tags":["K8S"],"title":"kubelet volume manager源码分析","uri":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"volume模块图 kubelet调用VolumeManager，为pods准备存储设备，存储设备就绪会挂载存储设备到pod所在的节点上，并在容器启动的时候挂载在容器指定的目录中；同时，删除卸载不再使用的存储； kubernetes采用Volume Plugins来实现存储卷的挂载等操作 ","date":"2021-02-09","objectID":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:1:1","tags":["K8S"],"title":"kubelet volume manager源码分析","uri":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"volume manager 源码位置：kubernetes\\pkg\\kubelet\\volumemanager const ( // reconcilerLoopSleepPeriod is the amount of time the reconciler loop waits // between successive executions reconcilerLoopSleepPeriod = 100 * time.Millisecond // desiredStateOfWorldPopulatorLoopSleepPeriod is the amount of time the // DesiredStateOfWorldPopulator loop waits between successive executions desiredStateOfWorldPopulatorLoopSleepPeriod = 100 * time.Millisecond // desiredStateOfWorldPopulatorGetPodStatusRetryDuration is the amount of // time the DesiredStateOfWorldPopulator loop waits between successive pod // cleanup calls (to prevent calling containerruntime.GetPodStatus too // frequently). desiredStateOfWorldPopulatorGetPodStatusRetryDuration = 2 * time.Second // podAttachAndMountTimeout is the maximum amount of time the // WaitForAttachAndMount call will wait for all volumes in the specified pod // to be attached and mounted. Even though cloud operations can take several // minutes to complete, we set the timeout to 2 minutes because kubelet // will retry in the next sync iteration. This frees the associated // goroutine of the pod to process newer updates if needed (e.g., a delete // request to the pod). // Value is slightly offset from 2 minutes to make timeouts due to this // constant recognizable. podAttachAndMountTimeout = 2*time.Minute + 3*time.Second // podAttachAndMountRetryInterval is the amount of time the GetVolumesForPod // call waits before retrying podAttachAndMountRetryInterval = 300 * time.Millisecond // waitForAttachTimeout is the maximum amount of time a // operationexecutor.Mount call will wait for a volume to be attached. // Set to 10 minutes because we've seen attach operations take several // minutes to complete for some volume plugins in some cases. While this // operation is waiting it only blocks other operations on the same device, // other devices are not affected. waitForAttachTimeout = 10 * time.Minute ) // VolumeManager runs a set of asynchronous loops that figure out which volumes // need to be attached/mounted/unmounted/detached based on the pods scheduled on // this node and makes it so. type VolumeManager interface { // Starts the volume manager and all the asynchronous loops that it controls Run(sourcesReady config.SourcesReady, stopCh \u003c-chan struct{}) // WaitForAttachAndMount processes the volumes referenced in the specified // pod and blocks until they are all attached and mounted (reflected in // actual state of the world). // An error is returned if all volumes are not attached and mounted within // the duration defined in podAttachAndMountTimeout. WaitForAttachAndMount(pod *v1.Pod) error // GetMountedVolumesForPod returns a VolumeMap containing the volumes // referenced by the specified pod that are successfully attached and // mounted. The key in the map is the OuterVolumeSpecName (i.e. // pod.Spec.Volumes[x].Name). It returns an empty VolumeMap if pod has no // volumes. GetMountedVolumesForPod(podName types.UniquePodName) container.VolumeMap // GetExtraSupplementalGroupsForPod returns a list of the extra // supplemental groups for the Pod. These extra supplemental groups come // from annotations on persistent volumes that the pod depends on. GetExtraSupplementalGroupsForPod(pod *v1.Pod) []int64 // GetVolumesInUse returns a list of all volumes that implement the volume.Attacher // interface and are currently in use according to the actual and desired // state of the world caches. A volume is considered \"in use\" as soon as it // is added to the desired state of world, indicating it *should* be // attached to this node and remains \"in use\" until it is removed from both // the desired state of the world and the actual state of the world, or it // has been unmounted (as indicated in actual state of world). GetVolumesInUse() []v1.UniqueVolumeName // ReconcilerStatesHasBeenSynced returns true only after the actual states in reconciler // has been synced at least once after kubelet starts so that it is safe to upd","date":"2021-02-09","objectID":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:1:2","tags":["K8S"],"title":"kubelet volume manager源码分析","uri":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"VolumeManager接口说明 运行在kubelet 里让存储Ready的部件，主要是mount/unmount（attach/detach可选） pod调度到这个node上后才会有卷的相应操作，所以它的触发端是kubelet（严格讲是kubelet里的pod manager），根据Pod Manager里pod spec里申明的存储来触发卷的挂载操作 Kubelet会监听到调度到该节点上的pod声明，会把pod缓存到Pod Manager中，VolumeManager通过Pod Manager获取PV/PVC的状态，并进行分析出具体的attach/detach、mount/umount, 操作然后调用plugin进行相应的业务处理 ","date":"2021-02-09","objectID":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:1:3","tags":["K8S"],"title":"kubelet volume manager源码分析","uri":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"volumeManager结构体 volumeManager结构体实现了VolumeManager接口，主要有两个需要注意： desiredStateOfWorld：预期状态，volume需要被attach，哪些pods引用这个volume actualStateOfWorld：实际状态，volume已经被atttach哪个node，哪个pod mount volume ","date":"2021-02-09","objectID":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:1:4","tags":["K8S"],"title":"kubelet volume manager源码分析","uri":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"desiredStateOfWorld 和 actualStateOfWorld desiredStateOfWorld为理想的volume情况，它主要是根据podManger获取所有的Pod信息，从中提取Volume信息。 actualStateOfWorld则是实际的volume情况。 desiredStateOfWorldPopulator通过podManager去构建desiredStateOfWorld。 reconciler的工作主要是比较actualStateOfWorld和desiredStateOfWorld的差别，然后进行volume的创建、删除和修改，最后使二者达到一致。 ","date":"2021-02-09","objectID":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:1:5","tags":["K8S"],"title":"kubelet volume manager源码分析","uri":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"流程 ","date":"2021-02-09","objectID":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:2:0","tags":["K8S"],"title":"kubelet volume manager源码分析","uri":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"新建 NewVolumeManager中主要构造了几个volume控制器 volumePluginMgr 和 csiMigratedPluginManager desiredStateOfWorldPopulator reconciler // NewMainKubelet instantiates a new Kubelet object along with all the required internal modules. // No initialization of Kubelet and its modules should happen here. func NewMainKubelet(){ // ...... // setup volumeManager klet.volumeManager = volumemanager.NewVolumeManager( kubeCfg.EnableControllerAttachDetach, nodeName, klet.podManager, klet.statusManager, klet.kubeClient, klet.volumePluginMgr, klet.containerRuntime, kubeDeps.Mounter, kubeDeps.HostUtil, klet.getPodsDir(), kubeDeps.Recorder, experimentalCheckNodeCapabilitiesBeforeMount, keepTerminatedPodVolumes, volumepathhandler.NewBlockVolumePathHandler()) // ...... } // NewVolumeManager returns a new concrete instance implementing the // VolumeManager interface. // // kubeClient - kubeClient is the kube API client used by DesiredStateOfWorldPopulator // to communicate with the API server to fetch PV and PVC objects // volumePluginMgr - the volume plugin manager used to access volume plugins. // Must be pre-initialized. func NewVolumeManager(){ vm := \u0026volumeManager{ kubeClient: kubeClient, volumePluginMgr: volumePluginMgr, desiredStateOfWorld: cache.NewDesiredStateOfWorld(volumePluginMgr), actualStateOfWorld: cache.NewActualStateOfWorld(nodeName, volumePluginMgr), operationExecutor: operationexecutor.NewOperationExecutor(operationexecutor.NewOperationGenerator( kubeClient, volumePluginMgr, recorder, checkNodeCapabilitiesBeforeMount, blockVolumePathHandler)), } intreeToCSITranslator := csitrans.New() csiMigratedPluginManager := csimigration.NewPluginManager(intreeToCSITranslator) vm.intreeToCSITranslator = intreeToCSITranslator vm.csiMigratedPluginManager = csiMigratedPluginManager vm.desiredStateOfWorldPopulator = populator.NewDesiredStateOfWorldPopulator( kubeClient, desiredStateOfWorldPopulatorLoopSleepPeriod, desiredStateOfWorldPopulatorGetPodStatusRetryDuration, podManager, podStatusProvider, vm.desiredStateOfWorld, vm.actualStateOfWorld, kubeContainerRuntime, keepTerminatedPodVolumes, csiMigratedPluginManager, intreeToCSITranslator, volumePluginMgr) vm.reconciler = reconciler.NewReconciler( kubeClient, controllerAttachDetachEnabled, reconcilerLoopSleepPeriod, waitForAttachTimeout, nodeName, vm.desiredStateOfWorld, vm.actualStateOfWorld, vm.desiredStateOfWorldPopulator.HasAddedPods, vm.operationExecutor, mounter, hostutil, volumePluginMgr, kubeletPodsDir) return vm } // NewDesiredStateOfWorldPopulator returns a new instance of // DesiredStateOfWorldPopulator. // // kubeClient - used to fetch PV and PVC objects from the API server // loopSleepDuration - the amount of time the populator loop sleeps between // successive executions // podManager - the kubelet podManager that is the source of truth for the pods // that exist on this host // desiredStateOfWorld - the cache to populate func NewDesiredStateOfWorldPopulator( kubeClient clientset.Interface, loopSleepDuration time.Duration, getPodStatusRetryDuration time.Duration, podManager pod.Manager, podStatusProvider status.PodStatusProvider, desiredStateOfWorld cache.DesiredStateOfWorld, actualStateOfWorld cache.ActualStateOfWorld, kubeContainerRuntime kubecontainer.Runtime, keepTerminatedPodVolumes bool, csiMigratedPluginManager csimigration.PluginManager, intreeToCSITranslator csimigration.InTreeToCSITranslator, volumePluginMgr *volume.VolumePluginMgr) DesiredStateOfWorldPopulator { return \u0026desiredStateOfWorldPopulator{ kubeClient: kubeClient, loopSleepDuration: loopSleepDuration, getPodStatusRetryDuration: getPodStatusRetryDuration, podManager: podManager, podStatusProvider: podStatusProvider, desiredStateOfWorld: desiredStateOfWorld, actualStateOfWorld: actualStateOfWorld, pods: processedPods{ processedPods: make(map[volumetypes.UniquePodName]bool)}, kubeContainerRuntime: kubeContainerRuntime, keepTerminatedPodVolumes: keepTerminatedPodVolumes, hasAddedPods: false, hasAddedPodsLock: sync.RWMutex{}, csiM","date":"2021-02-09","objectID":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:2:1","tags":["K8S"],"title":"kubelet volume manager源码分析","uri":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"启动 kl.volumeManager.Run // Run starts the kubelet reacting to config updates func (kl *Kubelet) Run(updates \u003c-chan kubetypes.PodUpdate) { // Start volume manager go kl.volumeManager.Run(kl.sourcesReady, wait.NeverStop) go wait.Until(kl.updateRuntimeUp, 5*time.Second, wait.NeverStop) // Set up iptables util rules if kl.makeIPTablesUtilChains { kl.initNetworkUtil() } // Start a goroutine responsible for killing pods (that are not properly // handled by pod workers). go wait.Until(kl.podKiller.PerformPodKillingWork, 1*time.Second, wait.NeverStop) // Start component sync loops. kl.statusManager.Start() kl.probeManager.Start() // Start syncing RuntimeClasses if enabled. if kl.runtimeClassManager != nil { kl.runtimeClassManager.Start(wait.NeverStop) } // Start the pod lifecycle event generator. kl.pleg.Start() kl.syncLoop(updates, kl) } func (vm *volumeManager) Run(sourcesReady config.SourcesReady, stopCh \u003c-chan struct{}) { defer runtime.HandleCrash() if vm.kubeClient != nil { // start informer for CSIDriver go vm.volumePluginMgr.Run(stopCh) } go vm.desiredStateOfWorldPopulator.Run(sourcesReady, stopCh) klog.V(2).Infof(\"The desired_state_of_world populator starts\") klog.Infof(\"Starting Kubelet Volume Manager\") go vm.reconciler.Run(stopCh) metrics.Register(vm.actualStateOfWorld, vm.desiredStateOfWorld, vm.volumePluginMgr) \u003c-stopCh klog.Infof(\"Shutting down Kubelet Volume Manager\") } 启动子模块有 如果有volumePlugin（默认安装时没有插件），启动volumePluginMgr 启动 desiredStateOfWorldPopulator：从apiserver同步到的pod信息，更新DesiredStateOfWorld findAndAddNewPods() findAndRemoveDeletedPods() 每隔dswp.getPodStatusRetryDuration时长，进行findAndRemoveDeletedPods() 启动 reconciler：预期状态和实际状态的协调者，负责调整实际状态至预期状态 desiredStateOfWorldPopulator 通过populatorLoop()来更新DesiredStateOfWorld func (dswp *desiredStateOfWorldPopulator) populatorLoop() { dswp.findAndAddNewPods() // findAndRemoveDeletedPods() calls out to the container runtime to // determine if the containers for a given pod are terminated. This is // an expensive operation, therefore we limit the rate that // findAndRemoveDeletedPods() is called independently of the main // populator loop. if time.Since(dswp.timeOfLastGetPodStatus) \u003c dswp.getPodStatusRetryDuration { klog.V(5).Infof( \"Skipping findAndRemoveDeletedPods(). Not permitted until %v (getPodStatusRetryDuration %v).\", dswp.timeOfLastGetPodStatus.Add(dswp.getPodStatusRetryDuration), dswp.getPodStatusRetryDuration) return } dswp.findAndRemoveDeletedPods() } findAndAddNewPods 遍历pod manager中所有pod 过滤掉Terminated态的pod，进行processPodVolumes，把这些pod添加到desired state of world 就是通过podManager获取所有的pods，然后调用processPodVolumes去更新desiredStateOfWorld。但是这样只能更新新增加的Pods的Volume信息。 // Iterate through all pods and add to desired state of world if they don't // exist but should func (dswp *desiredStateOfWorldPopulator) findAndAddNewPods() { // Map unique pod name to outer volume name to MountedVolume. mountedVolumesForPod := make(map[volumetypes.UniquePodName]map[string]cache.MountedVolume) if utilfeature.DefaultFeatureGate.Enabled(features.ExpandInUsePersistentVolumes) { for _, mountedVolume := range dswp.actualStateOfWorld.GetMountedVolumes() { mountedVolumes, exist := mountedVolumesForPod[mountedVolume.PodName] if !exist { mountedVolumes = make(map[string]cache.MountedVolume) mountedVolumesForPod[mountedVolume.PodName] = mountedVolumes } mountedVolumes[mountedVolume.OuterVolumeSpecName] = mountedVolume } } processedVolumesForFSResize := sets.NewString() for _, pod := range dswp.podManager.GetPods() { if dswp.isPodTerminated(pod) { // Do not (re)add volumes for terminated pods continue } dswp.processPodVolumes(pod, mountedVolumesForPod, processedVolumesForFSResize) } } processPodVolumes 更新desiredStateOfWorld // processPodVolumes processes the volumes in the given pod and adds them to the // desired state of the world. func (dswp *desiredStateOfWorldPopulator) processPodVolumes( pod *v1.Pod, mountedVolumesForPod map[volumetypes.UniquePodName]map[string]cache.MountedVolume, processedVolumesForFSResize sets.S","date":"2021-02-09","objectID":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:2:2","tags":["K8S"],"title":"kubelet volume manager源码分析","uri":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"NFS的mount setup 挂载命令默认使用了系统命令mount nfs中为每个volume的挂载目录路径的pluginName是kubernetes.io~nfs mount操作的source为nfs server 的 exportPath mount操作的target为dir，即pod的nfs卷路径位置nfsMounter.GetPath()，示例见下 source := fmt.Sprintf(\"%s:%s\", nfsMounter.server, nfsMounter.exportPath) err = nfsMounter.mounter.MountSensitiveWithoutSystemd(source, dir, \"nfs\", mountOptions, nil) nfs的挂载volume路径dir示例： var/lib/kubelet/pods/{podid}//volumes/{pluginName}/{pvname} # nfsMounter.GetPath() #/var/lib/kubelet/pods/{podid}//volumes/{pluginName}/{pvname} /var/lib/kubelet/pods/06d10daa-c7e8-46e5-b94a-c0fcd2f27a2e/volumes/kubernetes.io~nfs/pvc-1f9f7ceb-6ca8-453e-87a0-013e53841fad mount挂载处理 // SetUp attaches the disk and bind mounts to the volume path. func (nfsMounter *nfsMounter) SetUp(mounterArgs volume.MounterArgs) error { return nfsMounter.SetUpAt(nfsMounter.GetPath(), mounterArgs) } func (nfsMounter *nfsMounter) SetUpAt(dir string, mounterArgs volume.MounterArgs) error { notMnt, err := mount.IsNotMountPoint(nfsMounter.mounter, dir) klog.V(4).Infof(\"NFS mount set up: %s %v %v\", dir, !notMnt, err) if err != nil \u0026\u0026 !os.IsNotExist(err) { return err } if !notMnt { return nil } if err := os.MkdirAll(dir, 0750); err != nil { return err } source := fmt.Sprintf(\"%s:%s\", nfsMounter.server, nfsMounter.exportPath) options := []string{} if nfsMounter.readOnly { options = append(options, \"ro\") } mountOptions := util.JoinMountOptions(nfsMounter.mountOptions, options) err = nfsMounter.mounter.MountSensitiveWithoutSystemd(source, dir, \"nfs\", mountOptions, nil) if err != nil { notMnt, mntErr := mount.IsNotMountPoint(nfsMounter.mounter, dir) if mntErr != nil { klog.Errorf(\"IsNotMountPoint check failed: %v\", mntErr) return err } if !notMnt { if mntErr = nfsMounter.mounter.Unmount(dir); mntErr != nil { klog.Errorf(\"Failed to unmount: %v\", mntErr) return err } notMnt, mntErr := mount.IsNotMountPoint(nfsMounter.mounter, dir) if mntErr != nil { klog.Errorf(\"IsNotMountPoint check failed: %v\", mntErr) return err } if !notMnt { // This is very odd, we don't expect it. We'll try again next sync loop. klog.Errorf(\"%s is still mounted, despite call to unmount(). Will try again next sync loop.\", dir) return err } } os.Remove(dir) return err } return nil } func (plugin *nfsPlugin) newMounterInternal(spec *volume.Spec, pod *v1.Pod, mounter mount.Interface) (volume.Mounter, error) { source, readOnly, err := getVolumeSource(spec) if err != nil { return nil, err } return \u0026nfsMounter{ nfs: \u0026nfs{ volName: spec.Name(), mounter: mounter, pod: pod, plugin: plugin, MetricsProvider: volume.NewMetricsStatFS(getPath(pod.UID, spec.Name(), plugin.host)), }, server: source.Server, exportPath: source.Path, readOnly: readOnly, mountOptions: util.MountOptionFromSpec(spec), }, nil } // Name returns the name of either Volume or PersistentVolume, one of which must not be nil. func (spec *Spec) Name() string { switch { case spec.Volume != nil: return spec.Volume.Name case spec.PersistentVolume != nil: return spec.PersistentVolume.Name default: return \"\" } } // NFS volumes represent a bare host file or directory mount of an NFS export. type nfs struct { volName string pod *v1.Pod mounter mount.Interface plugin *nfsPlugin volume.MetricsProvider } func (nfsVolume *nfs) GetPath() string { name := nfsPluginName // GetPodVolumeDir returns the absolute path a directory which // represents the named volume under the named plugin for the given // pod. If the specified pod does not exist, the result of this call // might not exist. return nfsVolume.plugin.host.GetPodVolumeDir(nfsVolume.pod.UID, utilstrings.EscapeQualifiedName(name), nfsVolume.volName) } ","date":"2021-02-09","objectID":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:3:0","tags":["K8S"],"title":"kubelet volume manager源码分析","uri":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"Kueblet SyncPod ","date":"2021-02-09","objectID":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:4:0","tags":["K8S"],"title":"kubelet volume manager源码分析","uri":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"SyncPod上下文 这里先回顾下pod容器创建准备过程，粗体标注为volume相关的处理。 完成创建容器前的准备工作（SyncPod） 在这个方法中，主要完成以下几件事情： 如果是删除 pod，立即执行并返回 同步 podStatus 到 kubelet.statusManager 检查 pod 是否能运行在本节点，主要是权限检查（是否能使用主机网络模式，是否可以以 privileged 权限运行等）。如果没有权限，就删除本地旧的 pod 并返回错误信息 创建 containerManagar 对象，并且创建 pod level cgroup，更新 Qos level cgroup 如果是 static Pod，就创建或者更新对应的 mirrorPod 创建 pod 的数据目录，存放 volume 和 plugin 信息,如果定义了 pv，等待所有的 volume mount 完成（volumeManager 会在后台做这些事情）,如果有 image secrets，去 apiserver 获取对应的 secrets 数据 然后调用 kubelet.volumeManager 组件，等待它将 pod 所需要的所有外挂的 volume 都准备好。 调用 container runtime 的 SyncPod 方法，去实现真正的容器创建逻辑 这里所有的事情都和具体的容器没有关系，可以看到该方法是创建 pod 实体（即容器）之前需要完成的准备工作。 func (kl *Kubelet) syncPod(o syncPodOptions) error { // pull out the required options pod := o.pod mirrorPod := o.mirrorPod podStatus := o.podStatus updateType := o.updateType // 是否为 删除 pod if updateType == kubetypes.SyncPodKill { ... } ... // 检查 pod 是否能运行在本节点 runnable := kl.canRunPod(pod) if !runnable.Admit { ... } // 更新 pod 状态 kl.statusManager.SetPodStatus(pod, apiPodStatus) // 如果 pod 非 running 状态则直接 kill 掉 if !runnable.Admit || pod.DeletionTimestamp != nil || apiPodStatus.Phase == v1.PodFailed { ... } // 加载网络插件 if rs := kl.runtimeState.networkErrors(); len(rs) != 0 \u0026\u0026 !kubecontainer.IsHostNetworkPod(pod) { ... } pcm := kl.containerManager.NewPodContainerManager() if !kl.podIsTerminated(pod) { ... // 创建并更新 pod 的 cgroups if !(podKilled \u0026\u0026 pod.Spec.RestartPolicy == v1.RestartPolicyNever) { if !pcm.Exists(pod) { ... } } } // 为 static pod 创建对应的 mirror pod if kubepod.IsStaticPod(pod) { ... } // 创建数据目录 if err := kl.makePodDataDirs(pod); err != nil { ... } // 挂载 volume if !kl.podIsTerminated(pod) { if err := kl.volumeManager.WaitForAttachAndMount(pod); err != nil { ... } } // 获取 secret 信息 pullSecrets := kl.getPullSecretsForPod(pod) // 调用 containerRuntime 的 SyncPod 方法开始创建容器 result := kl.containerRuntime.SyncPod(pod, apiPodStatus, podStatus, pullSecrets, kl.backOff) kl.reasonCache.Update(pod.UID, result) if err := result.Error(); err != nil { ... } return nil } 在上面的上下文中，看到了kubelet的syncpod处理，同步 pod 时，等待 pod attach 和 mount 完成 func (kl *Kubelet) syncPod(o syncPodOptions) error { // 挂载 volume if !kl.podIsTerminated(pod) { if err := kl.volumeManager.WaitForAttachAndMount(pod); err != nil { ... } } } ","date":"2021-02-09","objectID":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:4:1","tags":["K8S"],"title":"kubelet volume manager源码分析","uri":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"WaitForAttachAndMount func (vm *volumeManager) WaitForAttachAndMount(pod *v1.Pod) error { if pod == nil { return nil } // pod的全部挂载卷 expectedVolumes := getExpectedVolumes(pod) if len(expectedVolumes) == 0 { // No volumes to verify return nil } klog.V(3).Infof(\"Waiting for volumes to attach and mount for pod %q\", format.Pod(pod)) uniquePodName := util.GetUniquePodName(pod) // Some pods expect to have Setup called over and over again to update. // Remount plugins for which this is true. (Atomically updating volumes, // like Downward API, depend on this to update the contents of the volume). vm.desiredStateOfWorldPopulator.ReprocessPod(uniquePodName) err := wait.PollImmediate( podAttachAndMountRetryInterval, podAttachAndMountTimeout, vm.verifyVolumesMountedFunc(uniquePodName, expectedVolumes)) if err != nil { unmountedVolumes := vm.getUnmountedVolumes(uniquePodName, expectedVolumes) // Also get unattached volumes for error message unattachedVolumes := vm.getUnattachedVolumes(expectedVolumes) // 没有被 mount 的volume 数量为0，表示成功完成挂载 if len(unmountedVolumes) == 0 { return nil } return fmt.Errorf( \"unmounted volumes=%v, unattached volumes=%v: %s\", unmountedVolumes, unattachedVolumes, err) } klog.V(3).Infof(\"All volumes are attached and mounted for pod %q\", format.Pod(pod)) return nil } ","date":"2021-02-09","objectID":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:4:2","tags":["K8S"],"title":"kubelet volume manager源码分析","uri":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"verifyVolumesMountedFunc 没有被 mount 的volume 数量为0，表示成功完成挂载 UnmountedVolumes = expectedVolumes - mountedVolumes // verifyVolumesMountedFunc returns a method that returns true when all expected // volumes are mounted. func (vm *volumeManager) verifyVolumesMountedFunc(podName types.UniquePodName, expectedVolumes []string) wait.ConditionFunc { return func() (done bool, err error) { if errs := vm.desiredStateOfWorld.PopPodErrors(podName); len(errs) \u003e 0 { return true, errors.New(strings.Join(errs, \"; \")) } return len(vm.getUnmountedVolumes(podName, expectedVolumes)) == 0, nil } } // getUnmountedVolumes fetches the current list of mounted volumes from // the actual state of the world, and uses it to process the list of // expectedVolumes. It returns a list of unmounted volumes. // The list also includes volume that may be mounted in uncertain state. func (vm *volumeManager) getUnmountedVolumes(podName types.UniquePodName, expectedVolumes []string) []string { mountedVolumes := sets.NewString() for _, mountedVolume := range vm.actualStateOfWorld.GetMountedVolumesForPod(podName) { // 实际的挂载卷 mountedVolumes.Insert(mountedVolume.OuterVolumeSpecName) } // expectedVolumes为pod的全部挂载卷 // UnmountedVolumes = expectedVolumes - mountedVolumes return filterUnmountedVolumes(mountedVolumes, expectedVolumes) } ","date":"2021-02-09","objectID":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:4:3","tags":["K8S"],"title":"kubelet volume manager源码分析","uri":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"参考资料 kubelet源码分析之volume manager源码分析 kubelet 创建 pod 的流程 ","date":"2021-02-09","objectID":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:5:0","tags":["K8S"],"title":"kubelet volume manager源码分析","uri":"/posts/2021/02/kubelet-volume-manager%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"k8s dynamic provisioning and storage 介绍","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"动态pv存储供应（k8s dynamic provisioning and storage） 和 nfs-server-provisioner 原理介绍和功能验证 ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:0:0","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"设计说明 Storage is a critical part of running containers, and Kubernetes offers some powerful primitives for managing it. Dynamic volume provisioning, a feature unique to Kubernetes, allows storage volumes to be created on-demand. Without dynamic provisioning, cluster administrators have to manually make calls to their cloud or storage provider to create new storage volumes, and then create PersistentVolume objects to represent them in Kubernetes. The dynamic provisioning feature eliminates the need for cluster administrators to pre-provision storage. Instead, it automatically provisions storage when it is requested by users. This feature was introduced as alpha in Kubernetes 1.2, and has been improved and promoted to beta in the latest release, 1.4. This release makes dynamic provisioning far more flexible and useful. ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:1:0","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"What’s New? The alpha version of dynamic provisioning only allowed a single, hard-coded provisioner to be used in a cluster at once. This meant that when Kubernetes determined storage needed to be dynamically provisioned, it always used the same volume plugin to do provisioning, even if multiple storage systems were available on the cluster. The provisioner to use was inferred based on the cloud environment - EBS for AWS, Persistent Disk for Google Cloud, Cinder for OpenStack, and vSphere Volumes on vSphere. Furthermore, the parameters used to provision new storage volumes were fixed: only the storage size was configurable. This meant that all dynamically provisioned volumes would be identical, except for their storage size, even if the storage system exposed other parameters (such as disk type) for configuration during provisioning. Although the alpha version of the feature was limited in utility, it allowed us to “get some miles” on the idea, and helped determine the direction we wanted to take. The beta version of dynamic provisioning, new in Kubernetes 1.4, introduces a new API object, StorageClass. Multiple StorageClass objects can be defined each specifying a volume plugin (aka provisioner) to use to provision a volume and the set of parameters to pass to that provisioner when provisioning. This design allows cluster administrators to define and expose multiple flavors of storage (from the same or different storage systems) within a cluster, each with a custom set of parameters. This design also ensures that end users don’t have to worry about the complexity and nuances of how storage is provisioned, but still have the ability to select from multiple storage options. Dynamic Provisioning and Storage Classes in Kubernetes 说明： 管理员只需要按存储类型，预置一些strorage class资源配置（可以理解为创建pv的模板），不需要为每个pvc声明手动创建pv 用户按所需strorage class，创建pvc，则系统（这里指的是nfs provisoner）会根据pvc信息，自动创建pv并进行绑定 当用户pod删除时，根据需要删除pvc，则绑定的pv会自动关联删除 ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:1:1","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"provisioner、pv、pvc 图 ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:2:0","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"资源视图 ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:2:1","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"交互视图 搭建StorageClass+NFS,大致有以下几个步骤: 创建一个可用的NFS Serve 创建Service Account.这是用来管控NFS provisioner在k8s集群中运行的权限 创建StorageClass.负责建立PVC并调用NFS provisioner进行预定的工作,并让PV与PVC建立管理 创建NFS provisioner.有两个功能,一个是在NFS共享目录下创建挂载点(volume),另一个则是建了PV并将PV与NFS的挂载点建立关联 ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:2:2","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"nfs-provisioner项目 新代码项目地址：https://github.com/kubernetes-sigs/nfs-ganesha-server-and-external-provisioner 老项目地址（不再使用）https://github.com/kubernetes-retired/external-storage/tree/master/nfs 可使用quay.io/kubernetes_incubator/nfs-provisioner镜像 ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:2:3","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"nfs-provisioner镜像 docker pull quay.io/kubernetes_incubator/nfs-provisioner docker save quay.io/kubernetes_incubator/nfs-provisioner:latest -o nfs-provisioner.img.tar ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:3:0","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"Arguments provisioner - Name of the provisioner. The provisioner will only provision volumes for claims that request a StorageClass with a provisioner field set equal to this name. master - Master URL to build a client config from. Either this or kubeconfig needs to be set if the provisioner is being run out of cluster. kubeconfig - Absolute path to the kubeconfig file. Either this or master needs to be set if the provisioner is being run out of cluster. run-server - If the provisioner is responsible for running the NFS server, i.e. starting and stopping NFS Ganesha. Default true. use-ganesha - If the provisioner will create volumes using NFS Ganesha (D-Bus method calls) as opposed to using the kernel NFS server (‘exportfs’). If run-server is true, this must be true. Default true. grace-period - NFS Ganesha grace period to use in seconds, from 0-180. If the server is not expected to survive restarts, i.e. it is running as a pod \u0026 its export directory is not persisted, this can be set to 0. Can only be set if both run-server and use-ganesha are true. Default 90. enable-xfs-quota - If the provisioner will set xfs quotas for each volume it provisions. Requires that the directory it creates volumes in ('/export') is xfs mounted with option prjquota/pquota, and that it has the privilege to run xfs_quota. Default false. failed-retry-threshold - If the number of retries on provisioning failure need to be limited to a set number of attempts. Default 10 server-hostname - The hostname for the NFS server to export from. Only applicable when running out-of-cluster i.e. it can only be set if either master or kubeconfig are set. If unset, the first IP output by hostname -i is used. device-based-fsids - If file system handles created by NFS Ganesha should be based on major/minor device IDs of the backing storage volume ('/export'). When running a cloud based kubernetes service (like Googles GKE service) set this to false as it might affect client connections on restarts of the nfs provisioner pod. Default true. ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:4:0","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"存储配额 ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:5:0","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"nfs provisioner xfsQuotaer 通过添加project到目标目录的方式来设置配额大小 实际上还是通过xfsQuotaer 实现 // createQuota creates a quota for the directory by adding a project to // represent the directory and setting a quota on it func (p *nfsProvisioner) createQuota(directory string, capacity resource.Quantity) (string, uint16, error) { path := path.Join(p.exportDir, directory) limit := strconv.FormatInt(capacity.Value(), 10) block, projectID, err := p.quotaer.AddProject(path, limit) if err != nil { return \"\", 0, fmt.Errorf(\"error adding project for path %s: %v\", path, err) } err = p.quotaer.SetQuota(projectID, path, limit) if err != nil { p.quotaer.RemoveProject(block, projectID) return \"\", 0, fmt.Errorf(\"error setting quota for path %s: %v\", path, err) } return block, projectID, nil } XfsQuotaer 需要系统配置 xfs文件系统挂载参数 prjquota 或则 pquota 参数 type xfsQuotaer struct { xfsPath string // The file where we store mappings between project ids and directories, and // each project's quota limit information, for backup. // Similar to http://man7.org/linux/man-pages/man5/projects.5.html projectsFile string projectIDs map[uint16]bool mapMutex *sync.Mutex fileMutex *sync.Mutex } // NewNFSProvisioner creates a Provisioner that provisions NFS PVs backed by // the given directory. func NewNFSProvisioner(exportDir string, client kubernetes.Interface, outOfCluster bool, useGanesha bool, ganeshaConfig string, enableXfsQuota bool, serverHostname string, maxExports int, exportSubnet string) controller.Provisioner { var quotaer quotaer var err error // 当XfsQuota功能开启时，才能进行配额 if enableXfsQuota { quotaer, err = newXfsQuotaer(exportDir) if err != nil { glog.Fatalf(\"Error creating xfs quotaer! %v\", err) } } else { quotaer = newDummyQuotaer() } } // 构造XfsQuotaer unc newXfsQuotaer(xfsPath string) (*xfsQuotaer, error) { if _, err := os.Stat(xfsPath); os.IsNotExist(err) { return nil, fmt.Errorf(\"xfs path %s does not exist\", xfsPath) } isXfs, err := isXfs(xfsPath) if err != nil { return nil, fmt.Errorf(\"error checking if xfs path %s is an XFS filesystem: %v\", xfsPath, err) } if !isXfs { return nil, fmt.Errorf(\"xfs path %s is not an XFS filesystem\", xfsPath) } entry, err := getMountEntry(path.Clean(xfsPath), \"xfs\") if err != nil { return nil, err } // XfsQuotaer 需要系统配置 xfs文件系统挂载参数 prjquota 或则 pquota 参数 if !strings.Contains(entry.VfsOpts, \"pquota\") \u0026\u0026 !strings.Contains(entry.VfsOpts, \"prjquota\") { return nil, fmt.Errorf(\"xfs path %s was not mounted with pquota nor prjquota\", xfsPath) } _, err = exec.LookPath(\"xfs_quota\") if err != nil { return nil, err } projectsFile := path.Join(xfsPath, \"projects\") projectIDs := map[uint16]bool{} _, err = os.Stat(projectsFile) if os.IsNotExist(err) { file, cerr := os.Create(projectsFile) if cerr != nil { return nil, fmt.Errorf(\"error creating xfs projects file %s: %v\", projectsFile, cerr) } file.Close() } else { re := regexp.MustCompile(\"(?m:^([0-9]+):/.+$)\") projectIDs, err = getExistingIDs(projectsFile, re) if err != nil { glog.Errorf(\"error while populating projectIDs map, there may be errors setting quotas later if projectIDs are reused: %v\", err) } } xfsQuotaer := \u0026xfsQuotaer{ xfsPath: xfsPath, projectsFile: projectsFile, projectIDs: projectIDs, mapMutex: \u0026sync.Mutex{}, fileMutex: \u0026sync.Mutex{}, } return xfsQuotaer, nil } ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:5:1","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"配额扩容 在storageclass和k8s的默认配置下，通过修改pvc配置文件claim.yaml的配额大小，会报错，报错信息如下。 [root@node131 nfs]# vi deploy/kubernetes_incubator_nfs_provisioner/claim.yaml [root@node131 nfs]# 编辑size大小 [root@node131 nfs]# [root@node131 nfs]# kubectl apply -f deploy/kubernetes_incubator_nfs_provisioner/claim.yaml Warning: resource persistentvolumeclaims/nfs is missing the kubectl.kubernetes.io/last-applied-configuration annotation which is required by kubectl apply. kubectl apply should only be used on resources created declaratively by either kubectl create --save-config or kubectl apply. The missing annotation will be patched automatically. Error from server (Forbidden): error when applying patch: {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"v1\\\",\\\"kind\\\":\\\"PersistentVolumeClaim\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"nfs\\\",\\\"namespace\\\":\\\"default\\\"},\\\"spec\\\":{\\\"accessModes\\\":[\\\"ReadWriteMany\\\"],\\\"resources\\\":{\\\"requests\\\":{\\\"storage\\\":\\\"5Mi\\\"}},\\\"storageClassName\\\":\\\"example-nfs\\\"}}\\n\"}},\"spec\":{\"resources\":{\"requests\":{\"storage\":\"5Mi\"}}}} to: Resource: \"/v1, Resource=persistentvolumeclaims\", GroupVersionKind: \"/v1, Kind=PersistentVolumeClaim\" Name: \"nfs\", Namespace: \"default\" for: \"deploy/kubernetes_incubator_nfs_provisioner/claim.yaml\": persistentvolumeclaims \"nfs\" is forbidden: only dynamically provisioned pvc can be resized and the storageclass that provisions the pvc must support resize [root@node131 nfs]# 参考文档说明内容如下： StorageClass允许卷扩容 FEATURE STATE: Kubernetes v1.11 [beta] PersistentVolume 可以配置为可扩容。将此功能设置为 true 时，允许用户通过编辑相应的 PVC 对象来调整卷大小。 当下层 StorageClass 的 allowVolumeExpansion 字段设置为 true 时，以下类型的卷支持卷扩展。 此功能仅可用于扩容卷，不能用于缩小卷。 注意，文档中没有说明nfs卷可以扩容，需要测试验证，测试验证如下 编辑 StorageClass ，添加 allowVolumeExpansion kind:StorageClassapiVersion:storage.k8s.io/v1metadata:name:example-nfsprovisioner:example.com/nfs# 允许卷扩容allowVolumeExpansion:truemountOptions:- vers=4.1 执行更新扩容为5M操作，发现pvc仍未更新 查看pvc的打印，如下 [root@node131 nfs]# kubectl apply -f deploy/kubernetes_incubator_nfs_provisioner/claim.yaml persistentvolumeclaim/nfs unchanged [root@node131 nfs]# kubectl describe pvc Name: nfs Namespace: default StorageClass: example-nfs Status: Bound Volume: pvc-1f9f7ceb-6ca8-453e-87a0-013e53841fad Labels: \u003cnone\u003e Annotations: pv.kubernetes.io/bind-completed: yes pv.kubernetes.io/bound-by-controller: yes volume.beta.kubernetes.io/storage-provisioner: example.com/nfs Finalizers: [kubernetes.io/pvc-protection] Capacity: 1Mi Access Modes: RWX VolumeMode: Filesystem Used By: \u003cnone\u003e Events: Type Reason Age From Message ---- ------ ---- ---- ------- Warning ExternalExpanding 40m volume_expand Ignoring the PVC: didn't find a plugin capable of expanding the volume; waiting for an external controller to process this PVC. Warning ExternalExpanding 2m52s volume_expand Ignoring the PVC: didn't find a plugin capable of expanding the volume; waiting for an external controller to process this PVC. [root@node131 nfs]# 根据上面 提示，查看controller是否处理了pvc resize操作。 查看kube-controller的打印，如下 I0223 07:31:30.381326 1 expand_controller.go:277] Ignoring the PVC \"default/nfs\" (uid: \"1f9f7ceb-6ca8-453e-87a0-013e53841fad\") : didn't find a plugin capable of expanding the volume; waiting for an external controller to process this PVC. I0223 07:31:30.381389 1 event.go:291] \"Event occurred\" object=\"default/nfs\" kind=\"PersistentVolumeClaim\" apiVersion=\"v1\" type=\"Warning\" reason=\"ExternalExpanding\" message=\"Ignoring the PVC: didn't find a plugin capable of expanding the volume; waiting for an external controller to process this PVC.\" 原因 nfs并不支持在线动态扩容操作，即在storageclass条件下，通过修改pvc，同步联动修改pv 说明： k8s从1.8版本开始支持PV扩容操作。目前glusterfs、rbd等几种存储类型已经支持扩容操作，按官方文档并未包含nfs存储。 PV支持扩容需要满足两个条件： PersistentVolumeClaimResize插件使能，apiserver启动参数 –enable-admission-plugins中添加 PersistentVolumeClaimResize StorageClass allowVolumeExpansion设置为true 当这两个条件达到之后，用户可以修改PVC的大小从而驱动底层PV的扩容操作。对于包含文件系统的PV，只有当新Pod启动并且以读写模式挂载该PV时才完成文件系统扩容。也就是说，当PV已经挂载在某个Pod时，需要重启该Pod才能完成文件系统扩容。目前支持支持扩容的文件系统包括Ext3/Ext4、XFS。 以上内容总结","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:5:2","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"apiserver 参数样例 [root@node131 manifests]# cat kube-apiserver.yamlapiVersion:v1kind:Podmetadata:annotations:kubeadm.kubernetes.io/kube-apiserver.advertise-address.endpoint:192.168.182.131:6443creationTimestamp:nulllabels:component:kube-apiservertier:control-planename:kube-apiservernamespace:kube-systemspec:containers:- command:- kube-apiserver- --advertise-address=192.168.182.131- --allow-privileged=true- --anonymous-auth=True- --apiserver-count=1- --authorization-mode=Node,RBAC- --bind-address=0.0.0.0- --client-ca-file=/etc/kubernetes/ssl/ca.crt#- --enable-admission-plugins=NodeRestriction- --enable-admission-plugins=\"NodeRestriction,PersistentVolumeClaimResize\"... ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:5:3","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"参考代码 kube apiserver 需要开启volume扩容插件 resize.PluginName, // PersistentVolumeClaimResize // AllOrderedPlugins is the list of all the plugins in order. var AllOrderedPlugins = []string{ admit.PluginName, // AlwaysAdmit autoprovision.PluginName, // NamespaceAutoProvision lifecycle.PluginName, // NamespaceLifecycle exists.PluginName, // NamespaceExists scdeny.PluginName, // SecurityContextDeny antiaffinity.PluginName, // LimitPodHardAntiAffinityTopology limitranger.PluginName, // LimitRanger serviceaccount.PluginName, // ServiceAccount noderestriction.PluginName, // NodeRestriction nodetaint.PluginName, // TaintNodesByCondition alwayspullimages.PluginName, // AlwaysPullImages imagepolicy.PluginName, // ImagePolicyWebhook podsecuritypolicy.PluginName, // PodSecurityPolicy podnodeselector.PluginName, // PodNodeSelector podpriority.PluginName, // Priority defaulttolerationseconds.PluginName, // DefaultTolerationSeconds podtolerationrestriction.PluginName, // PodTolerationRestriction exec.DenyEscalatingExec, // DenyEscalatingExec exec.DenyExecOnPrivileged, // DenyExecOnPrivileged eventratelimit.PluginName, // EventRateLimit extendedresourcetoleration.PluginName, // ExtendedResourceToleration label.PluginName, // PersistentVolumeLabel setdefault.PluginName, // DefaultStorageClass storageobjectinuseprotection.PluginName, // StorageObjectInUseProtection gc.PluginName, // OwnerReferencesPermissionEnforcement resize.PluginName, // PersistentVolumeClaimResize runtimeclass.PluginName, // RuntimeClass certapproval.PluginName, // CertificateApproval certsigning.PluginName, // CertificateSigning certsubjectrestriction.PluginName, // CertificateSubjectRestriction defaultingressclass.PluginName, // DefaultIngressClass // new admission plugins should generally be inserted above here // webhook, resourcequota, and deny plugins must go at the end mutatingwebhook.PluginName, // MutatingAdmissionWebhook validatingwebhook.PluginName, // ValidatingAdmissionWebhook resourcequota.PluginName, // ResourceQuota deny.PluginName, // AlwaysDeny } const ( // PluginName is the name of pvc resize admission plugin PluginName = \"PersistentVolumeClaimResize\" ) func (pvcr *persistentVolumeClaimResize) Validate(ctx context.Context, a admission.Attributes, o admission.ObjectInterfaces) error { if a.GetResource().GroupResource() != api.Resource(\"persistentvolumeclaims\") { return nil } if len(a.GetSubresource()) != 0 { return nil } pvc, ok := a.GetObject().(*api.PersistentVolumeClaim) // if we can't convert then we don't handle this object so just return if !ok { return nil } oldPvc, ok := a.GetOldObject().(*api.PersistentVolumeClaim) if !ok { return nil } oldSize := oldPvc.Spec.Resources.Requests[api.ResourceStorage] newSize := pvc.Spec.Resources.Requests[api.ResourceStorage] if newSize.Cmp(oldSize) \u003c= 0 { return nil } if oldPvc.Status.Phase != api.ClaimBound { return admission.NewForbidden(a, fmt.Errorf(\"Only bound persistent volume claims can be expanded\")) } // Growing Persistent volumes is only allowed for PVCs for which their StorageClass // explicitly allows it if !pvcr.allowResize(pvc, oldPvc) { return admission.NewForbidden(a, fmt.Errorf(\"only dynamically provisioned pvc can be resized and \"+ \"the storageclass that provisions the pvc must support resize\")) } return nil } // Growing Persistent volumes is only allowed for PVCs for which their StorageClass // explicitly allows it. func (pvcr *persistentVolumeClaimResize) allowResize(pvc, oldPvc *api.PersistentVolumeClaim) bool { pvcStorageClass := apihelper.GetPersistentVolumeClaimClass(pvc) oldPvcStorageClass := apihelper.GetPersistentVolumeClaimClass(oldPvc) if pvcStorageClass == \"\" || oldPvcStorageClass == \"\" || pvcStorageClass != oldPvcStorageClass { return false } sc, err := pvcr.scLister.Get(pvcStorageClass) if err != nil { return false } if sc.AllowVolumeExpansion != nil { return *sc.AllowVolumeExpansion } return false } controller相关代码 didn’t find a plugin capable of expanding the volume volumePlugin, err := exp","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:5:4","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"nfs-provisioner deploy说明 deployment说明 ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:6:0","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"部署 kubectl create -f deploy/kubernetes_incubator_nfs_provisioner/rbac.yaml kubectl create -f deploy/kubernetes_incubator_nfs_provisioner/deployment.yaml kubectl create -f deploy/kubernetes_incubator_nfs_provisioner/class.yaml kubectl create -f deploy/kubernetes_incubator_nfs_provisioner/claim.yaml kubectl get pv kubectl get pvc 部署信息 [root@node131 nfs]# kubectl create -f deploy/kubernetes_incubator_nfs_provisioner/deployment.yaml serviceaccount/nfs-provisioner created service/nfs-provisioner created deployment.apps/nfs-provisioner created [root@node131 nfs]# ls custom-nfs-busybox-rc.yaml custom-nfs-pv.yaml nfs-busybox-rc.yaml nfs-pvc.yaml nfs-server-rc.yaml nfs-web-service.yaml test custom-nfs-centos-rc.yaml custom-nfs-server-rc.yaml nfs-data nfs-pv.png nfs-server-service.yaml provisioner custom-nfs-pvc.yaml deploy nfsmount.conf nfs-pv.yaml nfs-web-rc.yaml README.md [root@node131 nfs]# kubectl create -f deploy/kubernetes_incubator_nfs_provisioner/class.yaml storageclass.storage.k8s.io/example-nfs created [root@node131 nfs]# kubectl get sc NAME PROVISIONER RECLAIMPOLICY VOLUMEBINDINGMODE ALLOWVOLUMEEXPANSION AGE example-nfs example.com/nfs Delete Immediate false 43s [root@node131 nfs]# [root@node131 nfs]# [root@node131 nfs]# kubectl describe sc Name: example-nfs IsDefaultClass: No Annotations: \u003cnone\u003e Provisioner: example.com/nfs Parameters: \u003cnone\u003e AllowVolumeExpansion: \u003cunset\u003e MountOptions: vers=4.1 ReclaimPolicy: Delete VolumeBindingMode: Immediate Events: \u003cnone\u003e [root@node131 nfs]# [root@node131 nfs]# [root@node131 nfs]# kubectl get pv No resources found [root@node131 nfs]# kubectl get pvc No resources found in default namespace. [root@node131 nfs]# [root@node131 nfs]# [root@node131 nfs]# [root@node131 nfs]# kubectl create -f deploy/kubernetes_incubator_nfs_provisioner/claim.yaml persistentvolumeclaim/nfs created [root@node131 nfs]# [root@node131 nfs]# kubectl get pvc NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE nfs Bound pvc-26703096-84df-4c18-88f5-16d0b09be156 1Mi RWX example-nfs 3s [root@node131 nfs]# [root@node131 nfs]# [root@node131 nfs]# kubectl get pv NAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS REASON AGE pvc-26703096-84df-4c18-88f5-16d0b09be156 1Mi RWX Delete Bound default/nfs example-nfs 5s [root@node131 nfs]# [root@node131 nfs]# [root@node131 nfs]# [root@node131 nfs]# [root@node131 nfs]# [root@node131 nfs]# kubectl get pvc NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE nfs Bound pvc-26703096-84df-4c18-88f5-16d0b09be156 1Mi RWX example-nfs 20s [root@node131 nfs]# kubectl describe pvc Name: nfs Namespace: default StorageClass: example-nfs Status: Bound Volume: pvc-26703096-84df-4c18-88f5-16d0b09be156 Labels: \u003cnone\u003e Annotations: pv.kubernetes.io/bind-completed: yes pv.kubernetes.io/bound-by-controller: yes volume.beta.kubernetes.io/storage-provisioner: example.com/nfs Finalizers: [kubernetes.io/pvc-protection] Capacity: 1Mi Access Modes: RWX VolumeMode: Filesystem Used By: \u003cnone\u003e Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal ExternalProvisioning 27s (x2 over 27s) persistentvolume-controller waiting for a volume to be created, either by external provisioner \"example.com/nfs\" or manually created by system administrator Normal Provisioning 27s example.com/nfs_nfs-provisioner-66ccf9bc7b-jpm2w_9633218c-812f-4e94-b77e-9f922ec2edb6 External provisioner is provisioning volume for claim \"default/nfs\" Normal ProvisioningSucceeded 27s example.com/nfs_nfs-provisioner-66ccf9bc7b-jpm2w_9633218c-812f-4e94-b77e-9f922ec2edb6 Successfully provisioned volume pvc-26703096-84df-4c18-88f5-16d0b09be156 [root@node131 nfs]# [root@node131 nfs]# kubectl describe pv Name: pvc-26703096-84df-4c18-88f5-16d0b09be156 Labels: \u003cnone\u003e Annotations: EXPORT_block: EXPORT { Export_Id = 1; Path = /export/pvc-26703096-84df-4c18-88f5-16d0b09be156; Pseudo = /export/pvc-26703096-84df-4c18-88f5-16d0b09be156; Access_Type = RW; Squash = no_root_squash; SecType = sys; Filesystem_id = 1.1; FSAL","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:7:0","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"卸载删除 kubectl delete -f deploy/kubernetes_incubator_nfs_provisioner/claim.yaml kubectl delete -f deploy/kubernetes_incubator_nfs_provisioner/class.yaml kubectl delete -f deploy/kubernetes_incubator_nfs_provisioner/deployment.yaml kubectl delete -f deploy/kubernetes_incubator_nfs_provisioner/rbac.yaml ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:8:0","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"测试验证 ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:9:0","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"存储写操作 kind:PodapiVersion:v1metadata:name:write-podspec:containers:- name:write-podimage:busyboximagePullPolicy:IfNotPresentcommand:- \"/bin/sh\"args:- \"-c\"- \"touch /mnt/SUCCESS \u0026\u0026 exit 0 || exit 1\"volumeMounts:- name:nfs-pvcmountPath:\"/mnt\"restartPolicy:\"Never\"volumes:- name:nfs-pvcpersistentVolumeClaim:claimName:nfs pod使用nfs pvc写操作，即往挂载路径/srv/pvc-idxxxxx/ 写 kubectl create -f deploy/kubernetes_incubator_nfs_provisioner/write-pod.yaml [root@node131 srv]# cd pvc-26703096-84df-4c18-88f5-16d0b09be156/ [root@node131 pvc-26703096-84df-4c18-88f5-16d0b09be156]# ll 总用量 0 -rw-r--r--. 1 root root 0 2月 8 11:16 SUCCESS ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:9:1","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"存储读操作 kind:PodapiVersion:v1metadata:name:read-podspec:containers:- name:read-podimage:busyboximagePullPolicy:IfNotPresentcommand:- \"/bin/sh\"args:- \"-c\"- \"test -f /mnt/SUCCESS \u0026\u0026 exit 0 || exit 1\"volumeMounts:- name:nfs-pvcmountPath:\"/mnt\"restartPolicy:\"Never\"volumes:- name:nfs-pvcpersistentVolumeClaim:claimName:nfs pod使用nfs pvc读操作，即往挂载路径/srv/pvc-idxxxxx/ 读 kubectl create -f deploy/kubernetes_incubator_nfs_provisioner/read-pod.yaml pod运行情况 [root@node131 pvc-26703096-84df-4c18-88f5-16d0b09be156]# kubectl get po -A NAMESPACE NAME READY STATUS RESTARTS AGE default nfs-provisioner-66ccf9bc7b-jpm2w 1/1 Running 0 38m default read-pod 0/1 Completed 0 7s default write-pod 0/1 Completed 0 8m43s kube-system calico-kube-controllers-65b86747bd-c4qsp 1/1 Running 16 47d kube-system calico-node-lglh4 1/1 Running 18 47d kube-system coredns-8677555d68-jwggm 1/1 Running 4 6d1h kube-system kube-apiserver-node131 1/1 Running 16 47d kube-system kube-controller-manager-node131 1/1 Running 17 47d kube-system kube-proxy-mktp9 1/1 Running 16 47d kube-system kube-scheduler-node131 1/1 Running 17 47d kube-system nodelocaldns-lfjzs 1/1 Running 16 47d ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:9:2","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"业务pod使用pvc时，删除pvc 业务pod状态为complete状态，进行delete pvc操作 此时命令会阻塞，pvc状态为保护过程中的Terminating [root@node131 nfs]# kubectl delete -f deploy/kubernetes_incubator_nfs_provisioner/claim.yaml persistentvolumeclaim \"nfs\" deleted ^C [root@node131 nfs]# [root@node131 nfs]# kubectl get pvc NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE nfs Terminating pvc-26703096-84df-4c18-88f5-16d0b09be156 1Mi RWX example-nfs 39m 无业务pod使用pvc时，删除pvc [root@node131 nfs]# kubectl delete po write-pod pod \"write-pod\" deleted [root@node131 nfs]# [root@node131 nfs]# kubectl get pvc NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE nfs Terminating pvc-26703096-84df-4c18-88f5-16d0b09be156 1Mi RWX example-nfs 41m [root@node131 nfs]# [root@node131 nfs]# [root@node131 nfs]# kubectl delete po read-pod pod \"read-pod\" deleted [root@node131 nfs]# [root@node131 nfs]# [root@node131 nfs]# kubectl get pvc No resources found in default namespace. [root@node131 nfs]# 上面阻塞的delete pvc操作，会删除pvc，同时由于pv的delete回收策略，该pvc对应的存储挂载目录也会删除 [root@node131 nfs]# kubectl get pvc No resources found in default namespace. [root@node131 nfs]# [root@node131 nfs]# [root@node131 nfs]# kubectl get pv No resources found [root@node131 nfs]# [root@node131 srv]# ll 总用量 16 -rw-r--r--. 1 root root 5140 2月 8 11:32 ganesha.log -rw-------. 1 root root 36 2月 8 10:46 nfs-provisioner.identity drwxr-xr-x. 3 root root 19 2月 8 10:46 v4old drwxr-xr-x. 3 root root 19 2月 8 10:46 v4recov -rw-------. 1 root root 667 2月 8 11:32 vfs.conf [root@node131 srv]# ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:9:3","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"配额测试 部署pod kubectl create -f deploy/kubernetes_incubator_nfs_provisioner/test_pod/custom-nfs-busybox-rc.yaml kubectl create -f deploy/kubernetes_incubator_nfs_provisioner/test_pod/nfs-web-rc.yaml kubectl create -f deploy/kubernetes_incubator_nfs_provisioner/test_pod/nfs-web-service.yaml 挂载目录下的数据情况，新增了index.html [root@node131 pvc-4f32a250-f6da-4534-80fd-196221b555d9]# ll -h 总用量 4.0K -rw-r--r--. 1 root root 611 2月 8 14:15 index.html -rw-r--r--. 1 root root 0 2月 8 11:57 SUCCESS [root@node131 pvc-4f32a250-f6da-4534-80fd-196221b555d9]# [root@node131 pvc-4f32a250-f6da-4534-80fd-196221b555d9]# [root@node131 pvc-4f32a250-f6da-4534-80fd-196221b555d9]# [root@node131 pvc-4f32a250-f6da-4534-80fd-196221b555d9]# cat index.html Mon Feb 8 06:14:38 UTC 2021 nfs-busybox-54846 Mon Feb 8 06:14:39 UTC 2021 nfs-busybox-8fqcr Mon Feb 8 06:14:44 UTC 2021 测试pvc的容量为1M，在挂载目录/srv/pvc-4f32a250-f6da-4534-80fd-196221b555d9下，写入个2M大小的文件。查看测试pod是否还能继续写入数据，观察可知，在nfs provisoner的默认参数下，测试pod还能继续往挂载目录中写入数据。index.html大小由11k新增到了14k并继续增加 [root@node131 pvc-4f32a250-f6da-4534-80fd-196221b555d9]# [root@node131 pvc-4f32a250-f6da-4534-80fd-196221b555d9]# ll -h 总用量 2.1M -rw-r--r--. 1 root root 11K 2月 8 14:28 index.html -rw-r--r--. 1 root root 0 2月 8 11:57 SUCCESS -rw-r--r--. 1 root root 2.0M 2月 8 14:25 tmp.2M [root@node131 pvc-4f32a250-f6da-4534-80fd-196221b555d9]# [root@node131 pvc-4f32a250-f6da-4534-80fd-196221b555d9]# [root@node131 pvc-4f32a250-f6da-4534-80fd-196221b555d9]# [root@node131 pvc-4f32a250-f6da-4534-80fd-196221b555d9]# pwd /srv/pvc-4f32a250-f6da-4534-80fd-196221b555d9 [root@node131 pvc-4f32a250-f6da-4534-80fd-196221b555d9]# [root@node131 pvc-4f32a250-f6da-4534-80fd-196221b555d9]# [root@node131 pvc-4f32a250-f6da-4534-80fd-196221b555d9]# ll -h 总用量 2.1M -rw-r--r--. 1 root root 14K 2月 8 14:31 index.html -rw-r--r--. 1 root root 0 2月 8 11:57 SUCCESS -rw-r--r--. 1 root root 2.0M 2月 8 14:25 tmp.2M [root@node131 pvc-4f32a250-f6da-4534-80fd-196221b555d9]# 目录挂载情况，有2个写pod和2个读pod共4个业务pod在运行 [root@node131 2129b202-2d91-400f-b04e-5e57f9c105b6]# mount |grep pvc 10.233.14.76:/export/pvc-4f32a250-f6da-4534-80fd-196221b555d9 on /var/lib/kubelet/pods/69448210-b1c1-4444-8c24-29024770acff/volumes/kubernetes.io~nfs/pvc-4f32a250-f6da-4534-80fd-196221b555d9 type nfs4 (rw,relatime,vers=4.1,rsize=1048576,wsize=1048576,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=10.233.14.76,local_lock=none,addr=10.233.14.76) 10.233.14.76:/export/pvc-4f32a250-f6da-4534-80fd-196221b555d9 on /var/lib/kubelet/pods/337827e0-4924-4afb-b41e-a19c522d59d6/volumes/kubernetes.io~nfs/pvc-4f32a250-f6da-4534-80fd-196221b555d9 type nfs4 (rw,relatime,vers=4.1,rsize=1048576,wsize=1048576,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=10.233.14.76,local_lock=none,addr=10.233.14.76) 10.233.14.76:/export/pvc-4f32a250-f6da-4534-80fd-196221b555d9 on /var/lib/kubelet/pods/888dd122-e529-4f36-bca4-828667c997dd/volumes/kubernetes.io~nfs/pvc-4f32a250-f6da-4534-80fd-196221b555d9 type nfs4 (rw,relatime,vers=4.1,rsize=1048576,wsize=1048576,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=10.233.14.76,local_lock=none,addr=10.233.14.76) 10.233.14.76:/export/pvc-4f32a250-f6da-4534-80fd-196221b555d9 on /var/lib/kubelet/pods/0298070d-66e2-43e1-947c-d4ae0f5fab4b/volumes/kubernetes.io~nfs/pvc-4f32a250-f6da-4534-80fd-196221b555d9 type nfs4 (rw,relatime,vers=4.1,rsize=1048576,wsize=1048576,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=10.233.14.76,local_lock=none,addr=10.233.14.76) [root@node131 2129b202-2d91-400f-b04e-5e57f9c105b6]# 删除测试pod，保留pv和pvc，检查挂载目录仍然存在。此时挂载目录大小\u003e2M 再重新部署测试pod，发现部署成功，说明pod使用pvc请求容量大小时并不检查挂载目录pvc要求数据大小。 实际上挂载了整个容量大小，如下图。 [root@node131 srv]# df -hT |grep pvc 文件系统 类型 容量 已用 可用 已用% 挂载点 10.233.14.76:/export/pvc-4f32a250-f6da-4534-80fd-196221b555d9 nfs4 17G 11G 6.8G 61% /var/lib/kubelet/pods/06940ab3-4d60-4015-8c39-3bb15b331e7f/volumes/kubernetes.io~nfs/pvc-4f32a250-f6da-4534-80fd-196221b555d9 考虑开启配额参数 删除原有 nfs_provisioner，修改 nfs_provisioner参数后，部署 kube","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:9:4","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"nfs-client-provisioner 如果集群系统中已有存储系统服务，则可使用nfs-subdir-external-provisioner项目组件来提供动态pv支持 Kubernetes NFS-Client Provisioner NFS subdir external provisioner is an automatic provisioner that use your existing and already configured NFS server to support dynamic provisioning of Kubernetes Persistent Volumes via Persistent Volume Claims. Persistent volumes are provisioned as ${namespace}-${pvcName}-${pvName}. nfs-subdir-external-provisioner ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:10:0","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"问题结论 PV共用机制，是否可以做到超分？是否可以有用户的概念？ 一个pv只能被一个pvc使用，pv实际上k8s的一种资源类型（类比node），没有用户的概念。用户可见并使用的是pvc，多个用户（pod）可以使用相同的pvc。 配额是依赖底层存储配置参数实现，如果使用pvc实现，则需要使用pv-provisioner封装存储组件来支持配额功能，此时由于对目录的配额限制会导致无法超分。 nfs的pvc 能否控制住大小？ pvc可以request使用量大小，但不是pvc和k8s来控制大小，实际上通过nfs的配额参数和xfs文件系统的存储配额参数设置实现 k8s只是通过pv和pvc管理存储信息，并通过vkubelet的olume manager对存储目录进行挂载和卸载操作 PV对多个Pod使用时，能否控制总量？ pod不直接使用pv，而是通过pv声明pvc方式来绑定pv使用 目前，如果不通过storageclass的动态方式（手动创建pv），或者storageclass中nfs-provision不使用配额参数，则无法实现存储总量控制。 PV是否能在线更新，比如扩容？ 无论是手动创建pv还是动态创建pv，如果直接修改pv（如，pv的Capacity从1M调整到2M），修改生效。但之前已创建的pvc的Capacity并没有发生变化（仍是原来的1M）。 如果通过修改pvc来更新存储资源pv的配置。需使用storageclass方式可以实现pvc-\u003epv的容量关联扩容。只有动态供应的pvc可以调整大小，供应pvc的存储类型必须支持调整大小。即满足如下条件： Kube-ApiServer 参数：PersistentVolumeClaimResize插件 使能 StorageClass 配置yaml的allowVolumeExpansion设置为true 在官方文档对StorageClass扩容支持的存储类型范围内 nfs无法通过通过pvc的resize扩容操作，来自动关联修改pv 如果底层存储出问题，k8s是否能够感知管理，故障恢复。 底层存储依赖于具体存储组件（如：nfs）实现的异常处理。或考虑把nfs组件封装成nfs-server + nfs-provisioner 当做k8s集群中的pod管理起来。 ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:11:0","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"参考 持久存储设计文档 存储类StorageClass nfs-subdir-external-provisioner https://www.cnblogs.com/panwenbin-logs/p/12196286.html ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:12:0","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"附录 ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:13:0","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"配置 StorageClass class.yaml kind:StorageClassapiVersion:storage.k8s.io/v1metadata:name:example-nfsprovisioner:example.com/nfsmountOptions:- vers=4.1 PersistentVolumeClaim claim.yaml kind:PersistentVolumeClaimapiVersion:v1metadata:name:nfsspec:storageClassName:example-nfsaccessModes:- ReadWriteManyresources:requests:storage:1Mi ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:13:1","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"dd命令 构造指定大小文件 # 从/dev/null每次读取1G数据，读5次，写入tmp.5G这个文件 # dd if=/dev/zero of=tmp.5G bs=1G count=5 dd if=/dev/zero of=tmp.2M bs=1M count=2 if=FILE : 指定输入文件，若不指定则从标注输入读取。这里指定为/dev/zero是Linux的一个伪文件，它可以产生连续不断的null流（二进制的0） of=FILE : 指定输出文件，若不指定则输出到标准输出 bs=BYTES : 每次读写的字节数，可以使用单位K、M、G等等。另外输入输出可以分别用ibs、obs指定，若使用bs，则表示是ibs和obs都是用该参数 count=BLOCKS : 读取的block数，block的大小由ibs指定（只针对输入参数） ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:13:2","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"开启xfs的quota特性 #什么结果都没有，这个表示没有设置配额 xfs_quota -x -c 'report' / mount -o remount,rw,uquota,prjquota / # 在开始划分分区的时候就要让分区的配额生效，添加一块硬盘作为docker的数据目录 #fdisk -l | grep sdb #Disk /dev/sdb: 53.7 GB, 53687091200 bytes, 104857600 sector 编辑/etc/fstab vi /etc/fstab [root@node131 nfs]# cat /etc/fstab # # /etc/fstab # Created by anaconda on Thu Dec 17 15:27:09 2020 # # Accessible filesystems, by reference, are maintained under '/dev/disk' # See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info # #/dev/mapper/centos_master-root / xfs defaults 0 0 /dev/mapper/centos_master-root / xfs defaults,usrquota,grpquota 0 0 UUID=d13f3d45-3ac2-4cda-b1ce-715d3153a900 /boot xfs defaults 0 0 注，类型如下： 根据用户(uquota/usrquota/quota) 根据组(gquota/grpquota) 根据目录(pquota/prjquota)(不能与grpquota同时设定) 卸载并重新挂载 #umount /home #mount -a #由于挂载了 /目录，采用重启操作 rebot now 2.2.3 检查 # mount | grep home mount | grep centos [root@node131 ~]# mount | grep centos /dev/mapper/centos_master-root on / type xfs (rw,relatime,seclabel,attr2,inode64,noquota) [root@node131 ~]# 结果：在本地虚拟机环境未生效，操作未成功。。。 ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:13:3","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"错误 新项目代码无法进行镜像制作 make container报错信息见下 [root@node1 nfs-ganesha-server-and-external-provisioner-master]# make container ./release-tools/verify-go-version.sh \"go\" fatal: Not a git repository (or any parent up to mount point /home) Stopping at filesystem boundary (GIT_DISCOVERY_ACROSS_FILESYSTEM not set). mkdir -p bin echo '' | tr ';' '\\n' | while read -r os arch suffix; do \\ if ! (set -x; CGO_ENABLED=0 GOOS=\"$os\" GOARCH=\"$arch\" go build -a -ldflags ' -X main.version= -extldflags \"-static\"' -o \"./bin/nfs-provisioner$suffix\" ./cmd/nfs-provisioner); then \\ echo \"Building nfs-provisioner for GOOS=$os GOARCH=$arch failed, see error(s) above.\"; \\ exit 1; \\ fi; \\ done + CGO_ENABLED=0 + GOOS= + GOARCH= + go build -a -ldflags ' -X main.version= -extldflags \"-static\"' -o ./bin/nfs-provisioner ./cmd/nfs-provisioner fatal: Not a git repository (or any parent up to mount point /home) Stopping at filesystem boundary (GIT_DISCOVERY_ACROSS_FILESYSTEM not set). docker build -t nfs-provisioner:latest -f Dockerfile --label revision= . Sending build context to Docker daemon 69.19MB Step 1/19 : FROM fedora:30 AS build 30: Pulling from library/fedora 401909e6e2aa: Pull complete Digest: sha256:3a0c8c86d8ac2d1bbcfd08d40d3b757337f7916fb14f40efcb1d1137a4edef45 Status: Downloaded newer image for fedora:30 ---\u003e 177d5adf0c6c Step 2/19 : RUN dnf install -y tar gcc cmake-3.14.2-1.fc30 autoconf libtool bison flex make gcc-c++ krb5-devel dbus-devel jemalloc-devel libnfsidmap-devel libnsl2-devel userspace-rcu-devel patch libblkid-devel ---\u003e Running in b6cb5632e5a4 Fedora Modular 30 - x86_64 0.0 B/s | 0 B 04:00 Errors during downloading metadata for repository 'fedora-modular': - Curl error (6): Couldn't resolve host name for https://mirrors.fedoraproject.org/metalink?repo=fedora-modular-30\u0026arch=x86_64 [Could not resolve host: mirrors.fedoraproject.org] Error: Failed to download metadata for repo 'fedora-modular': Cannot prepare internal mirrorlist: Curl error (6): Couldn't resolve host name for https://mirrors.fedoraproject.org/metalink?repo=fedora-modular-30\u0026arch=x86_64 [Could not resolve host: mirrors.fedoraproject.org] The command '/bin/sh -c dnf install -y tar gcc cmake-3.14.2-1.fc30 autoconf libtool bison flex make gcc-c++ krb5-devel dbus-devel jemalloc-devel libnfsidmap-devel libnsl2-devel userspace-rcu-devel patch libblkid-devel' returned a non-zero code: 1 make: *** [container-nfs-provisioner] Error 1 [root@node1 nfs-ganesha-server-and-external-provisioner-master]# 改用直接拉取镜像方式获得。 开启配额参数， nfs provisioner 启动报错 报错信息 Error creating xfs quotaer! xfs path /export was not mounted with pquota nor prjquota 系统的挂载盘使用的是xfs文件系统的默认参数，没有开启配额功能 所以无法挂载成功 [root@node131 /]# mount | grep centos /dev/mapper/centos_master-root on / type xfs (rw,relatime,seclabel,attr2,inode64,noquota) [root@node131 /]# cat /etc/fstab # # /etc/fstab # Created by anaconda on Thu Dec 17 15:27:09 2020 # # Accessible filesystems, by reference, are maintained under '/dev/disk' # See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info # /dev/mapper/centos_master-root / xfs defaults 0 0 UUID=d13f3d45-3ac2-4cda-b1ce-715d3153a900 /boot xfs defaults 0 0 https://kim1024.github.io/2018/11/27/quota-with-xfs.html https://blog.csdn.net/weixin_36458030/article/details/112232427 CentOS关于quota的总结与实践 https://blog.csdn.net/mnasd/article/details/80766756 https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/531-online-pv-resizing ","date":"2021-02-08","objectID":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/:13:4","tags":["K8S"],"title":"k8s dynamic provisioning and storage 介绍","uri":"/posts/2021/02/k8s-dynamic-provisioning-and-storage-%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"PV和PVC的概念和设计原理","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"介绍K8S的PV和PVC概念和设计原理。 ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:0:0","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"k8s的PV和PVC概念 ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:1:0","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"卷 Container 中的文件在磁盘上是临时存放的，这给 Container 中运行的较重要的应用 程序带来一些问题。 问题之一是当容器崩溃时文件丢失。kubelet 会重新启动容器， 但容器会以干净的状态重启。 第二个问题会在同一 Pod 中运行多个容器并共享文件时出现。 Kubernetes 卷（Volume） 这一抽象概念能够解决这两个问题。 Kubernetes 支持很多类型的卷。 Pod 可以同时使用任意数目的卷类型。 临时卷类型的生命周期与 Pod 相同，但持久卷可以比 Pod 的存活期长。 因此，卷的存在时间会超出 Pod 中运行的所有容器，并且在容器重新启动时数据也会得到保留。 当 Pod 不再存在时，卷也将不再存在。 卷的核心是包含一些数据的一个目录，Pod 中的容器可以访问该目录。 所采用的特定的卷类型将决定该目录如何形成的、使用何种介质保存数据以及目录中存放 的内容。 configMap configMap 卷 提供了向 Pod 注入配置数据的方法。 ConfigMap 对象中存储的数据可以被 configMap 类型的卷引用，然后被 Pod 中运行的 容器化应用使用。 引用 configMap 对象时，你可以在 volume 中通过它的名称来引用。 你可以自定义 ConfigMap 中特定条目所要使用的路径。 下面的配置显示了如何将名为 log-config 的 ConfigMap 挂载到名为 configmap-pod 的 Pod 中： apiVersion:v1kind:Podmetadata:name:configmap-podspec:containers:- name:testimage:busyboxvolumeMounts:- name:config-volmountPath:/etc/configvolumes:- name:config-volconfigMap:name:log-configitems:- key:log_levelpath:log_level log-config ConfigMap 以卷的形式挂载，并且存储在 log_level 条目中的所有内容 都被挂载到 Pod 的 /etc/config/log_level 路径下。 请注意，这个路径来源于卷的 mountPath 和 log_level 键对应的 path。 说明： 在使用 ConfigMap 之前你首先要创建它。 容器以 subPath 卷挂载方式使用 ConfigMap 时，将无法接收 ConfigMap 的更新。 文本数据挂载成文件时采用 UTF-8 字符编码。如果使用其他字符编码形式，可使用 binaryData 字段。 emptyDir 当 Pod 分派到某个 Node 上时，emptyDir 卷会被创建，并且在 Pod 在该节点上运行期间，卷一直存在。 就像其名称表示的那样，卷最初是空的。 尽管 Pod 中的容器挂载 emptyDir 卷的路径可能相同也可能不同，这些容器都可以读写 emptyDir 卷中相同的文件。 当 Pod 因为某些原因被从节点上删除时，emptyDir 卷中的数据也会被永久删除。 说明： 容器崩溃并不会导致 Pod 被从节点上移除，因此容器崩溃期间 emptyDir 卷中的数据是安全的。 emptyDir 的一些用途： 缓存空间，例如基于磁盘的归并排序。 为耗时较长的计算任务提供检查点，以便任务能方便地从崩溃前状态恢复执行。 在 Web 服务器容器服务数据时，保存内容管理器容器获取的文件。 hostPath hostPath 卷能将主机节点文件系统上的文件或目录挂载到你的 Pod 中。 虽然这不是大多数 Pod 需要的，但是它为一些应用程序提供了强大的逃生舱。 例如，hostPath 的一些用法有： 运行一个需要访问 Docker 内部机制的容器；可使用 hostPath 挂载 /var/lib/docker 路径。 在容器中运行 cAdvisor 时，以 hostPath 方式挂载 /sys。 允许 Pod 指定给定的 hostPath 在运行 Pod 之前是否应该存在，是否应该创建以及应该以什么方式存在。 除了必需的 path 属性之外，用户可以选择性地为 hostPath 卷指定 type。 Secret secret 卷用来给 Pod 传递敏感信息，例如密码。你可以将 Secret 存储在 Kubernetes API 服务器上，然后以文件的形式挂在到 Pod 中，无需直接与 Kubernetes 耦合。 secret 卷由 tmpfs（基于 RAM 的文件系统）提供存储，因此它们永远不会被写入非易失性 （持久化的）存储器。 说明： 使用前你必须在 Kubernetes API 中创建 secret。 说明： 容器以 subPath 卷挂载方式挂载 Secret 时，将感知不到 Secret 的更新。 secret说明文档：https://kubernetes.io/zh/docs/concepts/configuration/secret/ nfs nfs 卷能将 NFS (网络文件系统) 挂载到你的 Pod 中。 不像 emptyDir 那样会在删除 Pod 的同时也会被删除，nfs 卷的内容在删除 Pod 时会被保存，卷只是被卸载。 这意味着 nfs 卷可以被预先填充数据，并且这些数据可以在 Pod 之间共享。 注意： 在使用 NFS 卷之前，你必须运行自己的 NFS 服务，并将目标 share 导出备用。 nfs示例 persistentVolumeClaim persistentVolumeClaim 卷用来将持久卷（PersistentVolume） 挂载到 Pod 中。 持久卷声明（PersistentVolumeClaim）是用户在不知道特定云环境细节的情况下\"声明\"持久存储 （例如 GCE PersistentDisk 或者 iSCSI 卷）的一种方法。 更多详情请参考持久卷示例 ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:1:1","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"持久卷 persistent-volumes概念 存储的管理是一个与计算实例的管理完全不同的问题。PersistentVolume 子系统为用户 和管理员提供了一组 API，将存储如何供应的细节从其如何被使用中抽象出来。 为了实现这点，我们引入了两个新的 API 资源：PersistentVolume 和 PersistentVolumeClaim。 持久卷（PersistentVolume，PV）是集群中的一块存储，可以由管理员事先供应，或者 使用存储类（Storage Class）来动态供应。 持久卷是集群资源，就像节点也是集群资源一样。PV 持久卷和普通的 Volume 一样，也是使用 卷插件来实现的，只是它们拥有独立于任何使用 PV 的 Pod 的生命周期。 此 API 对象中记述了存储的实现细节，无论其背后是 NFS、iSCSI 还是特定于云平台的存储系统。 持久卷声明（PersistentVolumeClaim，PVC）表达的是用户对存储的请求。概念上与 Pod 类似。 Pod 会耗用节点资源，而 PVC 声明会耗用 PV 资源。Pod 可以请求特定数量的资源（CPU 和内存）；同样 PVC 声明也可以请求特定的大小和访问模式 （例如，可以要求 PV 卷能够以 ReadWriteOnce、ReadOnlyMany 或 ReadWriteMany 模式之一来挂载，参见访问模式）。 尽管 PersistentVolumeClaim 允许用户消耗抽象的存储资源，常见的情况是针对不同的 问题用户需要的是具有不同属性（如，性能）的 PersistentVolume 卷。 集群管理员需要能够提供不同性质的 PersistentVolume，并且这些 PV 卷之间的差别不 仅限于卷大小和访问模式，同时又不能将卷是如何实现的这些细节暴露给用户。 为了满足这类需求，就有了 存储类（StorageClass） 资源。 PV不属于任何命名空间, 它跟节点（node）一样是集群层面的资源，区别于pod和PVC。由系统管理员创建管理。 当集群用户需要在其pod中使用持久化存储时，他们首先创建PVC清单，指定所需要的最低容量要求和访问模式，然后用户将待久卷声明清单提交给Kubernetes API服务器，Kubernetes将找到可匹配的PV并将其绑定到PVC。PVC可以当作pod中的一个卷来使用，其他用户不能使用相同的PV，除非先通过删除PVC绑定来释放。 供应 PV 卷的供应有两种方式：静态供应或动态供应。 静态供应 集群管理员创建若干 PV 卷。这些卷对象带有真实存储的细节信息，并且对集群 用户可用（可见）。PV 卷对象存在于 Kubernetes API 中，可供用户消费（使用）。 动态供应 如果管理员所创建的所有静态 PV 卷都无法与用户的 PersistentVolumeClaim 匹配， 集群可以尝试为该 PVC 申领动态供应一个存储卷。 这一供应操作是基于 StorageClass 来实现的：PVC 申领必须请求某个 存储类，同时集群管理员必须 已经创建并配置了该类，这样动态供应卷的动作才会发生。 如果 PVC 申领指定存储类为 “\"，则相当于为自身禁止使用动态供应的卷。 为了基于存储类完成动态的存储供应，集群管理员需要在 API 服务器上启用 DefaultStorageClass 准入控制器。 举例而言，可以通过保证 DefaultStorageClass 出现在 API 服务器组件的 –enable-admission-plugins 标志值中实现这点；该标志的值可以是逗号 分隔的有序列表。关于 API 服务器标志的更多信息，可以参考 kube-apiserver 文档。 绑定 用户创建一个带有特定存储容量和特定访问模式需求的 PersistentVolumeClaim 对象； 在动态供应场景下，这个 PVC 对象可能已经创建完毕。 主控节点中的控制回路监测新的 PVC 对象，寻找与之匹配的 PV 卷（如果可能的话）， 并将二者绑定到一起。 如果为了新的 PVC 申领动态供应了 PV 卷，则控制回路总是将该 PV 卷绑定到这一 PVC 申领。 否则，用户总是能够获得他们所请求的资源，只是所获得的 PV 卷可能会超出所请求的配置。 一旦绑定关系建立，则 PersistentVolumeClaim 绑定就是排他性的，无论该 PVC 申领是 如何与 PV 卷建立的绑定关系。 PVC 申领与 PV 卷之间的绑定是一种一对一的映射，实现上使用 ClaimRef 来记述 PV 卷 与 PVC 申领间的双向绑定关系。 如果找不到匹配的 PV 卷，PVC 申领会无限期地处于未绑定状态（即pvc处于pending状态）。 当与之匹配的 PV 卷可用时，PVC 申领会被绑定。 例如，即使某集群上供应了很多 50 Gi 大小的 PV 卷，也无法与请求 100 Gi 大小的存储的 PVC 匹配。当新的 100 Gi PV 卷被加入到集群时，该 PVC 才有可能被绑定。 [root@node131 k8s_pv_pvc]# kubectl get pvc -A NAMESPACE NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE default nfs-pv-provisioning-demo Pending 7s [root@node131 k8s_pv_pvc]# [root@node131 k8s_pv_pvc]# kubectl describe pvc nfs-pv-provisioning-demo Name: nfs-pv-provisioning-demo Namespace: default StorageClass: Status: Pending Volume: Labels: demo=nfs-pv-provisioning Annotations: \u003cnone\u003e Finalizers: [kubernetes.io/pvc-protection] Capacity: Access Modes: VolumeMode: Filesystem Used By: \u003cnone\u003e Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal FailedBinding 5s (x3 over 27s) persistentvolume-controller no persistent volumes available for this claim and no storage class is set [root@node131 k8s_pv_pvc]# 使用 Pod 将 PVC 申领当做存储卷来使用。集群会检视 PVC 申领，找到所绑定的卷，并 为 Pod 挂载该卷。对于支持多种访问模式的卷，用户要在 Pod 中以卷的形式使用申领 时指定期望的访问模式。 一旦用户有了申领对象并且该申领已经被绑定，则所绑定的 PV 卷在用户仍然需要它期间 一直属于该用户。用户通过在 Pod 的 volumes 块中包含 persistentVolumeClaim 节区来调度 Pod，访问所申领的 PV 卷。 相关细节可参阅使用申领作为卷。 保护使用中的存储对象 保护使用中的存储对象（Storage Object in Use Protection）这一功能特性的目的 是确保仍被 Pod 使用的 PersistentVolumeClaim（PVC）对象及其所绑定的 PersistentVolume（PV）对象在系统中不会被删除，因为这样做可能会引起数据丢失。 说明： 当使用某 PVC 的 Pod 对象仍然存在时，认为该 PVC 仍被此 Pod 使用。 如果用户删除被某 Pod 使用的 PVC 对象，该 PVC 申领不会被立即移除。 PVC 对象的移除会被推迟，直至其不再被任何 Pod 使用。 此外，如果管理员删除已绑定到某 PVC 申领的 PV 卷，该 PV 卷也不会被立即移除。 PV 对象的移除也要推迟到该 PV 不再绑定到 PVC。 你可以看到当 PVC 的状态为 Terminating 且其 Finalizers 列表中包含 kubernetes.io/pvc-protection 时，PVC 对象是处于被保护状态的。 每个 PV 对象都包含 spec 部分和 status 部分，分别对应卷的规约和状态。 PersistentVolume 对象的名称必须是合法的 DNS 子域名. PV说明 apiVersion:v1kind:PersistentVolumemetadata:name:pv0003spec:capacity:storage:5GivolumeMode:FilesystemaccessModes:- ReadWriteOncepersistentVolumeReclaimPolicy:RecyclestorageClassName:slowmountOptions:- hard- nfsvers=4.1nfs:path:/tmpserver:192.168.182.131 说明： 在集群中使用持久卷存储通常需要一些特定于具体卷类型的辅助程序。 在这个例子中，PersistentVolume 是 NFS 类型的，因此需要辅助程序 /sbin/mount.nfs 来支持挂载 NFS 文件系统。 容量 一","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:1:2","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"PV和PVC设计目标 Kubernetes makes no guarantees at runtime that the underlying storage exists or is available. High availability is left to the storage provider. Goals Allow administrators to describe available storage.（通过pv来定义存储资源） Allow pod authors to discover and request persistent volumes to use with pods.（允许pod使用像使用pod的request资源一样使用存储pv） Enforce security through access control lists and securing storage to the same namespace as the pod volume.（通过访问控制列表机制来保证存储使用安全） Enforce quotas through admission control.（通过准入机制实现存储配额） Enforce scheduler rules by resource counting.（基于资源数量调度，调度pvc-\u003epv） Ensure developers can rely on storage being available without being closely bound to a particular disk, server, network, or storage device.(通过抽象层设计，pod与具体的存储资源隔离) ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:2:0","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"PersistentVolumeController分析 ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:3:0","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"实例化 volume manager controller 来管理persistentvolume kubernetes\\pkg\\controller\\volume\\persistentvolume\\ // NewController creates a new PersistentVolume controller controller := \u0026PersistentVolumeController{ volumes: newPersistentVolumeOrderedIndex(), claims: cache.NewStore(cache.DeletionHandlingMetaNamespaceKeyFunc), kubeClient: p.KubeClient, eventRecorder: eventRecorder, runningOperations: goroutinemap.NewGoRoutineMap(true /* exponentialBackOffOnError */), cloud: p.Cloud, enableDynamicProvisioning: p.EnableDynamicProvisioning, clusterName: p.ClusterName, createProvisionedPVRetryCount: createProvisionedPVRetryCount, createProvisionedPVInterval: createProvisionedPVInterval, claimQueue: workqueue.NewNamed(\"claims\"), volumeQueue: workqueue.NewNamed(\"volumes\"), resyncPeriod: p.SyncPeriod, operationTimestamps: metrics.NewOperationStartTimeCache(), } ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:3:1","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"pv cache 构造 newPersistentVolumeOrderedIndex -\u003e persistentVolumeOrderedIndex pv在cache中按AccessModes索引，并按存储量大小排序 // persistentVolumeOrderedIndex is a cache.Store that keeps persistent volumes // indexed by AccessModes and ordered by storage capacity. type persistentVolumeOrderedIndex struct { store cache.Indexer } func newPersistentVolumeOrderedIndex() persistentVolumeOrderedIndex { return persistentVolumeOrderedIndex{cache.NewIndexer(cache.MetaNamespaceKeyFunc, cache.Indexers{\"accessmodes\": accessModesIndexFunc})} } 进行pv的同步操作 如果 volume.Spec.ClaimRef == nil 说明pv没有被pvc绑定使用，直接更新pv：ctrl.updateVolumePhase(volume, v1.VolumeAvailable, “\") volume.Spec.ClaimRef != nil 说明pv被pvc绑定使用，需要进行相应逻辑处理 说明：pvc和 pv 是通过UID来进行关联标识：claim.UID != volume.Spec.ClaimRef.UID ? // syncVolume is the main controller method to decide what to do with a volume. // It's invoked by appropriate cache.Controller callbacks when a volume is // created, updated or periodically synced. We do not differentiate between // these events. func (ctrl *PersistentVolumeController) syncVolume(volume *v1.PersistentVolume) error { } ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:3:2","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"为pvc匹配查找最佳pv 根据声明的pvc，在pv列表中匹配查找 先按pvc要求的AccessModes，过滤出符合要求的pv候选列表 在pv候选列表中优选出最佳的pv // findBestMatchForClaim is a convenience method that finds a volume by the claim's AccessModes and requests for Storage func (pvIndex *persistentVolumeOrderedIndex) findBestMatchForClaim(claim *v1.PersistentVolumeClaim, delayBinding bool) (*v1.PersistentVolume, error) { return pvIndex.findByClaim(claim, delayBinding) } // find returns the nearest PV from the ordered list or nil if a match is not found func (pvIndex *persistentVolumeOrderedIndex) findByClaim(claim *v1.PersistentVolumeClaim, delayBinding bool) (*v1.PersistentVolume, error) { // PVs are indexed by their access modes to allow easier searching. Each // index is the string representation of a set of access modes. There is a // finite number of possible sets and PVs will only be indexed in one of // them (whichever index matches the PV's modes). // // A request for resources will always specify its desired access modes. // Any matching PV must have at least that number of access modes, but it // can have more. For example, a user asks for ReadWriteOnce but a GCEPD // is available, which is ReadWriteOnce+ReadOnlyMany. // // Searches are performed against a set of access modes, so we can attempt // not only the exact matching modes but also potential matches (the GCEPD // example above). allPossibleModes := pvIndex.allPossibleMatchingAccessModes(claim.Spec.AccessModes) for _, modes := range allPossibleModes { volumes, err := pvIndex.listByAccessModes(modes) if err != nil { return nil, err } bestVol, err := pvutil.FindMatchingVolume(claim, volumes, nil /* node for topology binding*/, nil /* exclusion map */, delayBinding) if err != nil { return nil, err } if bestVol != nil { return bestVol, nil } } return nil, nil } 优选算法函数如下，该函数会被PV controller 和 scheduler 使用 参数delayBinding 只在PV controller流程为true 参数node和excludedVolumes 只在scheduler流程设置 // FindMatchingVolume goes through the list of volumes to find the best matching volume // for the claim. // // This function is used by both the PV controller and scheduler. // // delayBinding is true only in the PV controller path. When set, prebound PVs are still returned // as a match for the claim, but unbound PVs are skipped. // // node is set only in the scheduler path. When set, the PV node affinity is checked against // the node's labels. // // excludedVolumes is only used in the scheduler path, and is needed for evaluating multiple // unbound PVCs for a single Pod at one time. As each PVC finds a matching PV, the chosen // PV needs to be excluded from future matching. func FindMatchingVolume( claim *v1.PersistentVolumeClaim, volumes []*v1.PersistentVolume, node *v1.Node, excludedVolumes map[string]*v1.PersistentVolume, delayBinding bool) (*v1.PersistentVolume, error) { } ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:3:3","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"Matching and binding PVC-\u003ePV PersistentVolumeClaimBinder尝试查找与用户请求最接近的可用卷。如果存在，则通过将pv上的引用绑定到pvc。如果找不到合适的匹配，请求可能无法满足。 claim(PVC)必须请求访问模式和存储容量。这是因为内部PV是按其AccessModes索引的，目标PV在某种程度上是按其容量排序的。pvc声明可以请求以下多个属性中的一个来更好地匹配PV：卷名称、选择器和卷类(当前实现为注释)。 PV可以定义一个ClaimRef，它会对PVC的匹配产生很大的影响(但不是绝对的保证)。PV还可以定义标签、注释和卷类(当前作为注释实现)以更好地针对目标PVC。 PVC-\u003ePV匹配算法说明： As of Kubernetes version 1.4, the following algorithm describes in more details how a claim is matched to a PV: Only PVs with accessModes equal to or greater than the claim’s requested accessModes are considered. “Greater” here means that the PV has defined more modes than needed by the claim, but it also defines the mode requested by the claim. The potential PVs above are considered in order of the closest access mode match, with the best case being an exact match, and a worse case being more modes than requested by the claim. Each PV above is processed. If the PV has a claimRef matching the claim, and the PV’s capacity is not less than the storage being requested by the claim then this PV will bind to the claim. Done. Otherwise, if the PV has the “volume.alpha.kubernetes.io/storage-class” annotation defined then it is skipped and will be handled by Dynamic Provisioning. Otherwise, if the PV has a claimRef defined, which can specify a different claim or simply be a placeholder, then the PV is skipped. 这点说明了 PV和PVC之间的关系是1对1 Otherwise, if the claim is using a selector but it does not match the PV’s labels (if any) then the PV is skipped. But, even if a claim has selectors which match a PV that does not guarantee a match since capacities may differ. Otherwise, if the PV’s “volume.beta.kubernetes.io/storage-class” annotation (which is a placeholder for a volume class) does not match the claim’s annotation (same placeholder) then the PV is skipped. If the annotations for the PV and PVC are empty they are treated as being equal. Otherwise, what remains is a list of PVs that may match the claim. Within this list of remaining PVs, the PV with the smallest capacity that is also equal to or greater than the claim’s requested storage is the matching PV and will be bound to the claim. Done. In the case of two or more PVCs matching all of the above criteria, the first PV (remember the PV order is based on accessModes) is the winner. 候选PV列表中最小资源满足的PV为最佳优选结果 Note: if no PV matches the claim and the claim defines a StorageClass (or a default StorageClass has been defined) then a volume will be dynamically provisioned. ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:4:0","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"测试NFS-PV-PVC 下面的示例演示如何从单个nfs server的POD RC控制器导出NFS共享，并将其导入web的两个RC控制器。 ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:5:0","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"nfs server # Copyright 2016 The Kubernetes Authors.## Licensed under the Apache License, Version 2.0 (the \"License\");# you may not use this file except in compliance with the License.# You may obtain a copy of the License at## http://www.apache.org/licenses/LICENSE-2.0## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an \"AS IS\" BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.FROMcentosRUN yum -y install /usr/bin/ps nfs-utils \u0026\u0026 yum clean allRUN mkdir -p /exportsADD run_nfs.sh /usr/local/bin/ADD index.html /tmp/index.htmlRUN chmod 644 /tmp/index.html# expose mountd 20048/tcp and nfsd 2049/tcp and rpcbind 111/tcpEXPOSE2049/tcp 20048/tcp 111/tcp 111/udpENTRYPOINT [\"/usr/local/bin/run_nfs.sh\", \"/exports\"] # 制作镜像 docker build -t k8s.gcr.io/volume-nfs:0.8 . docker save k8s.gcr.io/volume-nfs:0.8 -o volume-nfs-img.tar # 在测试环境中导出镜像 docker load -i volume-nfs-img.tar ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:5:1","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"NFS server part 把nfs测试配置脚本文件examples/staging/volumes/nfs拷贝到测试环境中 修改下测试镜像名称：如busybox和nginx 按需要， 创建 gce-pv # If you are on GCE, create a GCE PD-based PVC: # kubectl create -f examples/staging/volumes/nfs/provisioner/nfs-server-gce-pv.yaml # kubectl create -f nfs/provisioner/nfs-server-gce-pv.yaml test pv和 pvc # test pv kubectl create -f nfs/test/pv0001.yaml # test pvc kubectl create -f nfs/test/pvc-pv0001.yaml 创建 NFS server and service #kubectl create -f examples/staging/volumes/nfs/nfs-server-rc.yaml #kubectl create -f examples/staging/volumes/nfs/nfs-server-service.yaml kubectl create -f nfs/custom-nfs-server-rc.yaml kubectl create -f nfs/nfs-server-service.yaml 说明创建pod时，其使用的pvc必须为bound状态才能进行调度 Tolerations: node.kubernetes.io/not-ready:NoExecute op=Exists for 300s node.kubernetes.io/unreachable:NoExecute op=Exists for 300s Events: Type Reason Age From Message ---- ------ ---- ---- ------- Warning FailedScheduling 29s default-scheduler 0/1 nodes are available: 1 persistentvolumeclaim \"nfs-pv-provisioning-demo\" not found. Warning FailedScheduling 29s default-scheduler 0/1 nodes are available: 1 persistentvolumeclaim \"nfs-pv-provisioning-demo\" not found. 创建基于NFS的pv和pvc 检查下nfs-server kubectl describe services nfs-server nfs的服务端口 [root@node131 k8s_pv_pvc]# kubectl describe services nfs-server Name: nfs-server Namespace: default Labels: \u003cnone\u003e Annotations: \u003cnone\u003e Selector: role=nfs-server Type: ClusterIP IP Families: \u003cnone\u003e IP: 10.233.63.192 IPs: 10.233.63.192 Port: nfs 2049/TCP TargetPort: 2049/TCP Endpoints: 10.233.124.46:2049 Port: mountd 20048/TCP TargetPort: 20048/TCP Endpoints: 10.233.124.46:20048 Port: rpcbind 111/TCP TargetPort: 111/TCP Endpoints: 10.233.124.46:111 Session Affinity: None Events: \u003cnone\u003e 然后再创建nfs的pv和pvc #kubectl create -f examples/staging/volumes/nfs/nfs-pv.yaml #kubectl create -f examples/staging/volumes/nfs/nfs-pvc.yaml kubectl create -f nfs/custom-nfs-pv.yaml kubectl create -f nfs/custom-nfs-pvc.yaml [root@node131 k8s_pv_pvc]# kubectl create -f nfs/nfs-pv.yaml persistentvolume/nfs created [root@node131 k8s_pv_pvc]# kubectl get pv NAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS REASON AGE nfs 1Mi RWX Retain Available 6s [root@node131 k8s_pv_pvc]# kubectl describe pv nfs Name: nfs Labels: \u003cnone\u003e Annotations: \u003cnone\u003e Finalizers: [kubernetes.io/pv-protection] StorageClass: Status: Available Claim: Reclaim Policy: Retain Access Modes: RWX VolumeMode: Filesystem Capacity: 1Mi Node Affinity: \u003cnone\u003e Message: Source: Type: NFS (an NFS mount that lasts the lifetime of a pod) Server: nfs-server.default.svc.cluster.local Path: /tmp/data ReadOnly: false Events: \u003cnone\u003e [root@node131 k8s_pv_pvc]# [root@node131 k8s_pv_pvc]# kubectl create -f nfs/nfs-pvc.yaml persistentvolumeclaim/nfs created [root@node131 k8s_pv_pvc]# [root@node131 k8s_pv_pvc]# [root@node131 k8s_pv_pvc]# kubectl get pv NAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS REASON AGE nfs 1Mi RWX Retain Bound default/nfs 114s [root@node131 k8s_pv_pvc]# [root@node131 k8s_pv_pvc]# kubectl get pvc NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE nfs Bound nfs 1Mi RWX 16s [root@node131 k8s_pv_pvc]# [root@node131 k8s_pv_pvc]# 此时再查看pv和pvc的信息，能够看到注解信息有变化，状态为Status: Bound [root@node131 k8s_pv_pvc]# kubectl describe pv nfs Name: nfs Labels: \u003cnone\u003e Annotations: pv.kubernetes.io/bound-by-controller: yes Finalizers: [kubernetes.io/pv-protection] StorageClass: Status: Bound Claim: default/nfs Reclaim Policy: Retain Access Modes: RWX VolumeMode: Filesystem Capacity: 1Mi Node Affinity: \u003cnone\u003e Message: Source: Type: NFS (an NFS mount that lasts the lifetime of a pod) Server: nfs-server.default.svc.cluster.local Path: /tmp/data ReadOnly: false Events: \u003cnone\u003e [root@node131 k8s_pv_pvc]# [root@node131 k8s_pv_pvc]# [root@node131 k8s_pv_pvc]# kubectl describe pvc nfs Name: nfs Namespace: default StorageClass: Status: Bound Volume: nfs Labels: \u003cnone\u003e Annotations: pv.kubernetes.io/bind-completed: yes pv.kubernetes.io/bound-by-controller: ye","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:5:2","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"测试的pv和pvc信息 [root@node131 ~]# kubectl describe pv Name: nfs Labels: \u003cnone\u003e Annotations: pv.kubernetes.io/bound-by-controller: yes Finalizers: [kubernetes.io/pv-protection] StorageClass: Status: Bound Claim: default/nfs Reclaim Policy: Retain Access Modes: RWX VolumeMode: Filesystem Capacity: 1Mi Node Affinity: \u003cnone\u003e Message: Source: Type: NFS (an NFS mount that lasts the lifetime of a pod) Server: 10.233.16.102 Path: /exports ReadOnly: false Events: \u003cnone\u003e [root@node131 ~]# [root@node131 ~]# [root@node131 ~]# kubectl describe pvc Name: nfs Namespace: default StorageClass: Status: Bound Volume: nfs Labels: \u003cnone\u003e Annotations: pv.kubernetes.io/bind-completed: yes pv.kubernetes.io/bound-by-controller: yes Finalizers: [kubernetes.io/pvc-protection] Capacity: 1Mi Access Modes: RWX VolumeMode: Filesystem Used By: nfs-busybox-b8wdw nfs-busybox-hvc8w nfs-web-7bnhj nfs-web-mxpx9 Events: \u003cnone\u003e ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:5:3","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"部署 # create nfs server kubectl create -f nfs/custom-nfs-server-rc.yaml kubectl create -f nfs/nfs-server-service.yaml # create nfs pv pvc kubectl create -f nfs/custom-nfs-pv.yaml kubectl create -f nfs/custom-nfs-pvc.yaml # create busybox write kubectl create -f nfs/custom-nfs-busybox-rc.yaml # create web read kubectl create -f nfs/nfs-web-rc.yaml kubectl create -f nfs/nfs-web-service.yaml ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:5:4","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"卸载 # remove web read kubectl delete -f nfs/nfs-web-service.yaml kubectl delete -f nfs/nfs-web-rc.yaml # remove busybox write kubectl delete -f nfs/custom-nfs-busybox-rc.yaml # remove nfs pv pvc kubectl delete -f nfs/nfs-pvc.yaml kubectl delete -f nfs/custom-nfs-pv.yaml # remove nfs server kubectl delete -f nfs/nfs-server-service.yaml kubectl delete -f nfs/custom-nfs-server-rc.yaml ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:5:5","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"问题 启动测试pod，进行mount时失败 Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Scheduled 26s default-scheduler Successfully assigned default/nfs-busybox-jwshl to node131 Warning FailedMount 11s (x6 over 27s) kubelet MountVolume.SetUp failed for volume \"nfs\" : mount failed: exit status 32 Mounting command: mount Mounting arguments: -t nfs nfs-server.default.svc.cluster.local:/tmp/data /var/lib/kubelet/pods/d4ca8ca9-e1c8-4610-8a74-f0fdea827fee/volumes/kubernetes.io~nfs/nfs Output: mount: 文件系统类型错误、选项错误、nfs-server.default.svc.cluster.local:/tmp/data 上有坏超级块、 缺少代码页或助手程序，或其他错误 (对某些文件系统(如 nfs、cifs) 您可能需要 一款 /sbin/mount.\u003c类型\u003e 助手程序) 有些情况下在 syslog 中可以找到一些有用信息- 请尝试 dmesg | tail 这样的命令看看。 首先检查 内核是否支持nfs文件系统格式，方法如下 cat /proc/filesystems 如果能够看到 nfs 或者nfs4字样就说明内核支持nfs格式的文件系统，否则需要重新编译新的支持nfs文件系统的内核。 如果检查内核支持nfs格式的文件系统后，检查mount.nfs是否安装： ls /sbin/mount.* 看是否有 mount.nfs 或者 mount.nfs4 如果没有需要安装 nfs_utils ls /sbin/mount.* yum install nfs-utils (redhat系列) yum install -y nfs-utils apt-get install common(ubuntu系列) apt-get install nfs-common 挂载域名无法解析，使用ip地址标识 ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:6:0","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"Output: mount.nfs: Protocol not supported Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Scheduled 28s default-scheduler Successfully assigned default/nfs-busybox-k6dpc to node131 Warning FailedMount 11s (x6 over 27s) kubelet MountVolume.SetUp failed for volume \"nfs\" : mount failed: exit status 32 Mounting command: mount Mounting arguments: -t nfs 10.233.124.49:/tmp/data /var/lib/kubelet/pods/e5932fde-fe05-4612-b29d-333f48b03338/volumes/kubernetes.io~nfs/nfs Output: mount.nfs: Protocol not supported [root@node131 nfs]# https://stackoverflow.com/questions/35650935/output-mount-nfs-requested-nfs-version-or-transport-protocol-is-not-supported ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:6:1","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"访问挂载路径，服务端access denied Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Scheduled 33s default-scheduler Successfully assigned default/nfs-busybox-4ht5m to node131 Warning FailedMount 1s (x7 over 34s) kubelet MountVolume.SetUp failed for volume \"nfs\" : mount failed: exit status 32 Mounting command: mount Mounting arguments: -t nfs 10.233.124.49:/ /var/lib/kubelet/pods/bd34361c-4883-47a2-9e70-08772437e341/volumes/kubernetes.io~nfs/nfs Output: mount.nfs: access denied by server while mounting 10.233.124.49:/ [root@node131 nfs]# 原因挂载路径错误 pv配置的挂载路径path需跟nfs服务定义的路径一致。 nfs:#server: nfs-server.default.svc.cluster.localserver:10.233.124.49path:\"/exports\" ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:6:2","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"附录 按服务和资源配置顺序，依次如下 ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:7:0","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"custom-nfs-server-rc.yaml apiVersion:v1kind:ReplicationControllermetadata:name:nfs-serverspec:replicas:1selector:role:nfs-servertemplate:metadata:labels:role:nfs-serverspec:containers:- name:nfs-serverimage:k8s.gcr.io/volume-nfs:0.8ports:- name:nfscontainerPort:2049- name:mountdcontainerPort:20048- name:rpcbindcontainerPort:111securityContext:privileged:truevolumeMounts:- mountPath:/exports# name: mypvcname:data-volumevolumes:# - name: mypvc# persistentVolumeClaim:# claimName: nfs-pv-provisioning-demo- name:data-volume #卷名hostPath:path:/tmp/data ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:7:1","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"custom-nfs-pv.yaml apiVersion:v1kind:PersistentVolumemetadata:name:nfsspec:capacity:storage:1MiaccessModes:- ReadWriteMany#- ReadWriteOncenfs:# faild: nfs-server svc name#server: nfs-server.default.svc.cluster.local# success: nfs-server svc ipserver:10.233.16.102path:\"/exports\" ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:7:2","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"custom-nfs-pvc.yaml apiVersion:v1kind:PersistentVolumeClaimmetadata:name:nfsspec:accessModes:- ReadWriteMany#- ReadWriteOncestorageClassName:\"\"resources:requests:storage:1Mi ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:7:3","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"custom-nfs-busybox-rc.yaml 使用pvc进行nfs存储写操作 # This mounts the nfs volume claim into /mnt and continuously# overwrites /mnt/index.html with the time and hostname of the pod.apiVersion:v1kind:ReplicationControllermetadata:name:nfs-busyboxspec:replicas:2selector:name:nfs-busyboxtemplate:metadata:labels:name:nfs-busyboxspec:containers:- image:busyboxcommand:- sh- -c- 'while true; do date \u003e /mnt/index.html; hostname \u003e\u003e /mnt/index.html; sleep $(($RANDOM % 5 + 5)); done'imagePullPolicy:IfNotPresentname:busyboxvolumeMounts:# name must match the volume name below- name:nfsmountPath:\"/mnt\"volumes:- name:nfspersistentVolumeClaim:claimName:nfs ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:7:4","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"nfs-web-rc.yaml 使用pvc进行nfs存储读操作 # This pod mounts the nfs volume claim into /usr/share/nginx/html and# serves a simple web page.apiVersion:v1kind:ReplicationControllermetadata:name:nfs-webspec:replicas:2selector:role:web-frontendtemplate:metadata:labels:role:web-frontendspec:containers:- name:webimage:nginx:1.19ports:- name:webcontainerPort:80volumeMounts:# name must match the volume name below- name:nfsmountPath:\"/usr/share/nginx/html\"volumes:- name:nfspersistentVolumeClaim:claimName:nfs pv和pvc结构体 // Volume represents a named volume in a pod that may be accessed by any container in the pod. type Volume struct { // Volume's name. // Must be a DNS_LABEL and unique within the pod. // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names Name string `json:\"name\" protobuf:\"bytes,1,opt,name=name\"` // VolumeSource represents the location and type of the mounted volume. // If not specified, the Volume is implied to be an EmptyDir. // This implied behavior is deprecated and will be removed in a future version. VolumeSource `json:\",inline\" protobuf:\"bytes,2,opt,name=volumeSource\"` } // Represents the source of a volume to mount. // Only one of its members may be specified. type VolumeSource struct { // HostPath represents a pre-existing file or directory on the host // machine that is directly exposed to the container. This is generally // used for system agents or other privileged things that are allowed // to see the host machine. Most containers will NOT need this. // More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath // --- // TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not // mount host directories as read/write. // +optional HostPath *HostPathVolumeSource `json:\"hostPath,omitempty\" protobuf:\"bytes,1,opt,name=hostPath\"` // EmptyDir represents a temporary directory that shares a pod's lifetime. // More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir // +optional EmptyDir *EmptyDirVolumeSource `json:\"emptyDir,omitempty\" protobuf:\"bytes,2,opt,name=emptyDir\"` // GCEPersistentDisk represents a GCE Disk resource that is attached to a // kubelet's host machine and then exposed to the pod. // More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk // +optional GCEPersistentDisk *GCEPersistentDiskVolumeSource `json:\"gcePersistentDisk,omitempty\" protobuf:\"bytes,3,opt,name=gcePersistentDisk\"` // AWSElasticBlockStore represents an AWS Disk resource that is attached to a // kubelet's host machine and then exposed to the pod. // More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore // +optional AWSElasticBlockStore *AWSElasticBlockStoreVolumeSource `json:\"awsElasticBlockStore,omitempty\" protobuf:\"bytes,4,opt,name=awsElasticBlockStore\"` // GitRepo represents a git repository at a particular revision. // DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an // EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir // into the Pod's container. // +optional GitRepo *GitRepoVolumeSource `json:\"gitRepo,omitempty\" protobuf:\"bytes,5,opt,name=gitRepo\"` // Secret represents a secret that should populate this volume. // More info: https://kubernetes.io/docs/concepts/storage/volumes#secret // +optional Secret *SecretVolumeSource `json:\"secret,omitempty\" protobuf:\"bytes,6,opt,name=secret\"` // NFS represents an NFS mount on the host that shares a pod's lifetime // More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs // +optional NFS *NFSVolumeSource `json:\"nfs,omitempty\" protobuf:\"bytes,7,opt,name=nfs\"` // ISCSI represents an ISCSI Disk resource that is attached to a // kubelet's host machine and then exposed to the pod. // More info: https://examples.k8s.io/volumes/iscsi/README.md // +optional ISCSI *ISCSIVolumeSource `json:\"iscsi,omitempty\" protobuf:\"bytes,8,opt,name=iscsi\"` // Glusterfs represents a Glusterfs m","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:7:5","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"参考资料 volume概念 persistent-volumes概念 持久存储设计文档 存储类StorageClass 基于运行示例的详细演练 存储卷和数据持久化(Volumes and Persistent Storage) ","date":"2021-02-03","objectID":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/:8:0","tags":["K8S"],"title":"K8S的PV和PVC介绍","uri":"/posts/2021/02/k8s%E7%9A%84pv%E5%92%8Cpvc%E4%BB%8B%E7%BB%8D/"},{"categories":["K8S"],"content":"记录hugepage配置导致k8s的kubelet重启失败问题的排查过程","date":"2021-01-29","objectID":"/posts/2021/01/hugepage%E9%85%8D%E7%BD%AE%E5%AF%BC%E8%87%B4k8s%E7%9A%84kubelet%E9%87%8D%E5%90%AF%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/","tags":["K8S"],"title":"hugepage配置导致k8s的kubelet重启失败问题","uri":"/posts/2021/01/hugepage%E9%85%8D%E7%BD%AE%E5%AF%BC%E8%87%B4k8s%E7%9A%84kubelet%E9%87%8D%E5%90%AF%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"},{"categories":["K8S"],"content":"记录hugepage配置导致k8s的kubelet重启失败问题的排查过程 ","date":"2021-01-29","objectID":"/posts/2021/01/hugepage%E9%85%8D%E7%BD%AE%E5%AF%BC%E8%87%B4k8s%E7%9A%84kubelet%E9%87%8D%E5%90%AF%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/:0:0","tags":["K8S"],"title":"hugepage配置导致k8s的kubelet重启失败问题","uri":"/posts/2021/01/hugepage%E9%85%8D%E7%BD%AE%E5%AF%BC%E8%87%B4k8s%E7%9A%84kubelet%E9%87%8D%E5%90%AF%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"},{"categories":["K8S"],"content":"问题 kubelet 重启时，发现节点无法注册，错误信息如下： may not have pre-allocated hugepages for multiple page sizes 不支持预分配多种类型的大页。 ","date":"2021-01-29","objectID":"/posts/2021/01/hugepage%E9%85%8D%E7%BD%AE%E5%AF%BC%E8%87%B4k8s%E7%9A%84kubelet%E9%87%8D%E5%90%AF%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/:1:0","tags":["K8S"],"title":"hugepage配置导致k8s的kubelet重启失败问题","uri":"/posts/2021/01/hugepage%E9%85%8D%E7%BD%AE%E5%AF%BC%E8%87%B4k8s%E7%9A%84kubelet%E9%87%8D%E5%90%AF%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"},{"categories":["K8S"],"content":"分析 ","date":"2021-01-29","objectID":"/posts/2021/01/hugepage%E9%85%8D%E7%BD%AE%E5%AF%BC%E8%87%B4k8s%E7%9A%84kubelet%E9%87%8D%E5%90%AF%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/:2:0","tags":["K8S"],"title":"hugepage配置导致k8s的kubelet重启失败问题","uri":"/posts/2021/01/hugepage%E9%85%8D%E7%BD%AE%E5%AF%BC%E8%87%B4k8s%E7%9A%84kubelet%E9%87%8D%E5%90%AF%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"},{"categories":["K8S"],"content":"问题所在业务流程点 结合kubelet代码分析： kubelet启动时会进行自检，如果已使用的hugepagesize类型数 \u003e 1， 根据nr_hugepages，判断大页是否已使用，如nr_hugepages ！=1， 则无法通过 ","date":"2021-01-29","objectID":"/posts/2021/01/hugepage%E9%85%8D%E7%BD%AE%E5%AF%BC%E8%87%B4k8s%E7%9A%84kubelet%E9%87%8D%E5%90%AF%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/:2:1","tags":["K8S"],"title":"hugepage配置导致k8s的kubelet重启失败问题","uri":"/posts/2021/01/hugepage%E9%85%8D%E7%BD%AE%E5%AF%BC%E8%87%B4k8s%E7%9A%84kubelet%E9%87%8D%E5%90%AF%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"},{"categories":["K8S"],"content":"查看系统meminfo cat /proc/meminfo ","date":"2021-01-29","objectID":"/posts/2021/01/hugepage%E9%85%8D%E7%BD%AE%E5%AF%BC%E8%87%B4k8s%E7%9A%84kubelet%E9%87%8D%E5%90%AF%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/:2:2","tags":["K8S"],"title":"hugepage配置导致k8s的kubelet重启失败问题","uri":"/posts/2021/01/hugepage%E9%85%8D%E7%BD%AE%E5%AF%BC%E8%87%B4k8s%E7%9A%84kubelet%E9%87%8D%E5%90%AF%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"},{"categories":["K8S"],"content":"查看系统hugepage 查看大页信息，命令如下 # hugepages配置的size大小，如果有多个则会有多行输出 cat /sys/kernel/mm/hugepages/hugepages-*/nr_hugepages # 内核hugepages的配置文件 ls /sys/kernel/mm/hugepages 发现系统已使用了2种类型的大页，如下 [root@worker-01 ~]# cat /sys/kernel/mm/hugepages/hugepages-*/nr_hugepages 2 2560 [root@worker-01 ~]# ls /sys/kernel/mm/hugepages hugepages-1048576kB hugepages-2048kB ","date":"2021-01-29","objectID":"/posts/2021/01/hugepage%E9%85%8D%E7%BD%AE%E5%AF%BC%E8%87%B4k8s%E7%9A%84kubelet%E9%87%8D%E5%90%AF%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/:3:0","tags":["K8S"],"title":"hugepage配置导致k8s的kubelet重启失败问题","uri":"/posts/2021/01/hugepage%E9%85%8D%E7%BD%AE%E5%AF%BC%E8%87%B4k8s%E7%9A%84kubelet%E9%87%8D%E5%90%AF%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"},{"categories":["K8S"],"content":"解决方式 需要对一种类型大页，清0处理，比如对1G类型大页处理，该类型的hugepage未使用 echo 0 \u003e /sys/kernel/mm/hugepages/hugepages-1048576kB/nr_hugepages 重启kubelet systemctl restart kubelet ","date":"2021-01-29","objectID":"/posts/2021/01/hugepage%E9%85%8D%E7%BD%AE%E5%AF%BC%E8%87%B4k8s%E7%9A%84kubelet%E9%87%8D%E5%90%AF%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/:4:0","tags":["K8S"],"title":"hugepage配置导致k8s的kubelet重启失败问题","uri":"/posts/2021/01/hugepage%E9%85%8D%E7%BD%AE%E5%AF%BC%E8%87%B4k8s%E7%9A%84kubelet%E9%87%8D%E5%90%AF%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"Etcd参数调优配置和对比测试","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"针对etcd的性能指标：延迟(latency)和吞吐量(throughput)，进行Etcd参数调优和对比测试 ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:0:0","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"说明 etcd 提供稳定的，持续的高性能。两个定义性能的因素：延迟(latency)和吞吐量(throughput)。延迟是完成操作的时间。吞吐量是在某个时间期间之内完成操作的总数量。当 etcd 接收并发客户端请求时，通常平均延迟随着总体吞吐量增加而增加。在通常的云环境，比如 Google Compute Engine (GCE) 标准的 n-4 或者 AWS 上相当的机器类型，一个三成员 etcd 集群在轻负载下可以在低于1毫秒内完成一个请求，并在重负载下可以每秒完成超过 30000 个请求。 etcd 使用 Raft 一致性算法来在成员之间复制请求并达成一致。一致性性能，特别是提交延迟，受限于两个物理约束：网络IO延迟和磁盘IO延迟。完成一个etcd请求的最小时间是成员之间的网络往返时延(Round Trip Time / RTT)，加需要提交数据到持久化存储的 fdatasync 时间。在一个数据中心内的 RTT 可能有数百毫秒。在美国典型的 RTT 是大概 50ms, 而在大陆之间可以慢到400ms. 旋转硬盘(注：指传统机械硬盘)的典型 fdatasync 延迟是大概 10ms。对于 SSD 硬盘, 延迟通常低于 1ms. 为了提高吞吐量, etcd 将多个请求打包在一起并提交给 Raft。这个批量策略让 etcd 在重负载时获得高吞吐量. 有其他子系统影响到 etcd 的整体性能。每个序列化的 etcd 请求必须通过 etcd 的 boltdb支持的(boltdb-backed) MVCC 存储引擎,它通常需要10微秒来完成。etcd 定期递增快照它最近实施的请求，将他们和之前在磁盘上的快照合并。这个过程可能导致延迟尖峰(latency spike)。虽然在SSD上这通常不是问题，在HDD上它可能加倍可观察到的延迟。而且，进行中的压缩可以影响 etcd 的性能。幸运的是，压缩通常无足轻重，因为压缩是错开的，因此它不和常规请求竞争资源。RPC 系统，gRPC，为 etcd 提供定义良好，可扩展的 API，但是它也引入了额外的延迟，尤其是本地读取。 ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:1:0","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"etcd 安装 ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:2:0","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"二进制方式安装 参考版本地址 这里选择ETCD_VER=v3.4.13版本 ETCD_VER=v3.4.13 # choose either URL GOOGLE_URL=https://storage.googleapis.com/etcd GITHUB_URL=https://github.com/etcd-io/etcd/releases/download # choose GITHUB_URL DOWNLOAD_URL=${GITHUB_URL} rm -f /tmp/etcd-${ETCD_VER}-linux-amd64.tar.gz rm -rf /tmp/etcd-download-test \u0026\u0026 mkdir -p /tmp/etcd-download-test curl -L ${DOWNLOAD_URL}/${ETCD_VER}/etcd-${ETCD_VER}-linux-amd64.tar.gz -o /tmp/etcd-${ETCD_VER}-linux-amd64.tar.gz tar xzvf /tmp/etcd-${ETCD_VER}-linux-amd64.tar.gz -C /tmp/etcd-download-test --strip-components=1 rm -f /tmp/etcd-${ETCD_VER}-linux-amd64.tar.gz /tmp/etcd-download-test/etcd --version /tmp/etcd-download-test/etcdctl version ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:2:1","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"etcd 启动 # start a local etcd server /tmp/etcd-download-test/etcd ## 指定etcd name /tmp/etcd-download-test/etcd --name=etcdtest ## 指定data-dir /tmp/etcd-download-test/etcd --name=etcdtest --data-dir=/var/lib/etcd ## 指定 params /tmp/etcd-download-test/etcd --name=etcdtest --heartbeat-interval=200 --election-timeout=2000 --snapshot-count=5000 --auto-compaction-retention=1 ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:2:2","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"etcd 键值测试 # write,read to etcd /tmp/etcd-download-test/etcdctl --endpoints=localhost:2379 put foo bar /tmp/etcd-download-test/etcdctl --endpoints=localhost:2379 get foo ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:2:3","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"etcd 参数优化 ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:3:0","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"快照 etcd_snapshot_count 5000 数据快照触发数量，etcd处理指定的次数的事务提交后，生产数据快照 ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:3:1","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"历史数据压缩频率 etcd_compaction_retention 1 由于ETCD数据存储多版本数据，随着写入的主键增加历史版本需要定时清理，　默认的历史数据是不会清理的，数据达到2G就不能写入，必须要清理压缩历史数据才能继续写入； 所以根据业务需求，在上生产环境之前就提前确定，历史数据多长时间压缩一次；　我们的生产环境现在升级后是默认一小时压缩一次数据。这样可以极大的保证集群稳定，减少内存和磁盘占用 ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:3:2","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"时间参数 etcd_heartbeat_interval 200 etcd_election_timeout 2000 客户端连接后的心跳间隔（毫秒） 集群选举的超时时间（毫秒） ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:3:3","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"磁盘IO优先级，在全部etcd节点执行 ionice -c2 -n0 -p pgrep etcd ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:3:4","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"etcd配置，环境变量方式 vi /etc/etcd.env vi /etc/etcd.env ETCD_SNAPSHOT_COUNT=5000 ETCD_HEARTBEAT_INTERVAL=200 ETCD_ELECTION_TIMEOUT=2000 ETCD_AUTO_COMPACTION_RETENTION=1 ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:4:0","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"etcd配置， 命令行参数方式 etcd --heartbeat-interval=200 --election-timeout=2000 --snapshot-count=5000 --auto-compaction-retention=1 ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:5:0","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"benchmark安装 etcd/tools/benchmark 是etcd官方benchmark测试工具 安装命令如下， ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:6:0","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"get方式 # set myproject go env export GOPATH=/home/wangb/go_projects go get go.etcd.io/etcd/tools/benchmark ls $GOPATH/bin 示例： $ go get go.etcd.io/etcd/tools/benchmark # GOPATH should be set $ ls $GOPATH/bin benchmark ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:6:1","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"编译方式 如果上面get方式不能成功，则下载etcd源码，进行编译 # 使用go mod # 进入项目根目录，如go_projects/src/etcd-3.4.13 export GO111MODULE=on # export GO111MODULE=off # go env -w GOPROXY=https://goproxy.cn,direct #进入项目目录 #go mod init godev # 下载依赖 go mod tidy # 生成项目vendor go mod vendor # etcd-3.4.13/tools/benchmark cd tools/benchmark go build -o benchmark 示例： (base) [root@yuyuan211 /home/wangb/go_projects/src/etcd-3.4.13/tools/benchmark]# go build -o benchmark (base) [root@yuyuan211 /home/wangb/go_projects/src/etcd-3.4.13/tools/benchmark]# ll total 19080 -rwxr-xr-x. 1 root root 19525385 Jan 18 11:09 benchmark drwxr-xr-x. 2 root root 278 Aug 25 03:11 cmd -rw-r--r--. 1 root root 675 Aug 25 03:11 doc.go -rw-r--r--. 1 root root 784 Aug 25 03:11 main.go -rw-r--r--. 1 root root 284 Aug 25 03:11 README.md ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:6:2","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"benchmark指标 性能指标说明： 延时 吞吐量 title description Performance Understanding performance: latency \u0026 throughput ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:7:0","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"benchmark测试 ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:8:0","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"启动etcd /tmp/etcd-download-test/etcd --name=etcdtest --heartbeat-interval=200 --election-timeout=2000 --snapshot-count=5000 --auto-compaction-retention=1 启动打印 (base) [root@yuyuan211 /home/wangb/etcd-test]# /tmp/etcd-download-test/etcd --name=etcdtest --heartbeat-interval=200 --election-timeout=2000 --snapshot-count=5000 --auto-compaction-retention=1 [WARNING] Deprecated '--logger=capnslog' flag is set; use '--logger=zap' flag instead 2021-01-19 14:34:35.907827 I | etcdmain: etcd Version: 3.4.13 2021-01-19 14:34:35.908025 I | etcdmain: Git SHA: ae9734ed2 2021-01-19 14:34:35.908089 I | etcdmain: Go Version: go1.12.17 2021-01-19 14:34:35.908116 I | etcdmain: Go OS/Arch: linux/amd64 2021-01-19 14:34:35.908144 I | etcdmain: setting maximum number of CPUs to 32, total number of available CPUs is 32 2021-01-19 14:34:35.908186 W | etcdmain: no data-dir provided, using default data-dir ./etcdtest.etcd [WARNING] Deprecated '--logger=capnslog' flag is set; use '--logger=zap' flag instead 2021-01-19 14:34:35.912732 I | embed: name = etcdtest 2021-01-19 14:34:35.912790 I | embed: data dir = etcdtest.etcd 2021-01-19 14:34:35.912833 I | embed: member dir = etcdtest.etcd/member 2021-01-19 14:34:35.912854 I | embed: heartbeat = 200ms 2021-01-19 14:34:35.912873 I | embed: election = 2000ms 2021-01-19 14:34:35.912891 I | embed: snapshot count = 5000 2021-01-19 14:34:35.912944 I | embed: advertise client URLs = http://localhost:2379 2021-01-19 14:34:35.925333 I | etcdserver: starting member 8e9e05c52164694d in cluster cdf818194e3a8c32 raft2021/01/19 14:34:35 INFO: 8e9e05c52164694d switched to configuration voters=() raft2021/01/19 14:34:35 INFO: 8e9e05c52164694d became follower at term 0 raft2021/01/19 14:34:35 INFO: newRaft 8e9e05c52164694d [peers: [], term: 0, commit: 0, applied: 0, lastindex: 0, lastterm: 0] raft2021/01/19 14:34:35 INFO: 8e9e05c52164694d became follower at term 1 raft2021/01/19 14:34:35 INFO: 8e9e05c52164694d switched to configuration voters=(10276657743932975437) 2021-01-19 14:34:35.928869 W | auth: simple token is not cryptographically signed 2021-01-19 14:34:35.933119 I | etcdserver: starting server... [version: 3.4.13, cluster version: to_be_decided] 2021-01-19 14:34:35.933413 I | etcdserver: 8e9e05c52164694d as single-node; fast-forwarding 9 ticks (election ticks 10) raft2021/01/19 14:34:35 INFO: 8e9e05c52164694d switched to configuration voters=(10276657743932975437) 2021-01-19 14:34:35.935531 I | etcdserver/membership: added member 8e9e05c52164694d [http://localhost:2380] to cluster cdf818194e3a8c32 2021-01-19 14:34:35.939938 I | embed: listening for peers on 127.0.0.1:2380 raft2021/01/19 14:34:37 INFO: 8e9e05c52164694d is starting a new election at term 1 raft2021/01/19 14:34:37 INFO: 8e9e05c52164694d became candidate at term 2 raft2021/01/19 14:34:37 INFO: 8e9e05c52164694d received MsgVoteResp from 8e9e05c52164694d at term 2 raft2021/01/19 14:34:37 INFO: 8e9e05c52164694d became leader at term 2 raft2021/01/19 14:34:37 INFO: raft.node: 8e9e05c52164694d elected leader 8e9e05c52164694d at term 2 2021-01-19 14:34:37.328580 I | etcdserver: setting up the initial cluster version to 3.4 2021-01-19 14:34:37.330234 N | etcdserver/membership: set the initial cluster version to 3.4 2021-01-19 14:34:37.330360 I | embed: ready to serve client requests 2021-01-19 14:34:37.330537 I | etcdserver: published {Name:etcdtest ClientURLs:[http://localhost:2379]} to cluster cdf818194e3a8c32 2021-01-19 14:34:37.330575 I | etcdserver/api: enabled capabilities for version 3.4 2021-01-19 14:34:37.332810 N | embed: serving insecure client requests on 127.0.0.1:2379, this is strongly discouraged! 2021-01-19 14:36:58.994204 I | etcdserver: start to snapshot (applied: 5001, lastsnap: 0) 2021-01-19 14:36:58.999539 I | etcdserver: saved snapshot at index 5001 2021-01-19 14:36:59.000747 I | etcdserver: compacted raft log at 1 2021-01-19 14:37:02.580676 I | etcdserver: start to snapshot (applied: 10002, lastsnap: 5001) 2021-01-19 14:37:02.585886 I | etc","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:8:1","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"参数说明 clients：Number of clients： 客户端数量 conns：Number of connections，http连接数量，多个客户端可复用1个连接 total ：Total number of put requests，requests请求数量，即所有客户端的请求总数量，默认值10000 ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:8:2","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"write测试 With this configuration, etcd can approximately write: Number of keys Key size in bytes Value size in bytes Number of connections Number of clients Target etcd server Average write QPS Average latency per request Average server RSS 10,000 8 256 1 1 leader only 1359 0.7ms 24 MB 100,000 8 256 100 1000 leader only 27507 36ms 75MB 100,000 8 256 100 1000 all members 27206 36.3ms 89MB 说明：这里只有一个etcd节点，所以表格第3行的集群raft测试结果参考意义不大。 Sample commands are: HOST_1=http://127.0.0.1:2379 HOST_2=http://127.0.0.1:2379 HOST_3=http://127.0.0.1:2379 # include benchmark bin path current=`pwd` export PATH=$PATH:$current # write to leader benchmark --endpoints=${HOST_1} --target-leader --conns=1 --clients=1 \\ put --key-size=8 --sequential-keys --total=10000 --val-size=256 benchmark --endpoints=${HOST_1} --target-leader --conns=100 --clients=1000 \\ put --key-size=8 --sequential-keys --total=100000 --val-size=256 # write to all members benchmark --endpoints=${HOST_1},${HOST_2},${HOST_3} --conns=100 --clients=1000 \\ put --key-size=8 --sequential-keys --total=100000 --val-size=256 ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:8:3","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"read测试 Linearizable read requests go through a quorum of cluster members for consensus to fetch the most recent data. Serializable read requests are cheaper than linearizable reads since they are served by any single etcd member, instead of a quorum of members, in exchange for possibly serving stale data. etcd can read: Number of requests Key size in bytes Value size in bytes Number of connections Number of clients Consistency Average read QPS Average latency per request 10,000 8 256 1 1 Linearizable 1110 0.9ms 10,000 8 256 1 1 Serializable 1251 0.8ms 100,000 8 256 100 1000 Linearizable 9532 0.1044s 100,000 8 256 100 1000 Serializable 11354 0.0875s 说明 由于测试etcd为单节点，所以Linearizable和Serializable特性测试结果差别不大，参考意义不大。 Sample commands are: HOST_1=http://127.0.0.1:2379 HOST_2=http://127.0.0.1:2379 HOST_3=http://127.0.0.1:2379 current=`pwd` export PATH=$PATH:$current read前，先write一个测试key YOUR_KEY=foo /tmp/etcd-download-test/etcdctl --endpoints=localhost:2379 put $YOUR_KEY bar /tmp/etcd-download-test/etcdctl --endpoints=localhost:2379 get $YOUR_KEY 测试命令 # Single connection read requests benchmark --endpoints=${HOST_1},${HOST_2},${HOST_3} --conns=1 --clients=1 \\ range $YOUR_KEY --consistency=l --total=10000 benchmark --endpoints=${HOST_1},${HOST_2},${HOST_3} --conns=1 --clients=1 \\ range $YOUR_KEY --consistency=s --total=10000 # Many concurrent read requests benchmark --endpoints=${HOST_1},${HOST_2},${HOST_3} --conns=100 --clients=1000 \\ range $YOUR_KEY --consistency=l --total=100000 benchmark --endpoints=${HOST_1},${HOST_2},${HOST_3} --conns=100 --clients=1000 \\ range $YOUR_KEY --consistency=s --total=100000 ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:8:4","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"read-only 时间参数设置优化 read测试时的etcd打印信息 2021-01-18 14:54:58.315985 W | etcdserver: read-only range request \"key:\\\"foo\\\" serializable:true \" with result \"range_response_count:1 size:30\" took too long (128.237385ms) to execute 2021-01-18 14:54:58.316748 W | etcdserver: read-only range request \"key:\\\"foo\\\" serializable:true \" with result \"range_response_count:1 size:30\" took too long (136.434995ms) to execute 2021-01-18 14:54:58.317021 W | etcdserver: read-only range request \"key:\\\"foo\\\" serializable:true \" with result \"range_response_count:1 size:30\" took too long (125.138823ms) to execute 2021-01-18 14:54:58.327063 W | etcdserver: read-only range request \"key:\\\"foo\\\" serializable:true \" with result \"range_response_count:1 size:30\" took too long (113.659252ms) to execute 2021-01-18 14:54:58.327171 W | etcdserver: read-only range request \"key:\\\"foo\\\" serializable:true \" with result \"range_response_count:1 size:30\" took too long (140.480071ms) to execute 2021-01-18 14:54:58.328320 W | etcdserver: read-only range request \"key:\\\"foo\\\" serializable:true \" with result \"range_response_count:1 size:30\" took too long (138.142424ms) to execute 2021-01-18 14:54:58.329457 W | etcdserver: read-only range request \"key:\\\"foo\\\" serializable:true \" with result \"range_response_count:1 size:30\" took too long (136.980041ms) to execute 2021-01-18 14:54:58.330026 W | etcdserver: read-only range request \"key:\\\"foo\\\" serializable:true \" with result \"range_response_count:1 size:30\" took too long (139.674614ms) to execute 2021-01-18 14:54:58.330674 W | etcdserver: read-only range request \"key:\\\"foo\\\" serializable:true \" with result \"range_response_count:1 size:30\" took too long (137.950461ms) to execute 2021-01-18 14:54:58.330710 W | etcdserver: read-only range request \"key:\\\"foo\\\" serializable:true \" with result \"range_response_count:1 size:30\" took too long (151.589201ms) to execute 2021-01-18 14:54:58.338877 W | etcdserver: read-only range request \"key:\\\"foo\\\" serializable:true \" with result \"range_response_count:1 size:30\" took too long (149.623303ms) to execute 2021-01-18 14:54:58.339042 W | etcdserver: read-only range request \"key:\\\"foo\\\" serializable:true \" with result \"range_response_count:1 size:30\" took too long (148.882374ms) to execute 上面的read测试时的etcd打印信息， 会一直输出告警打印信息（包括输出到系统日志中），因为read-only range request \u003e 100ms，导致性能降低 代码中默认值设置为 100ms // v3.3 -\u003e v3.4.14 const ( warnApplyDuration = 100 * time.Millisecond ) // v3.4-master const ( DefaultWarningApplyDuration = 100 * time.Millisecond ) 在etcd-v3.4最新版本(master)添加了参数优化设置，而v3.4.14以前，包括v3.4.14和etcd-v3.3没有办法消除该告警信息打印 同时etcd-3.4版本的模块目录有所调整，所以需要跟踪etcd版本 跟踪etcd版本，是否新增了配置变量ExperimentalWarningApplyDuration，而最新版本不再使用变量WarnApplyDuration，改为WarningApplyDuration WarningApplyDuration 修改参考 srvcfg := etcdserver.ServerConfig{ WarningApplyDuration: cfg.ExperimentalWarningApplyDuration, } ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:8:5","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"benchmark测试条件 We encourage running the benchmark test when setting up an etcd cluster for the first time in a new environment to ensure the cluster achieves adequate performance; cluster latency and throughput can be sensitive to minor environment differences. ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:8:6","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"磁盘IO 参数调优 Linux 中 etcd 的磁盘优先级可以使用 ionice 配置： -c class 指定调度类型，0代表none，1代表real time,2代表best effort, 3代表idle-nclassdata 指定优先级 real time和best effor可以使用0-7-p pid 查看或改变已经运行的进程的调度类型和优先级。-t 忽略设置指定优先级的错误信息 ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:9:0","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"查询命令 ionice -p `pgrep etcd` 原有配置 (base) [root@yuyuan211 ~]# ionice -p `pgrep etcd` unknown: prio 4 ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:9:1","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"设置命令 Best Effort策略，优先级为0（优先级最高） # best effort, highest priority ionice -c2 -n0 -p `pgrep etcd` ionice -p `pgrep etcd` 优化配置 (base) [root@yuyuan211 ~]# ionice -c2 -n0 -p `pgrep etcd` (base) [root@yuyuan211 ~]# (base) [root@yuyuan211 ~]# ionice -p `pgrep etcd` best-effort: prio 0 (base) [root@yuyuan211 ~]# ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:9:2","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"优化后测试 说明 为了在相同环境下对比测试，把之前测试数据文件etcdtest.etcd全部删除 read测试时，测试键值key，可以不预置，这样read测试为极限值 (base) [root@yuyuan211 /home/wangb/etcd-test]# ll total 19068 -rwxr-xr-x. 1 root root 19525385 Jan 18 11:36 benchmark drwxr-xr-x. 3 root root 151 Jan 18 11:37 etcd-download-test drwx------. 3 root root 28 Jan 18 13:46 etcdtest.etcd (base) [root@yuyuan211 /home/wangb/etcd-test]# (base) [root@yuyuan211 /home/wangb/etcd-test]# (base) [root@yuyuan211 /home/wangb/etcd-test]# (base) [root@yuyuan211 /home/wangb/etcd-test]# rm -rf etcdtest.etcd (base) [root@yuyuan211 /home/wangb/etcd-test]# write测试 Sample commands are: HOST_1=http://127.0.0.1:2379 HOST_2=http://127.0.0.1:2379 HOST_3=http://127.0.0.1:2379 # include benchmark bin path current=`pwd` export PATH=$PATH:$current # write to leader benchmark --endpoints=${HOST_1} --target-leader --conns=1 --clients=1 \\ put --key-size=8 --sequential-keys --total=10000 --val-size=256 benchmark --endpoints=${HOST_1} --target-leader --conns=100 --clients=1000 \\ put --key-size=8 --sequential-keys --total=100000 --val-size=256 # write to all members benchmark --endpoints=${HOST_1},${HOST_2},${HOST_3} --conns=100 --clients=1000 \\ put --key-size=8 --sequential-keys --total=100000 --val-size=256 With this configuration, etcd can approximately write: Number of keys Key size in bytes Value size in bytes Number of connections Number of clients Target etcd server Average write QPS Average latency per request 10,000 8 256 1 1 leader only 1357 0.7ms 100,000 8 256 100 1000 leader only 28232 35.1ms 100,000 8 256 100 1000 all members 27620 35.9ms read测试 测试命令 HOST_1=http://127.0.0.1:2379 HOST_2=http://127.0.0.1:2379 HOST_3=http://127.0.0.1:2379 # include benchmark bin path current=`pwd` export PATH=$PATH:$current # Single connection read requests benchmark --endpoints=${HOST_1},${HOST_2},${HOST_3} --conns=1 --clients=1 \\ range $YOUR_KEY --consistency=l --total=10000 benchmark --endpoints=${HOST_1},${HOST_2},${HOST_3} --conns=1 --clients=1 \\ range $YOUR_KEY --consistency=s --total=10000 # Many concurrent read requests benchmark --endpoints=${HOST_1},${HOST_2},${HOST_3} --conns=100 --clients=1000 \\ range $YOUR_KEY --consistency=l --total=100000 benchmark --endpoints=${HOST_1},${HOST_2},${HOST_3} --conns=100 --clients=1000 \\ range $YOUR_KEY --consistency=s --total=100000 Number of requests Key size in bytes Value size in bytes Number of connections Number of clients Consistency Average read QPS Average latency per request 10,000 8 256 1 1 Linearizable 1272 0.8ms 10,000 8 256 1 1 Serializable 1432 0.7ms 100,000 8 256 100 1000 Linearizable 13108 0.0758s 100,000 8 256 100 1000 Serializable 16088 0.0617s 对比结果 write对比 Number of keys Key size in bytes Value size in bytes Number of connections Number of clients Target etcd server Average write QPS Average latency per request Tunning 10,000 8 256 1 1 leader only 1359 0.7ms false 10,000 8 256 1 1 leader only 1382 0.7ms true 100,000 8 256 100 1000 leader only 27507 36ms false 100,000 8 256 100 1000 leader only 28381 34.8ms true 100,000 8 256 100 1000 all members 27206 36.3ms false 100,000 8 256 100 1000 all members 27855 35.6ms true read对比 Number of requests Key size in bytes Value size in bytes Number of connections Number of clients Consistency Average read QPS Average latency per request Tunning 10,000 8 256 1 1 Linearizable 1110 0.9ms false 10,000 8 256 1 1 Linearizable 1272 0.8ms true 10,000 8 256 1 1 Serializable 1251 0.8ms false 10,000 8 256 1 1 Serializable 1432 0.7ms true 100,000 8 256 100 1000 Linearizable 9532 0.1044s false 100,000 8 256 100 1000 Linearizable 13108 0.0758s true 100,000 8 256 100 1000 Serializable 11354 0.0875s false 100,000 8 256 100 1000 Serializable 16088 0.0617s true ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:9:3","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"结论 磁盘IO参数可以优化etcd性能，write和read接口指标改善 快照和数据压缩参数，可以减少etcd的内存和磁盘占用量 ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:10:0","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"附录 etcd benchmarks etcd-3-demo-benchmarks ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:11:0","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"Linearizability Linearizability (also known as Atomic Consistency or External Consistency) is a consistency level between strict consistency and sequential consistency. For linearizability, suppose each operation receives a timestamp from a loosely synchronized global clock. Operations are linearized if and only if they always complete as though they were executed in a sequential order and each operation appears to complete in the order specified by the program. Likewise, if an operation’s timestamp precedes another, that operation must also precede the other operation in the sequence. For example, consider a client completing a write at time point 1 (t1). A client issuing a read at t2 (for t2 \u003e t1) should receive a value at least as recent as the previous write, completed at t1. However, the read might actually complete only by t3. Linearizability guarantees the read returns the most current value. Without linearizability guarantee, the returned value, current at t2 when the read began, might be “stale” by t3 because a concurrent write might happen between t2 and t3. etcd does not ensure linearizability for watch operations. Users are expected to verify the revision of watch responses to ensure correct ordering. etcd ensures linearizability for all other operations by default. Linearizability comes with a cost, however, because linearized requests must go through the Raft consensus process. To obtain lower latencies and higher throughput for read requests, clients can configure a request’s consistency mode to serializable, which may access stale data with respect to quorum, but removes the performance penalty of linearized accesses' reliance on live consensus. 线性化（也称为原子一致性或外部一致性）是严格一致性和顺序一致性之间的一致性级别。 对于线性化，假设每个操作从松散同步的全局时钟接收一个时间戳。当且仅当操作总是像按顺序执行一样完成，并且每个操作似乎按程序指定的顺序完成时，才线性化操作。同样，如果一个操作的时间戳先于另一个操作，那么该操作也必须先于序列中的另一个操作。 例如，假设客户机在时间点1（t1）完成写入。在t2发出read（对于t2\u003et1）的客户机应至少收到与在t1完成的上一次写入相同的最新值。然而，读取实际上可能只在t3之前完成。线性化保证读取返回最新值。如果没有线性化保证，返回值（读取开始时t2处的当前值）可能会被t3“过时”，因为t2和t3之间可能发生并发写入。 etcd不能确保监视操作的线性化。用户需要验证监视响应的修订，以确保正确排序。 默认情况下，etcd可确保所有其他操作的线性化。然而，线性化是有代价的，因为线性化的请求必须经过协商一致的过程。为了获得较低的延迟和较高的读请求吞吐量，客户机可以将请求的一致性模式配置为可串行化，这可能会访问有关仲裁的过时数据，但消除了线性化访问依赖实时一致性的性能损失。 ","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:11:1","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["数据库"],"content":"测试记录 write测试 表格第1行测试数据 (base) [root@yuyuan211 /home/wangb/etcd-test]# benchmark --endpoints=${HOST_1} --target-leader --conns=1 --clients=1 \\ \u003e put --key-size=8 --sequential-keys --total=10000 --val-size=256 10000 / 10000 Booooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo! 100.00% 7s Summary: Total: 7.3535 secs. Slowest: 0.0048 secs. Fastest: 0.0003 secs. Average: 0.0007 secs. Stddev: 0.0003 secs. Requests/sec: 1359.9057 Response time histogram: 0.0003 [1] | 0.0008 [7950] |∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 0.0012 [1535] |∎∎∎∎∎∎∎ 0.0016 [240] |∎ 0.0021 [152] | 0.0025 [53] | 0.0030 [33] | 0.0034 [20] | 0.0039 [10] | 0.0043 [3] | 0.0048 [3] | Latency distribution: 10% in 0.0006 secs. 25% in 0.0006 secs. 50% in 0.0006 secs. 75% in 0.0007 secs. 90% in 0.0010 secs. 95% in 0.0012 secs. 99% in 0.0022 secs. 99.9% in 0.0037 secs. (base) [root@yuyuan211 /home/wangb/etcd-test]# (base) [root@yuyuan211 /home/wangb/etcd-test]# ps aux |grep etcd root 29017 1.9 0.0 10616300 24752 pts/10 Sl+ 13:46 0:14 /tmp/etcd-download-test/etcd --name=etcdtest --heartbeat-interval=200 --election-timeout=2000 --snapshot-count=5000 表格第2行测试数据 (base) [root@yuyuan211 /home/wangb/etcd-test]# benchmark --endpoints=${HOST_1} --target-leader --conns=100 --clients=1000 \\ \u003e put --key-size=8 --sequential-keys --total=100000 --val-size=256 INFO: 2021/01/18 14:00:00 parsed scheme: \"endpoint\" INFO: 2021/01/18 14:00:00 ccResolverWrapper: sending new addresses to cc: [{http://localhost:2379 \u003cnil\u003e 0 \u003cnil\u003e}] 100000 / 100000 Booooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo! 100.00% 3s Summary: Total: 3.5391 secs. Slowest: 0.0837 secs. Fastest: 0.0035 secs. Average: 0.0351 secs. Stddev: 0.0109 secs. Requests/sec: 28255.6626 Response time histogram: 0.0035 [1] | 0.0116 [1] | 0.0196 [1298] |∎ 0.0276 [25892] |∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 0.0356 [34394] |∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 0.0436 [15557] |∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 0.0517 [14631] |∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 0.0597 [5577] |∎∎∎∎∎∎ 0.0677 [1873] |∎∎ 0.0757 [428] | 0.0837 [348] | Latency distribution: 10% in 0.0235 secs. 25% in 0.0272 secs. 50% in 0.0318 secs. 75% in 0.0424 secs. 90% in 0.0504 secs. 95% in 0.0550 secs. 99% in 0.0665 secs. 99.9% in 0.0812 secs. (base) [root@yuyuan211 /home/wangb/etcd-test]# (base) [root@yuyuan211 /home/wangb/etcd-test]# ps aux |grep etcd root 29017 6.6 0.2 10687728 75552 pts/10 Sl+ 13:46 0:56 /tmp/etcd-download-test/etcd --name=etcdtest --heartbeat-interval=200 --election-timeout=2000 --snapshot-count=5000 表格第3行测试数据 (base) [root@yuyuan211 /home/wangb/etcd-test]# benchmark --endpoints=${HOST_1},${HOST_2},${HOST_3} --conns=100 --clients=1000 \\ \u003e put --key-size=8 --sequential-keys --total=100000 --val-size=256 INFO: 2021/01/18 14:11:16 ccResolverWrapper: sending new addresses to cc: [{http://127.0.0.1:2379 \u003cnil\u003e 0 \u003cnil\u003e}] 100000 / 100000 Booooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo! 100.00% 3s Summary: Total: 3.5622 secs. Slowest: 0.0836 secs. Fastest: 0.0123 secs. Average: 0.0353 secs. Stddev: 0.0109 secs. Requests/sec: 28072.8070 Response time histogram: 0.0123 [1] | 0.0194 [1105] |∎ 0.0266 [23001] |∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 0.0337 [30319] |∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 0.0408 [13738] |∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 0.0480 [17523] |∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 0.0551 [9420] |∎∎∎∎∎∎∎∎∎∎∎∎ 0.0622 [3625] |∎∎∎∎ 0.0693 [506] | 0.0765 [597] | 0.0836 [165] | Latency distribution: 10% in 0.0235 secs. 25% in 0.0268 secs. 50% in 0.0319 secs. 75% in 0.0437 secs. 90% in 0.0501 secs. 95% in 0.0548 secs. 99% in 0.0649 secs. 99.9% in 0.0791 secs. (base) [root@yuyuan211 /home/wangb/etcd-test]# ps aux |grep etcd root 29017 6.2 0.2 10687728 89612 pts/10 Sl+ 13:46 1:41 /tmp/etcd-download-test/etcd --name=etcdtest --heartbeat-interval=200 --election","date":"2021-01-19","objectID":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:11:2","tags":["Etcd"],"title":"Etcd调优和性能测试","uri":"/posts/2021/01/etcd%E8%B0%83%E4%BC%98%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["K8S"],"content":"K8S calico网络插件问题集，持续更新","date":"2021-01-13","objectID":"/posts/2021/01/k8s-calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98%E9%9B%86/","tags":["K8S"],"title":"K8S calico网络插件问题集","uri":"/posts/2021/01/k8s-calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98%E9%9B%86/"},{"categories":["K8S"],"content":"K8S calico网络插件问题集，持续更新 ","date":"2021-01-13","objectID":"/posts/2021/01/k8s-calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98%E9%9B%86/:0:0","tags":["K8S"],"title":"K8S calico网络插件问题集","uri":"/posts/2021/01/k8s-calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98%E9%9B%86/"},{"categories":["K8S"],"content":"calico node pod一直没有起来 Number of node(s) with BGP peering established = 0 网上解决方法如下： https://blog.csdn.net/qq_36783142/article/details/107912407 name: IP_AUTODETECTION_METHOD value: “interface=enp26s0f3” 但此方式不能解决自己环境所遇问题。 分析应该是网络路由问题（原来环境残留的脏路由导致），做下清理处理 执行下面命令解决 systemctl stop kubelet systemctl stop docker iptables --flush iptables -tnat --flush systemctl start docker systemctl start kubelet ","date":"2021-01-13","objectID":"/posts/2021/01/k8s-calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98%E9%9B%86/:1:0","tags":["K8S"],"title":"K8S calico网络插件问题集","uri":"/posts/2021/01/k8s-calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98%E9%9B%86/"},{"categories":["K8S"],"content":"calico node pod异常 Readiness probe failed: container is not running 现象如下 [root@node2 ~]# kubectl get po -A -owide NAMESPACE NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES kube-system calico-kube-controllers-67f55f8858-5cgpg 1/1 Running 2 14d 10.151.11.53 gpu53 \u003cnone\u003e \u003cnone\u003e kube-system calico-node-l6crs 0/1 Running 3 18d 10.151.11.61 node2 \u003cnone\u003e \u003cnone\u003e kube-system calico-node-vb7s5 0/1 Running 1 57m 10.151.11.53 gpu53 \u003cnone\u003e \u003cnone\u003e calico node 异常现象跟上面类似，但是探针检查失败 Events: Type Reason Age From Message ---- ------ ---- ---- ------- Warning Unhealthy 69m (x2936 over 12d) kubelet Readiness probe errored: rpc error: code = Unknown desc = operation timeout: context deadline exceeded Warning Unhealthy 57m (x2938 over 12d) kubelet Liveness probe errored: rpc error: code = Unknown desc = operation timeout: context deadline exceeded Warning Unhealthy 12m (x6 over 13m) kubelet Liveness probe failed: container is not running Normal SandboxChanged 11m (x2 over 13m) kubelet Pod sandbox changed, it will be killed and re-created. Normal Killing 11m (x2 over 13m) kubelet Stopping container calico-node Warning Unhealthy 8m3s (x32 over 13m) kubelet Readiness probe failed: container is not running Warning Unhealthy 4m45s (x6 over 5m35s) kubelet Liveness probe failed: container is not running Normal SandboxChanged 3m42s (x2 over 5m42s) kubelet Pod sandbox changed, it will be killed and re-created. Normal Killing 3m42s (x2 over 5m42s) kubelet Stopping container calico-node Warning Unhealthy 42s (x31 over 5m42s) kubelet Readiness probe failed: container is not running 查看异常pod日志信息，发现进程端口被占用。通过netstat命令查看端口占用进程，发现下面进程一直残留 删除calico-node组件，包括kill，上面进程仍然残留 # 删除calico-node组件 cd /etc/kubernetes/ kubectl delete -f calico-node.yml 这些进程为docker启动，但未回收，此时21881进程状态为D - 不可中断的睡眠状态。 通过重启服务器节点，解除calico服务端口占用。问题解决。 有时进程可以进行删除，如下残留进程/usr/local/bin/runsvdir -P /etc/service/enabled，状态为S，其子进程包含了calico相关服务，通过kill命令清理，然后再启动calico-node组件 [root@node2 kubernetes]# ps -ef |grep 175885 root 24910 36399 0 16:04 pts/6 00:00:00 grep --color=auto 175885 root 175885 175862 0 15:12 ? 00:00:00 /usr/local/bin/runsvdir -P /etc/service/enabled root 201783 175885 0 15:29 ? 00:00:00 runsv felix root 201784 175885 0 15:29 ? 00:00:00 runsv monitor-addresses root 201785 175885 0 15:29 ? 00:00:00 runsv allocate-tunnel-addrs root 201786 175885 0 15:29 ? 00:00:00 runsv bird root 201787 175885 0 15:29 ? 00:00:00 runsv bird6 root 201788 175885 0 15:29 ? 00:00:00 runsv confd [root@node2 kubernetes]# ps aux |grep 175885 root 25633 0.0 0.0 112712 960 pts/6 S+ 16:05 0:00 grep --color=auto 175885 root 175885 0.0 0.0 4356 372 ? Ss 15:12 0:00 /usr/local/bin/runsvdir -P /etc/service/enabled [root@node2 kubernetes]# [root@node2 kubernetes]# [root@node2 kubernetes]# kill 175885 [root@node2 kubernetes]# [root@node2 kubernetes]# [root@node2 kubernetes]# ps -ef |grep calico root 33242 36399 0 16:11 pts/6 00:00:00 grep --color=auto calico [root@node2 kubernetes]# [root@node2 kubernetes]# 所以删除calico-node组件时，需要通过ps -ef |grep calico确认节点上是否还有calico相关进程 [root@node2 net.d]# [root@node2 net.d]# ps -ef |grep calico root 57982 18990 0 10:54 pts/8 00:00:00 grep --color=auto calico root 219142 219137 0 2020 ? 00:01:11 calico-node -allocate-tunnel-addrs root 219143 219135 0 2020 ? 02:25:07 calico-node -felix root 219144 219136 0 2020 ? 00:01:51 calico-node -monitor-addresses root 219145 219140 0 2020 ? 00:01:13 calico-node -confd root 219407 219138 0 2020 ? 00:11:20 bird -R -s /var/run/calico/bird.ctl -d -c /etc/calico/confd/config/bird.cfg root 219408 219139 0 2020 ? 00:10:59 bird6 -R -s /var/run/calico/bird6.ctl -d -c /etc/calico/confd/config/bird6.cfg ","date":"2021-01-13","objectID":"/posts/2021/01/k8s-calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98%E9%9B%86/:2:0","tags":["K8S"],"title":"K8S calico网络插件问题集","uri":"/posts/2021/01/k8s-calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98%E9%9B%86/"},{"categories":["K8S"],"content":"附录 ","date":"2021-01-13","objectID":"/posts/2021/01/k8s-calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98%E9%9B%86/:3:0","tags":["K8S"],"title":"K8S calico网络插件问题集","uri":"/posts/2021/01/k8s-calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98%E9%9B%86/"},{"categories":["K8S"],"content":"检查当前节点的calico网络状态 calicoctl node status calico网络成功配置示例： [root@node2 kubernetes]# calicoctl node status Calico process is running. IPv4 BGP status +--------------+-------------------+-------+----------+-------------+ | PEER ADDRESS | PEER TYPE | STATE | SINCE | INFO | +--------------+-------------------+-------+----------+-------------+ | 192.168.1.11 | node-to-node mesh | up | 08:13:23 | Established | +--------------+-------------------+-------+----------+-------------+ IPv6 BGP status No IPv6 peers found. ","date":"2021-01-13","objectID":"/posts/2021/01/k8s-calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98%E9%9B%86/:3:1","tags":["K8S"],"title":"K8S calico网络插件问题集","uri":"/posts/2021/01/k8s-calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98%E9%9B%86/"},{"categories":["K8S"],"content":"获取k8s node命令 # run in master node DATASTORE_TYPE=kubernetes KUBECONFIG=~/.kube/config calicoctl get nodes 示例 [root@node2 kubernetes]# DATASTORE_TYPE=kubernetes KUBECONFIG=~/.kube/config calicoctl get nodes NAME gpu53 node2 ","date":"2021-01-13","objectID":"/posts/2021/01/k8s-calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98%E9%9B%86/:3:2","tags":["K8S"],"title":"K8S calico网络插件问题集","uri":"/posts/2021/01/k8s-calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98%E9%9B%86/"},{"categories":["K8S"],"content":"获取ipPool命令 # run in master node DATASTORE_TYPE=kubernetes KUBECONFIG=~/.kube/config calicoctl get ipPool -o yaml 示例 [root@node2 kubernetes]# DATASTORE_TYPE=kubernetes KUBECONFIG=~/.kube/config calicoctl get ipPool -o yaml apiVersion: projectcalico.org/v3 items: [] kind: IPPoolList metadata: {} ","date":"2021-01-13","objectID":"/posts/2021/01/k8s-calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98%E9%9B%86/:3:3","tags":["K8S"],"title":"K8S calico网络插件问题集","uri":"/posts/2021/01/k8s-calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98%E9%9B%86/"},{"categories":["开发"],"content":"记录一些 git 常用和一些记不住的命令","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"[转载]这里是我的笔记，记录一些 git 常用和一些记不住的命令，这个笔记原本是基于 颜海镜的文章增加的，后面慢慢增加了许多内容，独立一个仓库维护，方便查询和使用。 目录 安装卸载 配置管理 不常见的使用场景 忽略文件的权限变化 设置大小写敏感 配置自动换行 创建SSH密钥 多账号ssh配置 免密码登录远程服务器 https协议下提交代码免密码 文件推向3个git库 修改远程仓库地址 撤销远程记录 放弃本地的文件修改 最简单放弃本地修改内容 回退到某一个版本 搜索 commit 历史记录 回滚到某个commit提交 去掉某个commit 把 A 分支的某一个 commit，放到 B 分支上 获取最近一次提交的 commit id 两个 git 仓库合并 合并多个commit 修改远程Commit记录 利用commit关闭一个issue 新建一个空分支 添加忽略文件 忽略某个文件的改动 同步fork的上游仓库 手动合并冲突的 Pull Request 修改作者名 批量修改历史commit中的名字和邮箱 查看两个星期内的改动 查看某个文件历史 查看git仓库中最近修改的分支 更新所有本地分支 打造自己的git命令 删除已经合并到 master 的分支 中文乱码的解决方案 提交一个空文件夹 新建仓库 init status add commit remote push clone 本地 help add rm commit reset revert checkout diff stash merge cherry-pick rebase 分支branch 删除 提交 拉取 分支合并 重命名 查看 新建 连接 分支切换 远端 submodule 更新 submodule 删除 submodule 转换分支 删除文件 remote 标签tag 重命名Tag 日志log 重写历史 其它 报错问题解决 参考资料 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:0:0","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"安装卸载 官方教程，在 Linux/Unix 系统中，通过工具在中安装 git,这种方式比较简单，便于升级卸载工具。 下面介绍在 CentOS 系统中，通过 yum 来安装 git Red Hat Enterprise Linux, Oracle Linux, CentOS, Scientific Linux, et al. RHEL and derivatives typically ship older versions of git. You can download a tarball and build from source, or use a 3rd-party repository such as the IUS Community Project to obtain a more recent version of git. 官方文档说 git 在 RHEL 和衍生产品通常都会发布旧版本的 git，我们需要源码编译安装，或者使用第三方存储库（如IUS社区项目）。 现在我们通过，IUS社区下载 ius-release.rpm 文件进行安装 # 注意下载不同的版本，本机 CentOS 7 wget https://centos7.iuscommunity.org/ius-release.rpm # 安装rpm文件 rpm -ivh ius-release.rpm 查看可安装的git安装包 repoquery --whatprovides git # git-0:1.8.3.1-13.el7.x86_64 # git2u-0:2.16.5-1.ius.centos7.x86_64 # git2u-0:2.16.2-1.ius.centos7.x86_64 # git2u-0:2.16.4-1.ius.centos7.x86_64 # git-0:1.8.3.1-14.el7_5.x86_64 yum 卸载 git 安装新版本 卸载 1.8.3 的 git，安装 2.16.5 的 git # 卸载老的版本 yum remove git # 安装新的版本 yum install git2u ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:1:0","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"配置管理 首先是配置帐号信息 ssh -T git@github.com 测试。 git help config # 获取帮助信息，查看修改个人信息的参数 git config --list # 查看配置的信息 git config --global user.name \"小弟调调\" # 修改全局名字 git config --global user.email \"wowohoo@qq.com\" # 修改全局邮箱 git config --global --unset \u003centry-name\u003e # 删除全局设置 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:2:0","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"不常见的使用场景 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:0","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"忽略文件的权限变化 不再将文件的权限变化视作改动 git config core.fileMode false ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:1","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"设置大小写敏感 git config --get core.ignorecase # 查看git 的设置 git config core.ignorecase false # 设置大小写敏感 git rm -r --cached \u003c目录/文件\u003e # 远程有俩相同目录，通过这种方式清除掉，然后提交记录 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:2","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"配置自动换行 自动转换坑太大，提交到git是自动将换行符转换为lf git config --global core.autocrlf input ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:3","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"创建SSH密钥 这个密钥用来跟 github 通信，在本地终端里生成然后上传到 github ssh-keygen -t rsa -C 'wowohoo@qq.com' # 生成密钥 ssh-keygen -t rsa -C \"wowohoo@qq.com\" -f ~/.ssh/ww_rsa # 指定生成目录文件名字 ssh -T git@github.com # 测试是否成功 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:4","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"多账号ssh配置 1.生成指定名字的密钥 ssh-keygen -t rsa -C \"邮箱地址\" -f ~/.ssh/jslite_rsa 会生成 jslite_rsa 和 jslite_rsa.pub 这两个文件 2.密钥复制到托管平台上 vim ~/.ssh/jslite_rsa.pub 打开公钥文件 jslite_rsa.pub ，并把内容复制至代码托管平台上 3.修改config文件 vim ~/.ssh/config #修改config文件，如果没有创建 config Host jslite.github.com HostName github.com User git IdentityFile ~/.ssh/jslite_rsa Host work.github.com HostName github.com # Port 服务器open-ssh端口（默认：22,默认时一般不写此行） # PreferredAuthentications 配置登录时用什么权限认证 # publickey|password publickey|keyboard-interactive等 User git IdentityFile ~/.ssh/work_rsa Host 这里是个别名可以随便命名 HostName 一般是网站如：git@ss.github.com:username/repo.git 填写 github.com User 通常填写git IdentityFile 使用的公钥文件地址 4.测试 ssh -T git@jslite.github.com # `@`后面跟上定义的Host ssh -T work.github.com # 通过别名测试 ssh -i ~/公钥文件地址 Host别名 # 如 ssh -i ~/.ssh/work_rsa work.github.com 5.使用 # 原来的写法 git clone git@github.com:\u003cjslite的用户名\u003e/learngit.git # 现在的写法 git clone git@jslite.github.com:\u003cjslite的用户名\u003e/learngit.git git clone git@work.github.com:\u003cwork的用户名\u003e/learngit.git 5.注意 如果你修改了id_rsa的名字，你需要将ssh key添加到SSH agent中，如： ssh-add ~/.ssh/jslite_rsa ssh-add -l # 查看所有的key ssh-add -D # 删除所有的key ssh-add -d ~/.ssh/jslite_rsa # 删除指定的key ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:5","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"免密码登录远程服务器 $ ssh-keygen -t rsa -P '' -f ~/.ssh/aliyunserver.key $ ssh-copy-id -i ~/.ssh/aliyunserver.key.pub root@192.168.182.112 # 这里需要输入密码一次 编辑 ~/.ssh/config Host aliyun1 HostName 192.168.182.112 User root PreferredAuthentications publickey IdentityFile ~/.ssh/aliyunserver.key 上面配置完了，可以通过命令登录，不需要输入IP地址和密码 ssh aliyun1 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:6","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"https协议下提交代码免密码 git clone https://github.com/username/rep.git 通过上面方式克隆可能需要密码，解决办法：进入当前克隆的项目 vi rep/.git/config 编辑 config, 按照下面方式修改，你就可以提交代码不用输入密码了。 [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true [remote \"origin\"] - url = https://github.com/username/rep.git + url = https://用户名:密码@github.com/username/rep.git fetch = +refs/heads/*:refs/remotes/origin/* [branch \"master\"] remote = origin merge = refs/heads/master ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:7","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"文件推向3个git库 1. 增加3个远程库地址 git remote add origin https://github.com/JSLite/JSLite.git git remote set-url --add origin https://gitlab.com/wang/JSLite.js.git git remote set-url --add origin https://oschina.net/wang/JSLite.js.git 2. 删除其中一个 set-url 地址 usage: git remote set-url [--push] \u003cname\u003e \u003cnewurl\u003e [\u003coldurl\u003e] or: git remote set-url --add \u003cname\u003e \u003cnewurl\u003e or: git remote set-url --delete \u003cname\u003e \u003curl\u003e git remote set-url --delete origin https://oschina.net/wang/JSLite.js.git 3.推送代码 git push origin master git push -f origin master # 强制推送 4.拉代码 只能拉取 origin 里的一个url地址，这个fetch-url 默认为你添加的到 origin的第一个地址 git pull origin master git pull --all # 获取远程所有内容包括tag git pull origin next:master # 取回origin主机的next分支，与本地的master分支合并 git pull origin next # 远程分支是与当前分支合并 # 上面一条命令等同于下面两条命令 git fetch origin git merge origin/next 如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。 但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。 $ git pull -p # 等同于下面的命令 $ git fetch --prune origin $ git fetch -p 5.更改pull 只需要更改config文件里，那三个url的顺序即可，fetch-url会直接对应排行第一的那个utl连接。 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:8","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"修改远程仓库地址 git remote remove origin # 删除该远程路径 git remote add origin git@jslite.github.com:JSLite/JSLite.git # 添加远程路径 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:9","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"撤销远程记录 git reset --hard HEAD~1 # 撤销一条记录 git push -f origin HEAD:master # 同步到远程仓库 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:10","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"放弃本地的文件修改 git reset --hard FETCH_HEAD # FETCH_HEAD表示上一次成功git pull之后形成的commit点。然后git pull git reset --hard FETCH_HEAD 出现错误 git pull You are not currently on a branch, so I cannot use any 'branch.\u003cbranchname\u003e.merge' in your configuration file. Please specify which remote branch you want to use on the command line and try again (e.g. 'git pull \u003crepository\u003e \u003crefspec\u003e'). See git-pull(1) FOR details. 解决方法： git checkout -b temp # 新建+切换到temp分支 git checkout master ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:11","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"最简单放弃本地修改内容 # 如果有的修改以及加入暂存区的话 git reset --hard # 还原所有修改，不会删除新增的文件 git checkout . # 下面命令会删除新增的文件 git clean -xdf 通过存储暂存区stash，在删除暂存区的方法放弃本地修改。 git stash \u0026\u0026 git stash drop ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:12","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"回退到某一个版本 git reset --hard \u003chash\u003e # 例如 git reset --hard a3hd73r # --hard代表丢弃工作区的修改，让工作区与版本代码一模一样，与之对应， # --soft参数代表保留工作区的修改。 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:13","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"搜索 commit 历史记录 git log --grep=224 # 这条命令是查看含有 \"224\" 关键字的 git commit ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:14","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"回滚到某个commit提交 git revert HEAD~1 # 撤销一条记录 会弹出 commit 编辑 git push # 提交回滚 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:15","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"去掉某个commit # 实质是新建了一个与原来完全相反的commit，抵消了原来commit的效果 git revert \u003ccommit-hash\u003e ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:16","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"把 A 分支的某一个 commit，放到 B 分支上 对两个分支，同时都拥有的文件，进行修改后，再同时 commit 到这两个分支，比如 master 分支和 branch1 分支，都拥有文件 test.js ，在 master 或者 branch1 分支下对 test.js 进行修改后，把修改的 test.js 同时提交到 master 分支和 branch1 分支。 git checkout \u003cbranch-name\u003e \u0026\u0026 git cherry-pick \u003ccommit-id\u003e ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:17","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"获取最近一次提交的 commit id git rev-parse HEAD # e10721cb8859b2cd340d31a52ef4bf4b9629ddda git rev-parse --short HEAD # e10721c ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:18","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"两个 git 仓库合并 现在有两个仓库 kktjs/kkt 和 kktjs/kkt-next 我们需要将 kkt-next 仓库合并到 kkt 并保留 kkt-next 的所有提交内容。 # 1. 克隆主仓库代码 git clone git@github.com:kktjs/kkt.git # 2. 将 kkt-next 作为远程仓库，添加到 kkt 中，设置别名为 other git remote add other git@github.com:kktjs/kkt-next.git # 3. 从 kkt-next 仓库中拉取数据到本仓库 git fetch other # 4. 将 kkt-next 仓库拉取的 master 分支作为新分支 checkout 到本地，新分支名设定为 kkt-next git checkout -b kkt-next other/master # 5. 切换回 kkt 的 master 分支 git checkout master # 6. 将 kkt-next 合并入 kkt 的 master 分支 git merge kkt-next # 如果第 6 步报错 `fatal: refusing to merge unrelated histories` # 请执行下面命令 ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ git merge kkt-next --allow-unrelated-histories 在合并时有可能两个分支对同一个文件都做了修改，这时需要解决冲突，对文本文件来说很简单，根据需要对冲突的位置进行处理就可以。对于二进制文件，需要用到如下命令: git checkout --theirs YOUR_BINARY_FILES # 保留需要合并进来的分支的修改 git checkout --ours YOUR_BINARY_FILES # 保留自己的修改 git add YOUR_BINARY_FILES ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:19","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"合并多个commit # 这个命令，将最近4个commit合并为1个，HEAD代表当前版本。 # 将进入VIM界面，你可以修改提交信息。 git rebase -i HEAD~4 # 可以看到其中分为两个部分，上方未注释的部分是填写要执行的指令， # 而下方注释的部分则是指令的提示说明。指令部分中由前方的命令名称、commit hash 和 commit message 组成 # 当前我们只要知道 pick 和 squash 这两个命令即可。 # --\u003e pick 的意思是要会执行这个 commit # --\u003e squash 的意思是这个 commit 会被合并到前一个commit # 我们将 需要保留的 这个 commit 前方的命令改成 squash 或 s，然后输入:wq以保存并退出 # 这是我们会看到 commit message 的编辑界面 # 其中, 非注释部分就是两次的 commit message, 你要做的就是将这两个修改成新的 commit message。 # # 输入wq保存并推出, 再次输入git log查看 commit 历史信息，你会发现这两个 commit 已经合并了。 # 将修改强制推送到前端 git push -f origin master ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:20","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"修改远程Commit记录 git commit --amend # amend只能修改没有提交到线上的，最后一次commit记录 git rebase -i HEAD~3 # 表示要修改当前版本的倒数第三次状态 # 将要更改的记录行首单词 pick 改为 edit pick 96dc3f9 doc: Update quick-start.md pick f1cce8a test(Transition):Add transition test (#47) pick 6293516 feat(Divider): Add Divider component. # Rebase eeb03a4..6293516 onto eeb03a4 (3 commands) # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like \"squash\", but discard this commit's log message # x, exec = run command (the rest of the line) using shell # d, drop = remove commit 保存并退出，会弹出下面提示 # You can amend the commit now, with # # git commit --amend # # Once you are satisfied with your changes, run # # git rebase --continue # 通过这条命令进入编辑页面更改commit，保存退出 git commit --amend # 保存退出确认修改，继续执行 rebase, git rebase --continue # 如果修改多条记录反复执行上面两条命令直到完成所有修改 # 最后，确保别人没有提交进行push，最好不要加 -f 强制推送 git push -f origin master ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:21","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"利用commit关闭一个issue 这个功能在Github上可以玩儿，Gitlab上特别老的版本不能玩儿哦，那么如何跟随着commit关闭一个issue呢? 在confirm merge的时候可以使用一下命令来关闭相关issue: fixes #xxx、 fixed #xxx、 fix #xxx、 closes #xxx、 close #xxx、 closed #xxx、 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:22","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"新建一个空分支 # 这种方式新建的分支(gh-pages)是没有 commit 记录的 git checkout --orphan gh-pages # 删除新建的gh-pages分支原本的内容，如果不删除，提交将作为当前分支的第一个commit git rm -rf . # 查看一下状态 有可能上面一条命令，没有删除还没有提交的的文件 git state ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:23","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"添加忽略文件 echo node_modules/ \u003e\u003e .gitignore ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:24","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"忽略某个文件的改动 git update-index --assume-unchanged path/to/file # 关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动 git update-index --no-assume-unchanged path/to/file # 恢复 track 指定文件的改动 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:25","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"同步fork的上游仓库 Github教程同步fork教程，在Github上同步一个分支(fork) 设置添加多个远程仓库地址。 在同步之前，需要创建一个远程点指向上游仓库(repo).如果你已经派生了一个原始仓库，可以按照如下方法做。 $ git remote -v # List the current remotes （列出当前远程仓库） # origin https://github.com/user/repo.git (fetch) # origin https://github.com/user/repo.git (push) $ git remote add upstream https://github.com/otheruser/repo.git # Set a new remote (设置一个新的远程仓库) $ git remote -v # Verify new remote (验证新的原唱仓库) # origin https://github.com/user/repo.git (fetch) # origin https://github.com/user/repo.git (push) # upstream https://github.com/otheruser/repo.git (fetch) # upstream https://github.com/otheruser/repo.git (push) 同步更新仓库内容 同步上游仓库到你的仓库需要执行两步：首先你需要从远程拉去，之后你需要合并你希望的分支到你的本地副本分支。从上游的存储库中提取分支以及各自的提交内容。 master 将被存储在本地分支机构 upstream/master git fetch upstream # remote: Counting objects: 75, done. # remote: Compressing objects: 100% (53/53), done. # remote: Total 62 (delta 27), reused 44 (delta 9) # Unpacking objects: 100% (62/62), done. # From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY # * [new branch] master -\u003e upstream/master 检查你的 fork’s 本地 master 分支 git checkout master # Switched to branch 'master' 合并来自 upstream/master 的更改到本地 master 分支上。 这使你的前 fork’s master 分支与上游资源库同步，而不会丢失你本地修改。 git merge upstream/master # Updating a422352..5fdff0f # Fast-forward # README | 9 ------- # README.md | 7 ++++++ # 2 files changed, 7 insertions(+), 9 deletions(-) # delete mode 100644 README # create mode 100644 README.md ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:26","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"手动合并冲突的 Pull Request 以 tsbbjs/tsbb 为例，合并来自 jaywcjlove/tsbb master分支的 Pull Request。 # 1. 克隆主仓库 git clone git@github.com:tsbbjs/tsbb.git # 2. 在主仓库 master 分支切个 jaywcjlove-master 分支出来，并且切换到 jaywcjlove-master 分支 git checkout -b jaywcjlove-master master # 3. 获取 jaywcjlove/tsbb 仓库 master 分支最新代码 git pull https://github.com/jaywcjlove/tsbb.git master # ⚠️ 注意下面是输出内容： # ---------------------- # Auto-merging src/babel/transform.ts # CONFLICT (content): Merge conflict in src/babel/transform.ts # ---------------------- # ⚠️ 注意上面 CONFLICT 标识是有冲突无法自动合并的代码，根据路径进入代码手动合并 # 4. 合并完成之后，进行 commit 说明合并内容 git commit -m \"Merge branch 'master' of github.com:jaywcjlove/tsbb #3\" # 5. 切换到 master 分支，如果是 PR 其它分支，这里就切其它分支 git checkout master # 6. 合并 jaywcjlove-master 分支的代码 git merge --no-ff jaywcjlove-master # 7. 提交代码 git push origin master ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:27","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"修改作者名 git commit --amend --author='Author Name \u003cemail@address.com\u003e' ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:28","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"批量修改历史commit中的名字和邮箱 这是 Github官方教程 1.克隆仓库 注意参数，这个不是普通的clone，clone下来的仓库并不能参与开发 git clone --bare https://github.com/user/repo.git cd repo.git 2.命令行中运行代码 OLD_EMAIL原来的邮箱 CORRECT_NAME更正的名字 CORRECT_EMAIL更正的邮箱 将下面代码复制放到命令行中执行 git filter-branch -f --env-filter ' OLD_EMAIL=\"wowohoo@qq.com\" CORRECT_NAME=\"小弟调调\" CORRECT_EMAIL=\"更正的邮箱@qq.com\" if [ \"$GIT_COMMITTER_EMAIL\" = \"$OLD_EMAIL\" ] then export GIT_COMMITTER_NAME=\"$CORRECT_NAME\" export GIT_COMMITTER_EMAIL=\"$CORRECT_EMAIL\" fi if [ \"$GIT_AUTHOR_EMAIL\" = \"$OLD_EMAIL\" ] then export GIT_AUTHOR_NAME=\"$CORRECT_NAME\" export GIT_AUTHOR_EMAIL=\"$CORRECT_EMAIL\" fi ' --tag-name-filter cat -- --branches --tags 执行过程 Rewrite 160d4df2689ff6df3820563bfd13b5f1fb9ba832 (479/508) (16 seconds passed, remaining 0 predicted) Ref 'refs/heads/dev' was rewritten Ref 'refs/heads/master' was rewritten 3.同步到远程仓库 同步到push远程git仓库 git push --force --tags origin 'refs/heads/*' 我还遇到了如下面错误，lab默认给master分支加了保护，不允许强制覆盖。Project(项目)-\u003eSetting-\u003eRepository 菜单下面的Protected branches把master的保护去掉就可以了。修改完之后，建议把master的保护再加回来，毕竟强推不是件好事。 remote: GitLab: You are not allowed to force push code to a protected branch on this project. 当上面的push 不上去的时候，先 git pull 确保最新代码 git pull --allow-unrelated-histories # 或者指定分枝 git pull origin master --allow-unrelated-histories 4. 删除仓库 cd .. rm -rf repo.git ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:29","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"查看两个星期内的改动 git whatchanged --since='2 weeks ago' ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:30","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"查看某个文件历史 git log --pretty=oneline 文件名 # 列出文件的所有改动历史 git show c178bf49 # 某次的改动的修改记录 git log -p c178bf49 # 某次的改动的修改记录 git blame 文件名 # 显示文件的每一行是在那个版本最后修改。 git whatchanged 文件名 # 显示某个文件的每个版本提交信息：提交日期，提交人员，版本号，提交备注（没有修改细节） ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:31","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"查看git仓库中最近修改的分支 git for-each-ref --count=30 --sort=-committerdate refs/heads/ --format='%(refname:short)' ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:32","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"更新所有本地分支 git branch \\ --format \"%(if)%(upstream:short)%(then)git push . %(upstream:short):%(refname:short)%(end)\" | sh ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:33","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"打造自己的git命令 git config --global alias.st status git config --global alias.br branch git config --global alias.co checkout git config --global alias.ci commit 配置好后再输入git命令的时候就不用再输入一大段了，例如我们要查看状态，只需： git st ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:34","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"删除已经合并到 master 的分支 git branch --merged master | grep -v '^\\*\\| master' | xargs -n 1 git branch -d ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:35","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"中文乱码的解决方案 git config --global core.quotepath false ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:36","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"提交一个空文件夹 在空文件夹中建立一个文件 .gitkeep, 你就可以提交这个空文件夹了。 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:3:37","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"新建仓库 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:4:0","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"init git init #初始化 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:4:1","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"status git status #获取状态 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:4:2","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"add git add file # .或*代表全部添加 git rm --cached \u003cadded_file_to_undo\u003e # 在commit之前撤销git add操作 git reset head # 好像比上面git rm --cached更方便 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:4:3","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"commit git commit -m \"message\" #此处注意乱码 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:4:4","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"remote git remote add origin git@github.com:JSLite/test.git #添加源 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:4:5","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"push git push -u origin master # push同事设置默认跟踪分支 git push origin master git push -f origin master # 强制推送文件，缩写 -f（全写--force） ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:4:6","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"clone git clone git://github.com/JSLite/JSLite.js.git git clone git://github.com/JSLite/JSLite.js.git --depth=1 git clone git://github.com/JSLite/JSLite.js.git mypro # 克隆到自定义文件夹 git clone [user@]example.com:path/to/repo.git/ # SSH协议还有另一种写法。 git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。git clone \u003c版本库的网址\u003e \u003c本地目录名\u003e $ git clone http[s]://example.com/path/to/repo.git/ $ git clone ssh://example.com/path/to/repo.git/ $ git clone ssh://example.com/path/to/repo.git/ $ git clone git://example.com/path/to/repo.git/ $ git clone /opt/git/project.git $ git clone file:///opt/git/project.git $ git clone ftp[s]://example.com/path/to/repo.git/ $ git clone rsync://example.com/path/to/repo.git/ ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:5:0","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"本地 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:6:0","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"help git help config # 获取帮助信息 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:6:1","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"add git add * # 跟踪新文件 git add -u [path] # 添加[指定路径下]已跟踪文件 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:6:2","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"rm rm *\u0026git rm * # 移除文件 git rm -f * # 移除文件 git rm --cached * # 取消跟踪 git mv file_from file_to # 重命名跟踪文件 git log # 查看提交记录 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:6:3","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"commit git commit #提交更新 git commit -m 'message' #提交说明 git commit -a #跳过使用暂存区域，把所有已经跟踪过的文件暂存起来一并提交 git commit --amend #修改最后一次提交 git commit log #查看所有提交，包括没有push的commit git commit -m \"#133\" #关联issue 任意位置带上# 符号加上issue号码 git commit -m \"fix #133\" commit关闭issue git commit -m '概要描述'$'\\n\\n''1.详细描述'$'\\n''2.详细描述' #提交简要描述和详细描述 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:6:4","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"reset git reset HEAD * # 取消已经暂存的文件 git reset --mixed HEAD * # 同上 git reset --soft HEAD * # 重置到指定状态，不会修改索引区和工作树 git reset --hard HEAD * # 重置到指定状态，会修改索引区和工作树 git reset -- files * # 重置index区文件 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:6:5","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"revert git revert HEAD # 撤销前一次操作 git revert HEAD~ # 撤销前前一次操作 git revert commit # 撤销指定操作 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:6:6","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"checkout git checkout -- file # 取消对文件的修改（从暂存区——覆盖worktree file） git checkout branch|tag|commit -- file_name # 从仓库取出file覆盖当前分支 git checkout HEAD~1 [文件] # 将会更新 working directory 去匹配某次 commit git checkout -- . # 从暂存区取出文件覆盖工作区 git checkout -b gh-pages 0c304c9 # 这个表示 从当前分支 commit 哈希值为 0c304c9 的节点，分一个新的分支gh-pages出来，并切换到 gh-pages ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:6:7","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"diff git diff file # 查看指定文件的差异 git diff --stat # 查看简单的diff结果 git diff # 比较 Worktree 和 Index 之间的差异 git diff --cached # 比较Index和HEAD之间的差异 git diff HEAD # 比较Worktree和HEAD之间的差异 git diff branch # 比较Worktree和branch之间的差异 git diff branch1 branch2 # 比较两次分支之间的差异 git diff commit commit # 比较两次提交之间的差异 git diff master..test # 上面这条命令只显示两个分支间的差异 git diff master...test # 你想找出‘master’,‘test’的共有 父分支和'test'分支之间的差异，你用3个‘.'来取代前面的两个'.' ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:6:8","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"stash 存储当前的修改，但不用提交 commit git stash # 将工作区现场（已跟踪文件）储藏起来，等以后恢复后继续工作。 git stash -u # 保存当前状态，包括 untracked 的文件 git stash list # 查看保存的工作现场 git stash apply # 恢复工作现场 git stash drop # 删除stash内容 git stash clear # 删除所有的 stash git stash pop # 恢复的同时直接删除stash内容 git stash apply stash@{0} # 恢复指定的工作现场，当你保存了不只一份工作现场时。 git checkout \u003cstash@{n}\u003e -- \u003cfile-path\u003e # 从 stash 中拿出某个文件的修改 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:6:9","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"merge git merge --squash test # 合并压缩，将test上的commit压缩为一条 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:6:10","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"cherry-pick git cherry-pick commit # 拣选合并，将commit合并到当前分支 git cherry-pick -n commit # 拣选多个提交，合并完后可以继续拣选下一个提交 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:6:11","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"rebase git rebase master # 将master分之上超前的提交，变基到当前分支 git rebase --onto master 169a6 # 限制回滚范围，rebase当前分支从169a6以后的提交 git rebase --interactive # 交互模式，修改commit git rebase --continue # 处理完冲突继续合并 git rebase --skip # 跳过 git rebase --abort # 取消合并 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:6:12","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"分支branch ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:7:0","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"删除 git push origin :branchName # 删除远程分支 git push origin --delete new # 删除远程分支new git branch -d branchName # 删除本地分支，强制删除用-D git branch -d test # 删除本地test分支 git branch -D test # 强制删除本地test分支 git remote prune origin # 远程删除了，本地还能看到远程存在，这条命令删除远程不存在的分支 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:7:1","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"提交 git push -u origin branchName # 提交分支到远程origin主机中 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:7:2","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"拉取 git fetch -p # 拉取远程分支时，自动清理 远程分支已删除，本地还存在的对应同名分支。 git fetch origin '+refs/heads/*:refs/heads/*' # 更新所有分支内容 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:7:3","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"分支合并 git merge branchName # 合并分支 - 将分支branchName和当前所在分支合并 git merge origin/master # 在本地分支上合并远程分支。 git rebase origin/master # 在本地分支上合并远程分支。 git merge test # 将test分支合并到当前分支 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:7:4","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"重命名 git branch -m old new # 重命名分支 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:7:5","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"查看 git branch # 列出本地分支 git branch -r # 列出远端分支 git branch -a # 列出所有分支 git branch -v # 查看各个分支最后一个提交对象的信息 git branch --merge # 查看已经合并到当前分支的分支 git branch --no-merge # 查看为合并到当前分支的分支 git remote show origin # 可以查看remote地址，远程分支 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:7:6","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"新建 git branch test # 新建test分支 git branch newBrach 3defc69 # 指定哈希3defc69，新建分支名字为newBrach git checkout -b newBrach origin/master # 取回远程主机的更新以后，在它的基础上创建一个新的分支 git checkout -b newBrach 3defc69 # 以哈希值3defc69，新建 newBrach 分支，并切换到该分支 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:7:7","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"连接 git branch --set-upstream dev origin/dev # 将本地dev分支与远程dev分支之间建立链接 git branch --set-upstream master origin/next # 手动建立追踪关系 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:7:8","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"分支切换 git checkout - # 快速切换分支上一个分支 git checkout test # 切换到test分支 git checkout -b test # 新建+切换到test分支 git checkout -b test dev # 基于dev新建test分支，并切换 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:7:9","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"远端 git fetch \u003c远程主机名\u003e \u003c分支名\u003e # fetch取回所有分支（branch）的更新 git fetch origin remotebranch[:localbranch] # 从远端拉去分支[到本地指定分支] git merge origin/branch # 合并远端上指定分支 git pull origin remotebranch:localbranch # 拉去远端分支到本地分支 git push origin branch # 将当前分支，推送到远端上指定分支 git push origin localbranch:remotebranch # 推送本地指定分支，到远端上指定分支 git push origin :remotebranch # 删除远端指定分支 git checkout -b [--track] test origin/dev # 基于远端dev分支，新建本地test分支[同时设置跟踪] ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:8:0","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"submodule 克隆项目同时克隆 submodule git clone https://github.com/jaywcjlove/handbook.git --depth=1 --recurse-submodules 克隆项目，之后再手动克隆 submodule 子项目 git submodule add -b gh-pages --force '仓库地址' '路径' git submodule add --force '仓库地址' '路径' # 其中，仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。 # 注意：路径不能以 / 结尾（会造成修改不生效）、不能是现有工程已有的目录（不能順利 Clone） git submodule init # 初始化 submodule git submodule update # 更新submodule(必须在根目录执行命令) git submodule update --init --recursive # 下载的工程带有submodule git submodule update --recursive --remote # 对于 git 1.8.2 或更高版本，添加了选项 --remote 以支持更新远程分支 git pull --recurse-submodules # 更新 submodule git 1.7.3 版本 当使用git clone下来的工程中带有submodule时，初始的时候，submodule的内容并不会自动下载下来的，此时，只需执行如下命令： git submodule foreach --recursive git submodule init ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:9:0","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"更新 submodule git submodule foreach git pull # submodule 里有其他的 submodule 一次更新 git submodule foreach git pull origin master # submodule更新 git submodule foreach --recursive git submodule update git submodule update --recursive --remote git pull --recurse-submodules git submodule deinit --all -f # 清理 submodule ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:9:1","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"删除 submodule git ls-files --stage \u003c子项目名称路径\u003e # 查看子项目 vim .gitmodules # 删除对应的 submodule vim .git/config # 删除对应的 submodule git rm --cached \u003c子模块名称\u003e # 删除缓存中的子项目，注意没有 `/` git rm --cached subProjectName rm -rf project/subProjectName rm .git/module/* # 删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:9:2","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"转换分支 $ git config -f .gitmodules submodule.public.branch gh-pages 下面是更改 .gitmodules 文件内容 [submodule \"public\"] path = public url = git@github.com:jaywcjlove/gitke.git branch = gh-pages ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:9:3","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"删除文件 git rm -rf node_modules/ ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:10:0","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"remote git是一个分布式代码管理工具，所以可以支持多个仓库，在git里，服务器上的仓库在本地称之为remote。个人开发时，多源用的可能不多，但多源其实非常有用。 git remote add origin1 git@github.com:yanhaijing/data.js.git git remote # 显示全部源 git remote -v # 显示全部源+详细信息 git remote rename origin1 origin2 # 重命名 git remote rm origin # 删除 git remote show origin # 查看指定源的全部信息 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:11:0","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"标签tag 当开发到一定阶段时，给程序打标签是非常棒的功能。 git tag -a v0.1 -m 'my version 1.4' # 新建带注释标签 git push origin --tags # 一次性推送所有分支 git push origin v1.5 # 推送单个tag到orgin源上 git tag -v v1.4.2.1 # 验证标签，验证已经签署的标签 git show v1.5 # 看到对应的 GPG 签 git tag # 列出现有标签 git tag v0gi.1 # 新建标签 git checkout tagname # 切换到标签 git tag -d v0.1 # 删除标签 git push origin :refs/tags/v0.1 # 删除远程标签 git pull --all # 获取远程所有内容包括tag git --git-dir='\u003c绝对地址\u003e/.git' describe --tags HEAD # 查看本地版本信息 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:12:0","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"重命名Tag mv .git/refs/tags/1.9.1 .git/refs/tags/v1.9.1 git push -f --tags ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:12:1","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"日志log git config format.pretty oneline # 显示历史记录时，每个提交的信息只显示一行 git config color.ui true # 彩色的 git 输出 git log # 查看最近的提交日志 git log --grep=224 # 这条命令是查看含有 \"224\" 关键字的 git commit git log --pretty=oneline # 单行显示提交日志 git log --graph --pretty=oneline --abbrev-commit git log -num # 显示第几条log（倒数） git reflog # 查看所有分支的所有操作记录 git log --since=1.day # 一天内的提交；你可以给出各种时间格式，比如说具体的某一天（“2008-01-15”），或者是多久以前（“2 years 1 day 3 minutes ago”）。 git log --pretty=\"%h - %s\" --author=自己的名字 # 查看自己的日志 git log -p -2 # 展开两次更新显示每次提交的内容差异 git log --stat # 要快速浏览其他协作者提交的更新都作了哪些改动 git log --pretty=format:\"%h - %an, %ar : %s\"# 定制要显示的记录格式 git log --pretty=format:'%h : %s' --date-order --graph # 拓扑顺序展示 git log --pretty=format:'%h : %s - %ad' --date=short # 日期YYYY-MM-DD显示 git log --pretty=oneline --graph --decorate --all # 展示简化的 commit 历史 git log \u003clast tag\u003e HEAD --pretty=format:%s # 只显示commit git config --global format.pretty '%h : %s - %ad' --date=short #日期YYYY-MM-DD显示 写入全局配置 选项 说明 选项 说明 %H 提交对象（commit）的完整哈希字串 %ad 作者修订日期（可以用 -date= 选项定制格式） %h 提交对象的简短哈希字串 %ar 作者修订日期，按多久以前的方式显示 %T 树对象（tree）的完整哈希字串 %cn 提交者(committer)的名字 %t 树对象的简短哈希字串 %ce 提交者的电子邮件地址 %P 父对象（parent）的完整哈希字串 %cd 提交日期 %p 父对象的简短哈希字串 %cr 提交日期，按多久以前的方式显示 %an 作者（author）的名字 %s 提交说明 %ae 作者的电子邮件地址 - - Pretty Formats ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:13:0","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"重写历史 git commit --amend # 改变最近一次提交 git rebase -i HEAD~3 # 修改最近三次的提交说明，或者其中任意一次 git commit --amend # 保存好了，这些指示很明确地告诉了你该干什么 git rebase --continue # 修改提交说明，退出编辑器。 pick f7f3f6d changed my name a bit pick 310154e updated README formatting and added blame pick a5f4a0d added cat-file 改成 pick 310154e updated README formatting and added blame pick f7f3f6d changed my name a bit ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:14:0","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"其它 git help * # 获取命令的帮助信息 git status # 获取当前的状态，非常有用，因为git会提示接下来的能做的操作 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:15:0","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"报错问题解决 1. git fatal: protocol error: bad line length character: No s 解决办法：更换remote地址为 http/https 的 2. The requested URL returned error: 403 Forbidden while accessing 解决github push错误的办法： #vim 编辑器打开 当前项目中的config文件 vim .git/config #修改 [remote \"origin\"] url = https://github.com/jaywcjlove/example.git #为下面代码 [remote \"origin\"] url = https://jaywcjlove@github.com/jaywcjlove/example.git 3. git status 显示中文问题 在查看状态的时候 git status 如果是中文就显示下面的情况 \\344\\272\\247\\345\\223\\201\\351\\234\\200\\346\\261\\202 解决这个问题方法是： git config --global core.quotepath false 4. The authenticity of host 192.168.0.xxx can’t be establis 修改 /etc/ssh/ssh_config 中的 StrictHostKeyChecking 的 ask 为 no 解决问题。 5. SSH连接时出现 Host key verification failed 的原因及解决方法 用 OpenSSH 的人都知 ssh 会把你每个你访问过计算机的公钥(public key)都记录在~/.ssh/known_hosts。当下次访问相同计算机时，OpenSSH 会核对公钥。如果公钥不同，OpenSSH 会发出警告，避免你受到 DNS Hijack 之类的攻击。 SSH 对主机的 public_key 的检查等级是根据 StrictHostKeyChecking=no # 最不安全的级别，当然也没有那么多烦人的提示了，相对安全的内网测试时建议使用。如果连接server的key在本地不存在，那么就自动添加到文件中（默认是known_hosts），并且给出一个警告。 StrictHostKeyChecking=ask # 默认的级别，就是出现刚才的提示了。如果连接和key不匹配，给出提示，并拒绝登录。 StrictHostKeyChecking=yes # 最安全的级别，如果连接与key不匹配，就拒绝连接，不会提示详细信息。 【解决方法1】在 .ssh/config（或者/etc/ssh/ssh_config）中配置： StrictHostKeyChecking no UserKnownHostsFile /dev/null 解决方法 2 vi ~/.ssh/known_hosts # 删除对应ip的相关rsa信息 rm known_hosts # 或者直接全部删除 5. insufficient permission for adding an object to repository database .git/objects cd .git/objects ls -al sudo chown -R yourname:yourgroup * ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:16:0","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["开发"],"content":"参考资料 Git官网 Github 15分钟学习Git Git参考手册 Git简明手册 Git Magic Git Community Book 中文版 Pro Git 图解Git git-简明指南 learnGitBranching 在线学习工具 初级教程 廖雪峰的Git教程 蒋鑫老师将带你入github的大门 git详解 oschina教程 How to undo (almost) anything with Git撤销一切，汇总各种回滚撤销的场景，加强学习。 Git 教程 | 菜鸟教程runoob.com Git 本地仓库和裸仓库 沉浸式学 Git Git进阶用法，主要是rebase高级用法 成为一个git大师 高质量的Git中文教程 ","date":"2021-01-12","objectID":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/:17:0","tags":["Git"],"title":"[转载]一些 git 常用和一些记不住的命令","uri":"/posts/2021/01/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B-git-%E5%B8%B8%E7%94%A8%E5%92%8C%E4%B8%80%E4%BA%9B%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["Python"],"content":"python生成requirements.txt环境打包，利用requirements.txt离线安装Python环境","date":"2021-01-11","objectID":"/posts/2021/01/python%E7%94%9F%E6%88%90requirements.txt%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/","tags":["Python"],"title":"python生成requirements.txt环境打包","uri":"/posts/2021/01/python%E7%94%9F%E6%88%90requirements.txt%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/"},{"categories":["Python"],"content":"python生成requirements.txt环境打包，利用requirements.txt离线安装Python环境 ","date":"2021-01-11","objectID":"/posts/2021/01/python%E7%94%9F%E6%88%90requirements.txt%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/:0:0","tags":["Python"],"title":"python生成requirements.txt环境打包","uri":"/posts/2021/01/python%E7%94%9F%E6%88%90requirements.txt%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/"},{"categories":["Python"],"content":"python环境，pip安装的包写入requirements.txt #查看安装的包 pip list #把包写入到requirements.txt中 pip freeze \u003e requirements.txt ","date":"2021-01-11","objectID":"/posts/2021/01/python%E7%94%9F%E6%88%90requirements.txt%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/:1:0","tags":["Python"],"title":"python生成requirements.txt环境打包","uri":"/posts/2021/01/python%E7%94%9F%E6%88%90requirements.txt%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/"},{"categories":["Python"],"content":"pip3方式 pip3 list pip3 freeze \u003e requirements.txt ","date":"2021-01-11","objectID":"/posts/2021/01/python%E7%94%9F%E6%88%90requirements.txt%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/:1:1","tags":["Python"],"title":"python生成requirements.txt环境打包","uri":"/posts/2021/01/python%E7%94%9F%E6%88%90requirements.txt%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/"},{"categories":["Python"],"content":"离线安装 ","date":"2021-01-11","objectID":"/posts/2021/01/python%E7%94%9F%E6%88%90requirements.txt%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/:2:0","tags":["Python"],"title":"python生成requirements.txt环境打包","uri":"/posts/2021/01/python%E7%94%9F%E6%88%90requirements.txt%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/"},{"categories":["Python"],"content":"下载python环境pip包 在可连接外网的环境中，将requirements.txt中导入的包离线下载到packagesdir目录下 packagesdir=/home/wangb/pip3_packages pip3 download -i https://pypi.douban.com/simple -d $packagesdir -r requirements.txt #pip download -d $packagesdir -r requirements.txt ","date":"2021-01-11","objectID":"/posts/2021/01/python%E7%94%9F%E6%88%90requirements.txt%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/:2:1","tags":["Python"],"title":"python生成requirements.txt环境打包","uri":"/posts/2021/01/python%E7%94%9F%E6%88%90requirements.txt%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/"},{"categories":["Python"],"content":"离线安装下载包 将packagesdir下的下载包，拷贝到内网环境packagesdir目录下 拷贝requirements.txt 到内网环境 执行离线安装命令 packagesdir=/home/wangb/pip3_packages pip3 install --no-index --find-links=$packagesdir -r requirements.txt #pip install --no-index --find-links=$packagesdir -r requirements.txt ","date":"2021-01-11","objectID":"/posts/2021/01/python%E7%94%9F%E6%88%90requirements.txt%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/:2:2","tags":["Python"],"title":"python生成requirements.txt环境打包","uri":"/posts/2021/01/python%E7%94%9F%E6%88%90requirements.txt%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/"},{"categories":["K8S"],"content":"基于K8S1.20的affinity topology feature源码分析","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"topology manager是k8s1.16版本以后kubelet中新增的子模块，并在1.18版本更新为beta版特性，按节点资源NUMA亲和性和插件资源自身拓扑亲和性策略，对作业和任务进行资源分配。本文k8s源码分析为1.20版本。 ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:0:0","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"topology-manager设计方案 kubelet numa拓扑亲和性资源分配方案： Kubernetes Topology Manager Moves to Beta - Align Up! 设计方案中的资源拓扑分配例子如下： An example system with 2 NUMA nodes, 2 Sockets with 4 CPUs each, 2 GPUs, and 2 NICs. CPUs on Socket 0, GPU 0, and NIC 0 are all part of NUMA node 0. CPUs on Socket 1, GPU 1, and NIC 1 are all part of NUMA node 1. For example, consider the system in above, with the following two containers requesting resources from it: Container Name CPU GPU NIC Container0 2 1 1 Container1 2 1 1 If Container0 is the first container considered for allocation on the system, the following set of hints will be generated for the three topology-aware resource types in the spec. cpu: {{01: True}, {10: True}, {11: False}} gpu-vendor.com/gpu: {{01: True}, {10: True}} nic-vendor.com/nic: {{01: True}, {10: True}} With a resulting aligned allocation of: {cpu: {0, 1}, gpu: 0, nic: 0} When considering Container1 these resources are then presumed to be unavailable, and thus only the following set of hints will be generated: cpu: {{01: True}, {10: True}, {11: False}} gpu-vendor.com/gpu: {{10: True}} nic-vendor.com/nic: {{10: True}} With a resulting aligned allocation of: {cpu: {4, 5}, gpu: 1, nic: 1} Supporting device-specific constraints Currently, NUMA affinity is the only constraint considered by the TopologyManager for resource alignment. Moreover, the only scalable extensions that can be made to a TopologyHint involve node-level constraints, such as PCIe bus alignment across device types. It would be intractable to try and add any device-specific constraints to this struct (e.g. the internal NVLINK topology among a set of GPU devices). As such, we propose an extension to the device plugin interface that will allow a plugin to state its topology-aware allocation preferences, without having to expose any device-specific topology information to the kubelet. In this way, the TopologyManager can be restricted to only deal with common node-level topology constraints, while still having a way of incorporating device-specific topology constraints into its allocation decisions. Details of this proposal can be found here, and should be available as soon as Kubernetes 1.19. 说明：目前，NUMA affinity是kubelet的TopologyManager唯一的资源对齐的约束条件（对齐标准），而设备可扩展拓扑约束条件只有非节点级别的。 Add proposal for GetPreferredAllocation() to TopologyManager KEP This proposal adds an API to allow a device plugin to forward a “preferred allocation” to the devicemanager so it can incorporate this information into its allocation decisions. It leaves the devicemanager in charge of making the final allocation, but gives the plugin the chance to help influence it more directly. Using this new API call, the devicemanager will call out to a plugin at pod admission time, asking it for a preferred device allocation of a given size from a list of available devices. One call will be made per-container for each pod. The list of available devices passed to the GetPreferredAllocation() call do not necessarily match the full list of available devices on the system. Instead, the devicemanager treats the GetPreferredAllocation() call as a “last-level” filter on the set of devices it has to choose from after taking all TopologyHint information into consideration. As such, the list of available devices passed to this call will already be pre-filtered by the topology constraints encoded in the TopologyHint. As such, the preferred allocation is not guaranteed to be the allocation ultimately performed by the devicemanager. It is only designed to help the devicemanager make a more informed allocation decision when possible. When deciding on a preferred allocation, a device plugin will likely take internal topology-constraints into consideration, that the devicemanager is unaware of. A good example of this is the case of allocating pairs of NVIDIA GPUs that always include an NVLINK. On an 8 GPU machine, with a request for 2 GPUs, the best connected pairs by NVLINK might be: {{0,3}, {1,2}, {4,7}, {5,6}} Using GetPrefe","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:1:0","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"流程 在分析源码前，先整理画出相关流程时序图。便于总体理解业务流程。如下 ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:2:0","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"资源管理组件创建和device plugin注册流程 这里以nvidia-k8s-deviceplugin为例，说明GPU设备注册流程 ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:2:1","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"kubelet分配资源流程 kubelet根据topology manager计算资源拓扑亲和性，并由cpu manager分配cpu资源；device manager分配插件资源 ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:2:2","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"主流程代码 kubelet/cm/topologymanager/scope_container.go func (s *containerScope) Admit(pod *v1.Pod) lifecycle.PodAdmitResult { if s.policy.Name() == PolicyNone { return s.admitPolicyNone(pod) } for _, container := range append(pod.Spec.InitContainers, pod.Spec.Containers...) { // bestHint, admit := s.calculateAffinity(pod, \u0026container) providersHints := s.accumulateProvidersHints(pod, container) bestHint, admit := s.policy.Merge(providersHints) if !admit { return topologyAffinityError() } if (s.podTopologyHints)[string(pod.UID)] == nil { (s.podTopologyHints)[string(pod.UID)] = make(map[string]TopologyHint) } klog.Infof(\"[topologymanager] Topology Affinity for (pod: %v container: %v): %v\", format.Pod(pod), container.Name, bestHint) (s.podTopologyHints)[string(pod.UID)][container.Name] = bestHint err := s.allocateAlignedResources(pod, \u0026container) if err != nil { return unexpectedAdmissionError(err) } } return admitPod() } 遍历pod中的所有容器 计算ProvidersHints，获取分配方案建议bestHint, 结果admit 按上面的对齐分配方案，为pod分配资源 参考数据结构 // Scope interface for Topology Manager type Scope interface { Name() string Admit(pod *v1.Pod) lifecycle.PodAdmitResult // AddHintProvider adds a hint provider to manager to indicate the hint provider // wants to be consoluted with when making topology hints AddHintProvider(h HintProvider) // AddContainer adds pod to Manager for tracking AddContainer(pod *v1.Pod, containerID string) error // RemoveContainer removes pod from Manager tracking RemoveContainer(containerID string) error // Store is the interface for storing pod topology hints Store } type scope struct { mutex sync.Mutex name string // Mapping of a Pods mapping of Containers and their TopologyHints // Indexed by PodUID to ContainerName podTopologyHints podTopologyHints // The list of components registered with the Manager hintProviders []HintProvider // Topology Manager Policy policy Policy // Mapping of PodUID to ContainerID for Adding/Removing Pods from PodTopologyHints mapping podMap map[string]string } // 格式: map[string(pod.UID)][container.Name]TopologyHint type podTopologyHints map[string]map[string]TopologyHint // TopologyHint is a struct containing the NUMANodeAffinity for a Container type TopologyHint struct { NUMANodeAffinity bitmask.BitMask // Preferred is set to true when the NUMANodeAffinity encodes a preferred // allocation for the Container. It is set to false otherwise. Preferred bool } // HintProvider is an interface for components that want to collaborate to // achieve globally optimal concrete resource alignment with respect to // NUMA locality. type HintProvider interface { // GetTopologyHints returns a map of resource names to a list of possible // concrete resource allocations in terms of NUMA locality hints. Each hint // is optionally marked \"preferred\" and indicates the set of NUMA nodes // involved in the hypothetical allocation. The topology manager calls // this function for each hint provider, and merges the hints to produce // a consensus \"best\" hint. The hint providers may subsequently query the // topology manager to influence actual resource assignment. GetTopologyHints(pod *v1.Pod, container *v1.Container) map[string][]TopologyHint // GetPodTopologyHints returns a map of resource names to a list of possible // concrete resource allocations per Pod in terms of NUMA locality hints. GetPodTopologyHints(pod *v1.Pod) map[string][]TopologyHint // Allocate triggers resource allocation to occur on the HintProvider after // all hints have been gathered and the aggregated Hint is available via a // call to Store.GetAffinity(). Allocate(pod *v1.Pod, container *v1.Container) error } ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:2:3","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"topology affinity hintProviders实际上为参与进行资源分配的资源管理器，其扩展topo计算接口，目前使用的是cpumanger和devicemanager cpumanger用于管理分配cpu资源，比如按static策略分配cpuset devicemanager用于管理分配k8s可扩展资源，比如k8s-nvidia-gpu插件管理的gpu资源 func (s *containerScope) accumulateProvidersHints(pod *v1.Pod, container *v1.Container) []map[string][]TopologyHint { var providersHints []map[string][]TopologyHint // hintProviders实际上为参与进行资源分配的资源管理器，其扩展topo计算接口，目前使用的是cpumanger和devicemanager for _, provider := range s.hintProviders { // Get the TopologyHints for a Container from a provider. hints := provider.GetTopologyHints(pod, container) providersHints = append(providersHints, hints) klog.Infof(\"[topologymanager] TopologyHints for pod '%v', container '%v': %v\", format.Pod(pod), container.Name, hints) } return providersHints } ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:3:0","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"cpumanager cpumanager ：GetTopologyHints -\u003e m.policy.GetTopologyHints(m.state, pod, container)[staticPolicy.GetTopologyHints] -\u003e generateCPUTopologyHints(available, reusable, requested) 计算并返回cpu资源的TopologyHint列表信息 func (p *staticPolicy) GetTopologyHints(){ // Get a list of available CPUs. available := p.assignableCPUs(s) // Get a list of reusable CPUs (e.g. CPUs reused from initContainers). // It should be an empty CPUSet for a newly created pod. reusable := p.cpusToReuse[string(pod.UID)] // Generate hints. cpuHints := p.generateCPUTopologyHints(available, reusable, requested) // 返回cpu资源的TopologyHint列表信息 return map[string][]topologymanager.TopologyHint{ // \"cpu\" : [{01 true} {10 true} {11 false}] string(v1.ResourceCPU): cpuHints, } } 计算cpu Hints generateCPUTopologyHints func (p *staticPolicy) generateCPUTopologyHints(availableCPUs cpuset.CPUSet, reusableCPUs cpuset.CPUSet, request int) []topologymanager.TopologyHint { // Initialize minAffinitySize to include all NUMA Nodes. minAffinitySize := p.topology.CPUDetails.NUMANodes().Size() // 执行了具体计算topo hint的算法 bitmask.IterateBitMasks(topology.CPUDetails.NUMANodes().ToSlice(), call_back_func{}) // If they don't, then move onto the next combination. if numMatching \u003c request { return } // Loop back through all hints and update the 'Preferred' field based on // counting the number of bits sets in the affinity mask and comparing it // to the minAffinitySize. Only those with an equal number of bits set (and // with a minimal set of numa nodes) will be considered preferred. for i := range hints { // 选择bitmap最窄的NUMANode，Preferred = true if hints[i].NUMANodeAffinity.Count() == minAffinitySize { hints[i].Preferred = true } } // 返回hints结果集，形式如：[{01 true} {10 true} {11 false}] // Preferred 优选字段标识 该hint是否为优先考虑方案 return hints } ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:4:0","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"devicemanager GetTopologyHints // GetTopologyHints implements the TopologyManager HintProvider Interface which // ensures the Device Manager is consulted when Topology Aware Hints for each // container are created. func (m *ManagerImpl) GetTopologyHints(pod *v1.Pod, container *v1.Container) map[string][]topologymanager.TopologyHint { // Garbage collect any stranded device resources before providing TopologyHints m.UpdateAllocatedDevices() // Loop through all device resources and generate TopologyHints for them.. deviceHints := make(map[string][]topologymanager.TopologyHint) for resourceObj, requestedObj := range container.Resources.Limits { resource := string(resourceObj) requested := int(requestedObj.Value()) // Only consider resources associated with a device plugin. // 只考虑device plugin的扩展资源 if m.isDevicePluginResource(resource) { // Only consider devices that actually container topology information. // 只考虑有拓扑信息的资源，比如按numa对齐的gpus if aligned := m.deviceHasTopologyAlignment(resource)!aligned { klog.Infof(\"[devicemanager] Resource '%v' does not have a topology preference\", resource) deviceHints[resource] = nil continue } // Get the list of available devices, for which TopologyHints should be generated. available := m.getAvailableDevices(resource) reusable := m.devicesToReuse[string(pod.UID)][resource] // Generate TopologyHints for this resource given the current // request size and the list of available devices. deviceHints[resource] = m.generateDeviceTopologyHints(resource, available, reusable, requested) } } return deviceHints } 计算device Hints generateDeviceTopologyHints func (m *ManagerImpl) generateDeviceTopologyHints(resource string, available sets.String, reusable sets.String, request int) []topologymanager.TopologyHint { // Initialize minAffinitySize to include all NUMA Nodes minAffinitySize := len(m.numaNodes) // Iterate through all combinations of NUMA Nodes and build hints from them. hints := []topologymanager.TopologyHint{} bitmask.IterateBitMasks(m.numaNodes, call_back_func{}) // Loop back through all hints and update the 'Preferred' field based on // counting the number of bits sets in the affinity mask and comparing it // to the minAffinity. Only those with an equal number of bits set will be // considered preferred. for i := range hints { if hints[i].NUMANodeAffinity.Count() == minAffinitySize { hints[i].Preferred = true } } return hints } ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:5:0","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"merge hints ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:6:0","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"merge算法思想 merge思想，是把多种类型资源的topo hints（即下面中的每一行），合并为一个hint，合并算法为位与运算。 不同的topo policy实现，区别就在merge处理中，如下 func (p *nonePolicy) Merge(providersHints []map[string][]TopologyHint) (TopologyHint, bool) { return TopologyHint{}, p.canAdmitPodResult(nil) } func (p *bestEffortPolicy) Merge(providersHints []map[string][]TopologyHint) (TopologyHint, bool) { // 1. 遍历全部hint providers，收集全部的hint，到filteredProvidersHints列表中。 // 本质上，是把map数据，转换成二维列表[][]TopologyHint，目的便于后面的mergeFilteredHints处理 filteredProvidersHints := filterProvidersHints(providersHints) bestHint := mergeFilteredHints(p.numaNodes, filteredProvidersHints) admit := p.canAdmitPodResult(\u0026bestHint) return bestHint, admit } func (p *restrictedPolicy) Merge(providersHints []map[string][]TopologyHint) (TopologyHint, bool) { filteredHints := filterProvidersHints(providersHints) hint := mergeFilteredHints(p.numaNodes, filteredHints) admit := p.canAdmitPodResult(\u0026hint) return hint, admit } func (p *singleNumaNodePolicy) Merge(providersHints []map[string][]TopologyHint) (TopologyHint, bool) { filteredHints := filterProvidersHints(providersHints) // Filter to only include don't cares and hints with a single NUMA node. singleNumaHints := filterSingleNumaHints(filteredHints) bestHint := mergeFilteredHints(p.numaNodes, singleNumaHints) defaultAffinity, _ := bitmask.NewBitMask(p.numaNodes...) if bestHint.NUMANodeAffinity.IsEqual(defaultAffinity) { bestHint = TopologyHint{nil, bestHint.Preferred} } admit := p.canAdmitPodResult(\u0026bestHint) return bestHint, admit } ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:6:1","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"mergeFilteredHints处理 func mergeFilteredHints(numaNodes []int, filteredHints [][]TopologyHint) TopologyHint { // Set the default affinity as an any-numa affinity containing the list // of NUMA Nodes available on this machine. defaultAffinity, _ := bitmask.NewBitMask(numaNodes...) // Set the bestHint to return from this function as {nil false}. // This will only be returned if no better hint can be found when // merging hints from each hint provider. bestHint := TopologyHint{defaultAffinity, false} // 计算merge结果 iterateAllProviderTopologyHints(filteredHints, call_back_func{}) return bestHint } ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:6:2","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"mergePermutation处理 应用了向量叉积(Cross Product)，但只是组合排列，并未求和 permutation为iterateAllProviderTopologyHints中罗列出的各种资源类型的hints的全部排列 位与运算bitmask.And，计算besthint值mergedAffinity hint.Preferred 逻辑与关系，全部为true，则为true。否则为false // Merge a TopologyHints permutation to a single hint by performing a bitwise-AND // of their affinity masks. The hint shall be preferred if all hits in the permutation // are preferred. func mergePermutation(numaNodes []int, permutation []TopologyHint) TopologyHint { // Get the NUMANodeAffinity from each hint in the permutation and see if any // of them encode unpreferred allocations. preferred := true defaultAffinity, _ := bitmask.NewBitMask(numaNodes...) var numaAffinities []bitmask.BitMask for _, hint := range permutation { // Only consider hints that have an actual NUMANodeAffinity set. if hint.NUMANodeAffinity == nil { numaAffinities = append(numaAffinities, defaultAffinity) } else { numaAffinities = append(numaAffinities, hint.NUMANodeAffinity) } if !hint.Preferred { preferred = false } } // Merge the affinities using a bitwise-and operation. mergedAffinity := bitmask.And(defaultAffinity, numaAffinities...) // Build a mergedHint from the merged affinity mask, indicating if an // preferred allocation was used to generate the affinity mask or not. return TopologyHint{mergedAffinity, preferred} } ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:6:3","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"bestHint kubelet会再次遍历merged hint，得出bestHint，最终按bestHint进行资源分配。 bestHint算法思想： 优选preference为true的merge hint，即mergedHint.Preferred: true 在相同preference条件下，优选长度最窄的NUMANodeAffinity（bitmap类型） 计算好bestHint后，并保存，为后面流程使用 (s.podTopologyHints)[string(pod.UID)][container.Name] = bestHint 小结： hints的合并流程：resource topo hints -\u003e merged hints -\u003e bestHint ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:7:0","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"算法函数 ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:8:0","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"计算BitMasks 组合 资源单元的分配是一种寻找组合的算法 bits列表即为NUMANodes返回与资源(如cpu)相关联的所有NUMANode id列表 // IterateBitMasks iterates all possible masks from a list of bits, // issuing a callback on each mask. func IterateBitMasks(bits []int, callback func(BitMask)) { var iterate func(bits, accum []int, size int) iterate = func(bits, accum []int, size int) { if len(accum) == size { // 构建size个numa组的bits按位或得到的mask，比如size=2时，输出numa组id组合：{01,10,11} mask, _ := NewBitMask(accum...) // callback 会对获得的各种长度的numa node mask进程处理 callback(mask) return } // 组合，遍历可选numa的bits列表 for i := range bits { iterate(bits[i+1:], append(accum, bits[i]), size) } } // bits列表即为NUMANodes返回与资源(如cpu)相关联的所有NUMANode id列表，如：[0,1]或者[0,1,2...7]或者 [0,1,2,3....63] // 并枚举1到全部numa node长度的numa node id 组合 for i := 1; i \u003c= len(bits); i++ { iterate(bits, []int{}, i) } } IterateBitMasks是计算topo hint的关键函数，在cpumangager和devicemanager中都有使用 IterateBitMasks本质上是计算出了资源列表（bits选择列表）的全部组合（size大小），如：cpuset的各种组合；devices中gpus的各种组合 DFS算法 ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:8:1","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"计算AllProviderTopologyHints 排列 不同资源类型的hits合并，是全排列算法 // Iterate over all permutations of hints in 'allProviderHints [][]TopologyHint'. // // This procedure is implemented as a recursive function over the set of hints // in 'allproviderHints[i]'. It applies the function 'callback' to each // permutation as it is found. It is the equivalent of: // // for i := 0; i \u003c len(providerHints[0]); i++ // for j := 0; j \u003c len(providerHints[1]); j++ // for k := 0; k \u003c len(providerHints[2]); k++ // ... // for z := 0; z \u003c len(providerHints[-1]); z++ // permutation := []TopologyHint{ // providerHints[0][i], // providerHints[1][j], // providerHints[2][k], // ... // providerHints[-1][z] // } // callback(permutation) func iterateAllProviderTopologyHints(allProviderHints [][]TopologyHint, callback func([]TopologyHint)) { // Internal helper function to accumulate the permutation before calling the callback. var iterate func(i int, accum []TopologyHint) iterate = func(i int, accum []TopologyHint) { // Base case: we have looped through all providers and have a full permutation. if i == len(allProviderHints) { callback(accum) return } // Loop through all hints for provider 'i', and recurse to build the // the permutation of this hint with all hints from providers 'i++'. for j := range allProviderHints[i] { iterate(i+1, append(accum, allProviderHints[i][j])) } } iterate(0, []TopologyHint{}) } ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:8:2","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"资源分配 ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:9:0","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"allocateAlignedResources // It would be better to implement this function in topologymanager instead of scope // but topologymanager do not track providers anymore func (s *scope) allocateAlignedResources(pod *v1.Pod, container *v1.Container) error { for _, provider := range s.hintProviders { err := provider.Allocate(pod, container) if err != nil { return err } } return nil } ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:9:1","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"cpumanger 根据前面计算出的topo hint 进行cpu分配 func (p *staticPolicy) Allocate(s state.State, pod *v1.Pod, container *v1.Container) error { if numCPUs := p.guaranteedCPUs(pod, container); numCPUs != 0 { // Call Topology Manager to get the aligned socket affinity across all hint providers. hint := p.affinity.GetAffinity(string(pod.UID), container.Name) // Allocate CPUs according to the NUMA affinity contained in the hint. cpuset, err := p.allocateCPUs(s, numCPUs, hint.NUMANodeAffinity, p.cpusToReuse[string(pod.UID)]) s.SetCPUSet(string(pod.UID), container.Name, cpuset) p.updateCPUsToReuse(pod, container, cpuset) } // container belongs in the shared pool (nothing to do; use default cpuset) return nil } ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:9:2","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"devicemanger devicemanger的资源分配逻辑处理逻辑较多。首先看下调用链，如下： Allocate -\u003e allocateContainerResources -\u003e devicesToAllocate // Returns list of device Ids we need to allocate with Allocate rpc call. // Returns empty list in case we don't need to issue the Allocate rpc call. func (m *ManagerImpl) devicesToAllocate(podUID, contName, resource string, required int, reusableDevices sets.String) (sets.String, error) { // Declare the list of allocated devices. // This will be populated and returned below. allocated := sets.NewString() // Create a closure to help with device allocation // Returns 'true' once no more devices need to be allocated. allocateRemainingFrom := func(devices sets.String) bool { for device := range devices.Difference(allocated) { m.allocatedDevices[resource].Insert(device) allocated.Insert(device) needed-- if needed == 0 { return true } } return false } // Allocates from reusableDevices list first. if allocateRemainingFrom(reusableDevices) { return allocated, nil } // Needs to allocate additional devices. if m.allocatedDevices[resource] == nil { m.allocatedDevices[resource] = sets.NewString() } // Gets Devices in use. devicesInUse := m.allocatedDevices[resource] // Gets Available devices. available := m.healthyDevices[resource].Difference(devicesInUse) if available.Len() \u003c needed { return nil, fmt.Errorf(\"requested number of devices unavailable for %s. Requested: %d, Available: %d\", resource, needed, available.Len()) } // Filters available Devices based on NUMA affinity. aligned, unaligned, noAffinity := m.filterByAffinity(podUID, contName, resource, available) // If we can allocate all remaining devices from the set of aligned ones, then // give the plugin the chance to influence which ones to allocate from that set. if needed \u003c aligned.Len() { // First allocate from the preferred devices list (if available). preferred, err := m.callGetPreferredAllocationIfAvailable(podUID, contName, resource, aligned.Union(allocated), allocated, required) if err != nil { return nil, err } if allocateRemainingFrom(preferred.Intersection(aligned)) { return allocated, nil } // Then fallback to allocate from the aligned set if no preferred list // is returned (or not enough devices are returned in that list). if allocateRemainingFrom(aligned) { return allocated, nil } return nil, fmt.Errorf(\"unexpectedly allocated less resources than required. Requested: %d, Got: %d\", required, required-needed) } // If we can't allocate all remaining devices from the set of aligned ones, // then start by first allocating all of the aligned devices (to ensure // that the alignment guaranteed by the TopologyManager is honored). if allocateRemainingFrom(aligned) { return allocated, nil } // Then give the plugin the chance to influence the decision on any // remaining devices to allocate. preferred, err := m.callGetPreferredAllocationIfAvailable(podUID, contName, resource, available.Union(allocated), allocated, required) if err != nil { return nil, err } if allocateRemainingFrom(preferred.Intersection(available)) { return allocated, nil } // Finally, if the plugin did not return a preferred allocation (or didn't // return a large enough one), then fall back to allocating the remaining // devices from the 'unaligned' and 'noAffinity' sets. if allocateRemainingFrom(unaligned) { return allocated, nil } if allocateRemainingFrom(noAffinity) { return allocated, nil } return nil, fmt.Errorf(\"unexpectedly allocated less resources than required. Requested: %d, Got: %d\", required, required-needed) } numa亲和性分配主要在filterByAffinity中 构造了perNodeDevices map对象: map[numaid]deivces 构造返回结果集：sets.NewString(fromAffinity…), sets.NewString(notFromAffinity…), sets.NewString(withoutTopology…), 即 基于numa亲和性从available资源中过滤出：aligned, unaligned, noAffinity func (m *ManagerImpl) filterByAffinity(podUID, contName, resource string, available sets.String) (sets.String, sets.String, sets.String) { // Build a map of NUMA Nodes to the devices associated with them. A // device may be associated to multi","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:9:3","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"接口 ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:10:0","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"接口位置 kubernetes/staging/src/k8s.io/kubelet/pkg/apis/deviceplugin/v1beta1/api.proto // DevicePlugin is the service advertised by Device Plugins service DevicePlugin { // GetDevicePluginOptions returns options to be communicated with Device // Manager rpc GetDevicePluginOptions(Empty) returns (DevicePluginOptions) {} // ListAndWatch returns a stream of List of Devices // Whenever a Device state change or a Device disappears, ListAndWatch // returns the new list rpc ListAndWatch(Empty) returns (stream ListAndWatchResponse) {} // GetPreferredAllocation returns a preferred set of devices to allocate // from a list of available ones. The resulting preferred allocation is not // guaranteed to be the allocation ultimately performed by the // devicemanager. It is only designed to help the devicemanager make a more // informed allocation decision when possible. rpc GetPreferredAllocation(PreferredAllocationRequest) returns (PreferredAllocationResponse) {} // Allocate is called during container creation so that the Device // Plugin can run device specific operations and instruct Kubelet // of the steps to make the Device available in the container rpc Allocate(AllocateRequest) returns (AllocateResponse) {} // PreStartContainer is called, if indicated by Device Plugin during registeration phase, // before each container start. Device plugin can run device specific operations // such as resetting the device before making devices available to the container rpc PreStartContainer(PreStartContainerRequest) returns (PreStartContainerResponse) {}}// ListAndWatch returns a stream of List of Devices // Whenever a Device state change or a Device disappears, ListAndWatch // returns the new list message ListAndWatchResponse { repeated Device devices = 1;}message TopologyInfo { repeated NUMANode nodes = 1;}message NUMANode { int64 ID = 1;}/* E.g: * struct Device { * ID: \"GPU-fef8089b-4820-abfc-e83e-94318197576e\", * Health: \"Healthy\", * Topology: * Node: * ID: 1 *} */message Device { // A unique ID assigned by the device plugin used // to identify devices during the communication // Max length of this field is 63 characters string ID = 1; // Health of the device, can be healthy or unhealthy, see constants.go string health = 2; // Topology for device TopologyInfo topology = 3;} ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:10:1","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"NVIDIA k8s-device-plugin 插件版本：k8s-device-plugin-0.7.3 ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:11:0","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"gpu device 目前插件对分配策略的参数配置如下 “nvidia.com/gpu\"的GPU资源，默认采用BestEffortPolicy plugins := []*NvidiaDevicePlugin{ NewNvidiaDevicePlugin( \"nvidia.com/gpu\", NewGpuDeviceManager(true), \"NVIDIA_VISIBLE_DEVICES\", gpuallocator.NewBestEffortPolicy(), pluginapi.DevicePluginPath+\"nvidia-gpu.sock\"), } ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:11:1","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"处理流程 分析k8s-device-plugin对GetPreferredAllocation处理 对kubelet的请求参数AvailableDeviceIDs和MustIncludeDeviceIDs进行校验，构造available和required 按策略执行allocatePolicy.Allocate // GetPreferredAllocation returns the preferred allocation from the set of devices specified in the request func (m *NvidiaDevicePlugin) GetPreferredAllocation(ctx context.Context, r *pluginapi.PreferredAllocationRequest) (*pluginapi.PreferredAllocationResponse, error) { response := \u0026pluginapi.PreferredAllocationResponse{} for _, req := range r.ContainerRequests { available, err := gpuallocator.NewDevicesFrom(req.AvailableDeviceIDs) if err != nil { return nil, fmt.Errorf(\"Unable to retrieve list of available devices: %v\", err) } required, err := gpuallocator.NewDevicesFrom(req.MustIncludeDeviceIDs) if err != nil { return nil, fmt.Errorf(\"Unable to retrieve list of required devices: %v\", err) } allocated := m.allocatePolicy.Allocate(available, required, int(req.AllocationSize)) var deviceIds []string for _, device := range allocated { deviceIds = append(deviceIds, device.UUID) } resp := \u0026pluginapi.ContainerPreferredAllocationResponse{ DeviceIDs: deviceIds, } response.ContainerResponses = append(response.ContainerResponses, resp) } return response, nil } ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:11:2","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"处理策略 GPU分配算法采用了策略模式，相关代码文件位置在 k8s-device-plugin\\vendor\\github.com\\NVIDIA\\go-gpuallocator\\gpuallocator gpu插件的资源分配算法已经封装为依赖包NVIDIA\\go-gpuallocator simplePolicy 算法思想 先选required，再从set(available - required)中，选择满足size大小的gpus数。 该算法简单且没有考虑任何GPU拓扑连接 // Allocate GPUs following a simple policy. func (p *simplePolicy) Allocate(available []*Device, required []*Device, size int) []*Device { if size \u003c= 0 { return []*Device{} } if len(available) \u003c size { return []*Device{} } if len(required) \u003e size { return []*Device{} } availableSet := NewDeviceSet(available...) if !availableSet.ContainsAll(required) { return []*Device{} } availableSet.Delete(required...) allocated := append([]*Device{}, required...) allocated = append(allocated, availableSet.SortedSlice()[:size-len(allocated)]...) return allocated } bestEffortPolicy 算法思想 Allocate从可用GPU设备列表中查找要分配的最佳大小GPU集，并返回它们。该算法旨在确保必需GPU设备的列表出现在最终分配中。 该算法考虑了大小为“size”的所有可能gpu集。然而，它并不满足于贪婪的解决方案，即寻找具有最高分数的单个大小集“size”。相反，当将节点上所有可用的gpu划分为大小为“size”的集合，然后将它们各自的分数相加时，它会寻找一种使总分最大化的解决方案。然后它返回该分组中具有最高得分的GPU集。 这种解决方案在一般情况下是必要的，因为各种链接的非层次性会影响每对gpu计算的分数。 // Allocate finds the best set of 'size' GPUs to allocate from a list of // available GPU devices and returns them. The algorithm is designed to // ensure that a list of 'required' GPU devices is present in the final // allocation. // // This algorithm considers all possible sets of GPUs of size 'size'. // However, it does not settle for the greedy solution of looking for the // single set of size 'size' with the highest score. Instead, it looks for a // solution that maximizes the total score when dividing up all available // GPUs on the node into sets of size 'size' and then summing their // individual scores. It then returns the set of GPUs from that grouping // with the highest individual score. // // Such a solution is necessary in the general case because of the // non-hierarchical nature of the various links that influence the score // calculated for each pair of GPUs. func (p *bestEffortPolicy) Allocate(available []*Device, required []*Device, size int) []*Device { if size \u003c= 0 { return []*Device{} } if len(available) \u003c size { return []*Device{} } if len(required) \u003e size { return []*Device{} } // Find the highest scoring GPU partition with sets of of size 'size'. // Don't consider partitions that don't have at least one set that contains // all of the GPUs 'required' by the allocation. // 1. 计算出得分最高的gpu分区（分组），该分区需要满足要分配size大小，并包含全部的'required' // gpuPartition对devices按size等分，e.g. [[0,1],[2,3]]；如果不能等分，则padding处理，填充devices。？？？ bestPartition := [][]*Device(nil) bestScore := 0 iterateGPUPartitions(available, size, func(candidate [][]*Device) { if !gpuPartitionContainsSetWithAll(candidate, required) { return } score := calculateGPUPartitionScore(candidate) if score \u003e bestScore || bestPartition == nil { bestPartition = candidate bestScore = score } }) // Filter the 'bestPartition' to only include sets containing all of the // 'required' devices (which may be nil so all sets will be valid). filteredBestPartition := [][]*Device{} for _, set := range bestPartition { if gpuSetContainsAll(set, required) { filteredBestPartition = append(filteredBestPartition, set) } } if len(filteredBestPartition) == 0 { return []*Device{} } // Find the highest scoring GPU set in the highest scoring GPU partition. // 在得分最高的分区中，找到得分最高的GPUset bestSet := filteredBestPartition[0] bestScore = calculateGPUSetScore(bestSet) for i := 1; i \u003c len(filteredBestPartition); i++ { score := calculateGPUSetScore(filteredBestPartition[i]) if score \u003e bestScore { bestSet = filteredBestPartition[i] bestScore = score } } // Return the highest scoring GPU set. return bestSet } 这里处理了gpuSet中的gpu拓扑得分，累计gpuSet中每对设备的得分PairScore，最后得出总分score // Get the total score of a set of GPUs. The score is calculated as the sum of // the scores calculated for each pair of GPUs in the set. func calculateGPUSetScore(gpuSet []*Device) int { score := 0 iterateGPUSets(gpuSet, 2, func(gpus []*Device) { score += calculateGPUPairScore(gpus[","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:11:3","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"gpu 拓扑 type P2PLinkType uint const ( P2PLinkUnknown P2PLinkType = iota P2PLinkCrossCPU P2PLinkSameCPU P2PLinkHostBridge P2PLinkMultiSwitch P2PLinkSingleSwitch P2PLinkSameBoard SingleNVLINKLink TwoNVLINKLinks ThreeNVLINKLinks FourNVLINKLinks FiveNVLINKLinks SixNVLINKLinks SevenNVLINKLinks EightNVLINKLinks NineNVLINKLinks TenNVLINKLinks ElevenNVLINKLinks TwelveNVLINKLinks ) func (t P2PLinkType) String() string { switch t { case P2PLinkCrossCPU: return \"Cross CPU socket\" case P2PLinkSameCPU: return \"Same CPU socket\" case P2PLinkHostBridge: return \"Host PCI bridge\" case P2PLinkMultiSwitch: return \"Multiple PCI switches\" case P2PLinkSingleSwitch: return \"Single PCI switch\" case P2PLinkSameBoard: return \"Same board\" case SingleNVLINKLink: return \"Single NVLink\" case TwoNVLINKLinks: return \"Two NVLinks\" case ThreeNVLINKLinks: return \"Three NVLinks\" case FourNVLINKLinks: return \"Four NVLinks\" case FiveNVLINKLinks: return \"Five NVLinks\" case SixNVLINKLinks: return \"Six NVLinks\" case SevenNVLINKLinks: return \"Seven NVLinks\" case EightNVLINKLinks: return \"Eight NVLinks\" case NineNVLINKLinks: return \"Nine NVLinks\" case TenNVLINKLinks: return \"Ten NVLinks\" case ElevenNVLINKLinks: return \"Eleven NVLinks\" case TwelveNVLINKLinks: return \"Twelve NVLinks\" case P2PLinkUnknown: } return \"N/A\" } 插件实例创建时NewDevices，会构造device信息，其中包括GPU拓扑连接信息 // Device represents a GPU device as reported by NVML, including all of its // Point-to-Point link information. type Device struct { *nvml.Device Index int Links map[int][]P2PLink } // P2PLink represents a Point-to-Point link between two GPU devices. The link // is between the Device struct this struct is embedded in and the GPU Device // contained in the P2PLink struct itself. type P2PLink struct { GPU *Device Type nvml.P2PLinkType } // DeviceSet is used to hold and manipulate a set of unique GPU devices. type DeviceSet map[string]*Device // Create a list of Devices from all available nvml.Devices. func NewDevices() ([]*Device, error) { devices = append(devices, \u0026Device{device, i, make(map[int][]P2PLink)}) for i, d1 := range devices { for j, d2 := range devices { if d1 != d2 { p2plink, err := nvml.GetP2PLink(d1.Device, d2.Device) if err != nil { return nil, fmt.Errorf(\"error getting P2PLink for devices (%v, %v): %v\", i, j, err) } if p2plink != nvml.P2PLinkUnknown { d1.Links[d2.Index] = append(d1.Links[d2.Index], P2PLink{d2, p2plink}) } nvlink, err := nvml.GetNVLink(d1.Device, d2.Device) if err != nil { return nil, fmt.Errorf(\"error getting NVLink for devices (%v, %v): %v\", i, j, err) } if nvlink != nvml.P2PLinkUnknown { d1.Links[d2.Index] = append(d1.Links[d2.Index], P2PLink{d2, nvlink}) } } } } return devices, nil } ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:11:4","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"总结 kubelet根据所在节点可用资源和numa对齐准则，提供资源分配建议topo hint cpu资源分配，在cpu static分配策略下，由cpumanager根据计算好的topo hint进行cpuset分配 gpu资源分配：则由kubelet和gpu插件共同作用完成 kubelet会计算topo hint，并远程调用gpu插件的GetPreferredAllocation，提供gpu分配建议，包括request、available、size等 gpu插件根据分配建议，在bestEffortPolicy策略下，还会计算gpu device的拓扑得分，然后优选gpuset，并把该gpuset的devices返回给kubelet kbuelet根据gpu插件确认后的gpu devices，再校验处理，调用allocate，通知gpu插件进行资源分配 ","date":"2021-01-05","objectID":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:12:0","tags":["K8S"],"title":"K8S affinity topology feature源码分析","uri":"/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["K8S"],"content":"K8S1.20的kubelet的cpu和topo manager功能测试","date":"2020-12-29","objectID":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/","tags":["K8S"],"title":"K8S基于NUMA亲和性的资源分配特性测试","uri":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/"},{"categories":["K8S"],"content":"1.20版本已经有了kubelet的numa亲和性资源（CPU和GPU）分配功能（与1.18版本的beta接口相同），本文记录操作要点 ","date":"2020-12-29","objectID":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/:0:0","tags":["K8S"],"title":"K8S基于NUMA亲和性的资源分配特性测试","uri":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/"},{"categories":["K8S"],"content":"配置kubelet 添加kubelet中numa相关的运行命令参数 --cpu-manager-policy=static --topology-manager-policy=best-effort kubelet的cpu-manager策略默认是none，会分配系统全部cpuset。这里需要显示指定策略 topology-manager-policy这里根据项目场景需要，配置best-effort：优选分配numa拓扑亲和性的资源，如果numa亲和性不满足，则分配系统可用资源。 cpu-manager策略默认配置 [root@gpu53 ~]# cat /var/lib/kubelet/cpu_manager_state {\"policyName\":\"none\",\"defaultCpuSet\":\"\",\"checksum\":1353318690} cpu-manager策略static配置 [root@node2 kubelet]# cat cpu_manager_state {\"policyName\":\"static\",\"defaultCpuSet\":\"0,4-27\",\"entries\":{\"39b37746-7f5e-4064-b8e1-eebd2bfaa003\":{\"app\":\"1-3\"}},\"checksum\":3300516549} ","date":"2020-12-29","objectID":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/:1:0","tags":["K8S"],"title":"K8S基于NUMA亲和性的资源分配特性测试","uri":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/"},{"categories":["K8S"],"content":"topology-manager-policy 注意  说明 none: this policy will not attempt to do any alignment of resources. It will act the same as if the TopologyManager were not present at all. This is the default policy. best-effort: with this policy, the TopologyManager will attempt to align allocations on NUMA nodes as best it can, but will always allow the pod to start even if some of the allocated resources are not aligned on the same NUMA node. restricted: this policy is the same as the best-effort policy, except it will fail pod admission if allocated resources cannot be aligned properly. Unlike with the single-numa-node policy, some allocations may come from multiple NUMA nodes if it is impossible to ever satisfy the allocation request on a single NUMA node (e.g. 2 devices are requested and the only 2 devices on the system are on different NUMA nodes). single-numa-node: this policy is the most restrictive and will only allow a pod to be admitted if all requested CPUs and devices can be allocated from exactly one NUMA node. ","date":"2020-12-29","objectID":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/:2:0","tags":["K8S"],"title":"K8S基于NUMA亲和性的资源分配特性测试","uri":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/"},{"categories":["K8S"],"content":"kubelet.env配置示例 /etc/kubernetes/kubelet.env 即在原有配置上增加 –cpu-manager-policy=static –topology-manager-policy=best-effort [root@node2 kubelet]# cat /etc/kubernetes/kubelet.env KUBE_LOGTOSTDERR=\"--logtostderr=true\" KUBE_LOG_LEVEL=\"--v=2\" KUBELET_ADDRESS=\"--node-ip=10.151.11.61\" KUBELET_HOSTNAME=\"--hostname-override=node2\" KUBELET_ARGS=\"--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf \\ --config=/etc/kubernetes/kubelet-config.yaml \\ --kubeconfig=/etc/kubernetes/kubelet.conf \\ --pod-infra-container-image=k8s.gcr.io/pause:3.2 \\ --authentication-token-webhook \\ --enforce-node-allocatable=\"\" \\ --client-ca-file=/etc/kubernetes/ssl/ca.crt \\ --rotate-certificates \\ --node-status-update-frequency=10s \\ --cgroup-driver=systemd \\ --cgroups-per-qos=False \\ --max-pods=110 \\ --anonymous-auth=false \\ --read-only-port=0 \\ --fail-swap-on=True \\ --runtime-cgroups=/systemd/system.slice --kubelet-cgroups=/systemd/system.slice \\ --cluster-dns=10.233.0.3 --cluster-domain=cluster.local --resolv-conf=/etc/resolv.conf --node-labels= --eviction-hard=\"\" --image-gc-high-threshold=100 --image-gc-low-threshold=99 --kube-reserved cpu=100m --system-reserved cpu=100m \\ --cpu-manager-policy=static --topology-manager-policy=best-effort \\ \" KUBELET_NETWORK_PLUGIN=\"--network-plugin=cni --cni-conf-dir=/etc/cni/net.d --cni-bin-dir=/opt/cni/bin\" KUBELET_CLOUDPROVIDER=\"\" PATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin ","date":"2020-12-29","objectID":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/:3:0","tags":["K8S"],"title":"K8S基于NUMA亲和性的资源分配特性测试","uri":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/"},{"categories":["K8S"],"content":"kubelet重启 注意：kubelet修改cpu_manager策略配置，一定要停掉kubelet服务，并删除/var/lib/kubelet/cpu_manager_state文件，再重启kubelet，否则会导致kubelet服务重启失败。 ","date":"2020-12-29","objectID":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/:4:0","tags":["K8S"],"title":"K8S基于NUMA亲和性的资源分配特性测试","uri":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/"},{"categories":["K8S"],"content":"启动GPU k8s插件 需要支持CPUManager static policy 这里采用镜像方式启动，详细操作参考K8S GPU DEVICEPLUGIN docker run \\ -it \\ --privileged \\ --network=none \\ -v /var/lib/kubelet/device-plugins:/var/lib/kubelet/device-plugins \\ nvidia/k8s-device-plugin:devel --pass-device-specs ","date":"2020-12-29","objectID":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/:5:0","tags":["K8S"],"title":"K8S基于NUMA亲和性的资源分配特性测试","uri":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/"},{"categories":["K8S"],"content":"kubelet的快照文件 cpu_manager_state：CPU管理器快照文件，包含cpu分配策略和已分配pod的cpuset信息 device-plugins/kubelet_internal_checkpoint：deviceplugin的快照信息，这里关注测试numa亲和性分配相关的TOPO分配信息 ","date":"2020-12-29","objectID":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/:6:0","tags":["K8S"],"title":"K8S基于NUMA亲和性的资源分配特性测试","uri":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/"},{"categories":["K8S"],"content":"GPU命令 ","date":"2020-12-29","objectID":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/:7:0","tags":["K8S"],"title":"K8S基于NUMA亲和性的资源分配特性测试","uri":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/"},{"categories":["K8S"],"content":"GPU uuid nvidia-smi -L 显示如下，查询到INDEX -\u003e UUID： [root@node2 ~]# nvidia-smi -L GPU 0: Tesla P100-PCIE-16GB (UUID: GPU-77a702db-e37f-3a74-d46d-c5713f66058c) GPU 1: Tesla P100-PCIE-16GB (UUID: GPU-9b341c59-f96b-ba85-c137-78c3652fea65) GPU 2: Tesla P100-PCIE-16GB (UUID: GPU-c1e9f249-b37b-81c2-a8d9-ba5ca0294841) ","date":"2020-12-29","objectID":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/:7:1","tags":["K8S"],"title":"K8S基于NUMA亲和性的资源分配特性测试","uri":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/"},{"categories":["K8S"],"content":"GPU 详细信息 lspci | grep -i nvidia [root@node2 ~]# lspci | grep -i nvidia 3b:00.0 3D controller: NVIDIA Corporation GP100GL [Tesla P100 PCIe 16GB] (rev a1) 86:00.0 3D controller: NVIDIA Corporation GP100GL [Tesla P100 PCIe 16GB] (rev a1) d8:00.0 3D controller: NVIDIA Corporation GP100GL [Tesla P100 PCIe 16GB] (rev a1) 前边的序号 “3b:00.0\"是显卡的代号; 查看指定显卡的详细信息用以下指令： lspci -v -s 3b:00.0 这里能看到NUMA node 1 [root@node2 ~]# lspci -v -s d8:00.0 d8:00.0 3D controller: NVIDIA Corporation GP100GL [Tesla P100 PCIe 16GB] (rev a1) Subsystem: NVIDIA Corporation Device 118f Flags: bus master, fast devsel, latency 0, IRQ 441, NUMA node 1 Memory at fa000000 (32-bit, non-prefetchable) [size=16M] Memory at 39f800000000 (64-bit, prefetchable) [size=16G] Memory at 39fc00000000 (64-bit, prefetchable) [size=32M] Capabilities: [60] Power Management version 3 Capabilities: [68] MSI: Enable+ Count=1/1 Maskable- 64bit+ Capabilities: [78] Express Endpoint, MSI 00 Capabilities: [100] Virtual Channel Capabilities: [258] L1 PM Substates Capabilities: [128] Power Budgeting \u003c?\u003e Capabilities: [420] Advanced Error Reporting Capabilities: [600] Vendor Specific Information: ID=0001 Rev=1 Len=024 \u003c?\u003e Capabilities: [900] #19 Kernel driver in use: nvidia Kernel modules: nouveau, nvidia_drm, nvidia ","date":"2020-12-29","objectID":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/:7:2","tags":["K8S"],"title":"K8S基于NUMA亲和性的资源分配特性测试","uri":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/"},{"categories":["K8S"],"content":"GPU拓扑 nvidia-smi topo -mp GPU0属于NUMA组0，GPU1和GPU2属于NUMA组1 [root@node2 numa_test]# nvidia-smi topo -mp GPU0 GPU1 GPU2 CPU Affinity NUMA Affinity GPU0 X SYS SYS 0-13 0 GPU1 SYS X NODE 14-27 1 GPU2 SYS NODE X 14-27 1 Legend: X = Self SYS = Connection traversing PCIe as well as the SMP interconnect between NUMA nodes (e.g., QPI/UPI) NODE = Connection traversing PCIe as well as the interconnect between PCIe Host Bridges within a NUMA node PHB = Connection traversing PCIe as well as a PCIe Host Bridge (typically the CPU) PXB = Connection traversing multiple PCIe bridges (without traversing the PCIe Host Bridge) PIX = Connection traversing at most a single PCIe bridge ","date":"2020-12-29","objectID":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/:7:3","tags":["K8S"],"title":"K8S基于NUMA亲和性的资源分配特性测试","uri":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/"},{"categories":["K8S"],"content":"测试 ","date":"2020-12-29","objectID":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/:8:0","tags":["K8S"],"title":"K8S基于NUMA亲和性的资源分配特性测试","uri":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/"},{"categories":["K8S"],"content":"CPU numa亲和性 资源占用和释放：启动pod[3c]，并删除该pod 占用3个cpu后，再释放： [root@node2 kubelet]# cat cpu_manager_state {\"policyName\":\"static\",\"defaultCpuSet\":\"0,4-27\",\"entries\":{\"39b37746-7f5e-4064-b8e1-eebd2bfaa003\":{\"app\":\"1-3\"}},\"checksum\":3300516549} [root@node2 kubelet]# kubectl delete po cpu-numa-batch-pod pod \"cpu-numa-batch-pod\" deleted [root@node2 kubelet]# cat cpu_manager_state {\"policyName\":\"static\",\"defaultCpuSet\":\"0-27\",\"checksum\":273146150} 环境资源未占用 [root@node2 kubelet]# cat cpu_manager_state {\"policyName\":\"static\",\"defaultCpuSet\":\"0,14-27\",\"entries\":{\"c0c5c4b3-3f63-4677-ba68-52da74012371\":{\"app\":\"1-13\"}},\"checksum\":1954249489} 占用一个numa组的cpu资源，14个cpu [root@node2 kubelet]# cat cpu_manager_state {\"policyName\":\"static\",\"defaultCpuSet\":\"0-13\",\"entries\":{\"6c5f3038-adfc-485d-9943-3fd5e825300d\":{\"app\":\"14-27\"}},\"checksum\":3451722052} 启动2个pod，pod1 占用14c，pod2占用12c [root@node2 kubelet]# cat cpu_manager_state {\"policyName\":\"static\",\"defaultCpuSet\":\"0,13\",\"entries\":{\"55784671-0e4e-49e2-b4d6-c0377ca14c81\":{\"app\":\"1-12\"},\"6c5f3038-adfc-485d-9943-3fd5e825300d\":{\"app\":\"14-27\"}},\"checksum\":3558029577} ","date":"2020-12-29","objectID":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/:8:1","tags":["K8S"],"title":"K8S基于NUMA亲和性的资源分配特性测试","uri":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/"},{"categories":["K8S"],"content":"GPU+CPU numa亲和性 pod请求2个GPU，0个cpu [root@node2 kubelet]# cat cpu_manager_state {\"policyName\":\"static\",\"defaultCpuSet\":\"0-27\",\"checksum\":273146150}[root@node2 kubelet]# [root@node2 kubelet]# [root@node2 kubelet]# cat device-plugins/kubelet_internal_checkpoint {\"Data\":{\"PodDeviceEntries\":[{\"PodUID\":\"9a15d2b5-c152-46b9-96e0-d57032629e1f\",\"ContainerName\":\"app\",\"ResourceName\":\"nvidia.com/gpu\",\"DeviceIDs\":{\"1\":[\"GPU-9b341c59-f96b-ba85-c137-78c3652fea65\",\"GPU-c1e9f249-b37b-81c2-a8d9-ba5ca0294841\"]},\"AllocResp\":\"CmsKFk5WSURJQV9WSVNJQkxFX0RFVklDRVMSUUdQVS1jMWU5ZjI0OS1iMzdiLTgxYzItYThkOS1iYTVjYTAyOTQ4NDEsR1BVLTliMzQxYzU5LWY5NmItYmE4NS1jMTM3LTc4YzM2NTJmZWE2NRokCg4vZGV2L252aWRpYWN0bBIOL2Rldi9udmlkaWFjdGwaAnJ3GiYKDy9kZXYvbnZpZGlhLXV2bRIPL2Rldi9udmlkaWEtdXZtGgJydxoyChUvZGV2L252aWRpYS11dm0tdG9vbHMSFS9kZXYvbnZpZGlhLXV2bS10b29scxoCcncaLgoTL2Rldi9udmlkaWEtbW9kZXNldBITL2Rldi9udmlkaWEtbW9kZXNldBoCcncaIAoML2Rldi9udmlkaWExEgwvZGV2L252aWRpYTEaAnJ3GiAKDC9kZXYvbnZpZGlhMhIML2Rldi9udmlkaWEyGgJydw==\"}],\"RegisteredDevices\":{\"nvidia.com/gpu\":[\"GPU-77a702db-e37f-3a74-d46d-c5713f66058c\",\"GPU-9b341c59-f96b-ba85-c137-78c3652fea65\",\"GPU-c1e9f249-b37b-81c2-a8d9-ba5ca0294841\"]}},\"Checksum\":2530956716}[root@node2 kubelet]# [root@node2 kubelet]# 查看容器信息 docker inspect，已分配GPU资源 \"Devices\": [ { \"PathOnHost\": \"/dev/nvidia1\", \"PathInContainer\": \"/dev/nvidia1\", \"CgroupPermissions\": \"rw\" }, { \"PathOnHost\": \"/dev/nvidia2\", \"PathInContainer\": \"/dev/nvidia2\", \"CgroupPermissions\": \"rw\" } ] 结果：2个GPU都分配到了同1个numa组，cpu资源无指定则使用全部cpuset pod请求1个GPU，3个cpu [root@node2 kubelet]# cat cpu_manager_state {\"policyName\":\"static\",\"defaultCpuSet\":\"0,4-27\",\"entries\":{\"513cb897-0262-4868-826f-aa943ee45a38\":{\"app\":\"1-3\"}},\"checksum\":1982473279}[root@node2 kubelet]# [root@node2 kubelet]# [root@node2 kubelet]# [root@node2 kubelet]# [root@node2 kubelet]# cat device-plugins/kubelet_internal_checkpoint {\"Data\":{\"PodDeviceEntries\":[{\"PodUID\":\"513cb897-0262-4868-826f-aa943ee45a38\",\"ContainerName\":\"app\",\"ResourceName\":\"nvidia.com/gpu\",\"DeviceIDs\":{\"0\":[\"GPU-77a702db-e37f-3a74-d46d-c5713f66058c\"]},\"AllocResp\":\"CkIKFk5WSURJQV9WSVNJQkxFX0RFVklDRVMSKEdQVS03N2E3MDJkYi1lMzdmLTNhNzQtZDQ2ZC1jNTcxM2Y2NjA1OGMaJAoOL2Rldi9udmlkaWFjdGwSDi9kZXYvbnZpZGlhY3RsGgJydxomCg8vZGV2L252aWRpYS11dm0SDy9kZXYvbnZpZGlhLXV2bRoCcncaMgoVL2Rldi9udmlkaWEtdXZtLXRvb2xzEhUvZGV2L252aWRpYS11dm0tdG9vbHMaAnJ3Gi4KEy9kZXYvbnZpZGlhLW1vZGVzZXQSEy9kZXYvbnZpZGlhLW1vZGVzZXQaAnJ3GiAKDC9kZXYvbnZpZGlhMBIML2Rldi9udmlkaWEwGgJydw==\"}],\"RegisteredDevices\":{\"nvidia.com/gpu\":[\"GPU-77a702db-e37f-3a74-d46d-c5713f66058c\",\"GPU-9b341c59-f96b-ba85-c137-78c3652fea65\",\"GPU-c1e9f249-b37b-81c2-a8d9-ba5ca0294841\"]}},\"Checksum\":133412836}[root@node2 kubelet]# 查看容器信息 docker inspect，分配了GPU0 结果：资源充足时，1个GPU，3个cpu都分配到了numa组0，同时满足numa亲和性 pod请求2个GPU，3个cpu [root@node2 kubelet]# cat cpu_manager_state {\"policyName\":\"static\",\"defaultCpuSet\":\"0-13,17-27\",\"entries\":{\"de6df8b8-a6b7-41cc-97a6-19d0fbd44714\":{\"app\":\"14-16\"}},\"checksum\":3366848516}[root@node2 kubelet]# [root@node2 kubelet]# [root@node2 kubelet]# [root@node2 kubelet]# cat device-plugins/kubelet_internal_checkpoint {\"Data\":{\"PodDeviceEntries\":[{\"PodUID\":\"de6df8b8-a6b7-41cc-97a6-19d0fbd44714\",\"ContainerName\":\"app\",\"ResourceName\":\"nvidia.com/gpu\",\"DeviceIDs\":{\"1\":[\"GPU-9b341c59-f96b-ba85-c137-78c3652fea65\",\"GPU-c1e9f249-b37b-81c2-a8d9-ba5ca0294841\"]},\"AllocResp\":\"CmsKFk5WSURJQV9WSVNJQkxFX0RFVklDRVMSUUdQVS05YjM0MWM1OS1mOTZiLWJhODUtYzEzNy03OGMzNjUyZmVhNjUsR1BVLWMxZTlmMjQ5LWIzN2ItODFjMi1hOGQ5LWJhNWNhMDI5NDg0MRokCg4vZGV2L252aWRpYWN0bBIOL2Rldi9udmlkaWFjdGwaAnJ3GiYKDy9kZXYvbnZpZGlhLXV2bRIPL2Rldi9udmlkaWEtdXZtGgJydxoyChUvZGV2L252aWRpYS11dm0tdG9vbHMSFS9kZXYvbnZpZGlhLXV2bS10b29scxoCcncaLgoTL2Rldi9udmlkaWEtbW9kZXNldBITL2Rldi9udmlkaWEtbW9kZXNldBoCcncaIAoML2Rldi9udmlkaWExEgwvZGV2L252aWRpYTEaAnJ3GiAKDC9kZXYvbnZpZGlhMhIML2Rldi9udmlkaWEyGgJydw==\"}],\"RegisteredDevices\":{\"nvidia.com/gpu\":[\"GPU-77a702db-e37f-3a74-d46d-c5713f66058c\",\"GPU-9b341c59-f96b-ba85-c137-78c3652fea65\",\"GPU-c1e9f249-b37b-81c2-a8d9-ba5ca0294841\"]}},\"Checksum\":4219022648}[root@","date":"2020-12-29","objectID":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/:8:2","tags":["K8S"],"title":"K8S基于NUMA亲和性的资源分配特性测试","uri":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/"},{"categories":["K8S"],"content":"numa资源不足场景测试 cpu某num组资源不足 启动2个pod 启动2个pod pod1：请求0个GPU，12个cpu pod2：请求1个GPU，3个cpu pod1分配到了numa组0，且基本上占满numa组0的cpu资源； 这时pod2再分配资源（cpu和GPU）时，根据numa亲和性策略，要分配到numa组1的cpu和GPU资源 [root@node2 kubelet]# cat cpu_manager_state {\"policyName\":\"static\",\"defaultCpuSet\":\"0,13,17-27\",\"entries\":{\"77025d90-6e46-4a87-ad3a-bf0c02c6713c\":{\"app\":\"1-12\"},\"f21fe02b-e6e2-4d04-9a4a-9e57367fa324\":{\"app\":\"14-16\"}},\"checksum\":874856219}[root@node2 kubelet]# [root@node2 kubelet]# [root@node2 kubelet]# [root@node2 kubelet]# [root@node2 kubelet]# cat device-plugins/kubelet_internal_checkpoint {\"Data\":{\"PodDeviceEntries\":[{\"PodUID\":\"f21fe02b-e6e2-4d04-9a4a-9e57367fa324\",\"ContainerName\":\"app\",\"ResourceName\":\"nvidia.com/gpu\",\"DeviceIDs\":{\"1\":[\"GPU-c1e9f249-b37b-81c2-a8d9-ba5ca0294841\"]},\"AllocResp\":\"CkIKFk5WSURJQV9WSVNJQkxFX0RFVklDRVMSKEdQVS1jMWU5ZjI0OS1iMzdiLTgxYzItYThkOS1iYTVjYTAyOTQ4NDEaJAoOL2Rldi9udmlkaWFjdGwSDi9kZXYvbnZpZGlhY3RsGgJydxomCg8vZGV2L252aWRpYS11dm0SDy9kZXYvbnZpZGlhLXV2bRoCcncaMgoVL2Rldi9udmlkaWEtdXZtLXRvb2xzEhUvZGV2L252aWRpYS11dm0tdG9vbHMaAnJ3Gi4KEy9kZXYvbnZpZGlhLW1vZGVzZXQSEy9kZXYvbnZpZGlhLW1vZGVzZXQaAnJ3GiAKDC9kZXYvbnZpZGlhMhIML2Rldi9udmlkaWEyGgJydw==\"}],\"RegisteredDevices\":{\"nvidia.com/gpu\":[\"GPU-77a702db-e37f-3a74-d46d-c5713f66058c\",\"GPU-9b341c59-f96b-ba85-c137-78c3652fea65\",\"GPU-c1e9f249-b37b-81c2-a8d9-ba5ca0294841\"]}},\"Checksum\":2941906560}[root@node2 kubelet]# [root@node2 kubelet]# 启动2个pod 2 启动2个pod pod1：请求1个GPU，3个cpu, 已占numa组1 pod2：请求1个GPU，12个cpu 第2个pod 9388acc6-a396-4f03-a353-ce153da46aaf 的cpu资源 占用了numa组0和1，gpu资源占用了numa组0，如下 [root@node2 kubelet]# cat cpu_manager_state {\"policyName\":\"static\",\"defaultCpuSet\":\"0-13,17-27\",\"entries\":{\"f21fe02b-e6e2-4d04-9a4a-9e57367fa324\":{\"app\":\"14-16\"}},\"checksum\":2485662466}[root@node2 kubelet]# [root@node2 kubelet]# [root@node2 kubelet]# [root@node2 kubelet]# cat cpu_manager_state {\"policyName\":\"static\",\"defaultCpuSet\":\"0,20-27\",\"entries\":{\"9388acc6-a396-4f03-a353-ce153da46aaf\":{\"app\":\"1-13,17-19\"},\"f21fe02b-e6e2-4d04-9a4a-9e57367fa324\":{\"app\":\"14-16\"}},\"checksum\":4055801500}[root@node2 kubelet]# [root@node2 kubelet]# [root@node2 kubelet]# [root@node2 kubelet]# [root@node2 kubelet]# cat device-plugins/kubelet_internal_checkpoint {\"Data\":{\"PodDeviceEntries\":[{\"PodUID\":\"f21fe02b-e6e2-4d04-9a4a-9e57367fa324\",\"ContainerName\":\"app\",\"ResourceName\":\"nvidia.com/gpu\",\"DeviceIDs\":{\"1\":[\"GPU-c1e9f249-b37b-81c2-a8d9-ba5ca0294841\"]},\"AllocResp\":\"CkIKFk5WSURJQV9WSVNJQkxFX0RFVklDRVMSKEdQVS1jMWU5ZjI0OS1iMzdiLTgxYzItYThkOS1iYTVjYTAyOTQ4NDEaJAoOL2Rldi9udmlkaWFjdGwSDi9kZXYvbnZpZGlhY3RsGgJydxomCg8vZGV2L252aWRpYS11dm0SDy9kZXYvbnZpZGlhLXV2bRoCcncaMgoVL2Rldi9udmlkaWEtdXZtLXRvb2xzEhUvZGV2L252aWRpYS11dm0tdG9vbHMaAnJ3Gi4KEy9kZXYvbnZpZGlhLW1vZGVzZXQSEy9kZXYvbnZpZGlhLW1vZGVzZXQaAnJ3GiAKDC9kZXYvbnZpZGlhMhIML2Rldi9udmlkaWEyGgJydw==\"},{\"PodUID\":\"9388acc6-a396-4f03-a353-ce153da46aaf\",\"ContainerName\":\"app\",\"ResourceName\":\"nvidia.com/gpu\",\"DeviceIDs\":{\"0\":[\"GPU-77a702db-e37f-3a74-d46d-c5713f66058c\"]},\"AllocResp\":\"CkIKFk5WSURJQV9WSVNJQkxFX0RFVklDRVMSKEdQVS03N2E3MDJkYi1lMzdmLTNhNzQtZDQ2ZC1jNTcxM2Y2NjA1OGMaJAoOL2Rldi9udmlkaWFjdGwSDi9kZXYvbnZpZGlhY3RsGgJydxomCg8vZGV2L252aWRpYS11dm0SDy9kZXYvbnZpZGlhLXV2bRoCcncaMgoVL2Rldi9udmlkaWEtdXZtLXRvb2xzEhUvZGV2L252aWRpYS11dm0tdG9vbHMaAnJ3Gi4KEy9kZXYvbnZpZGlhLW1vZGVzZXQSEy9kZXYvbnZpZGlhLW1vZGVzZXQaAnJ3GiAKDC9kZXYvbnZpZGlhMBIML2Rldi9udmlkaWEwGgJydw==\"}],\"RegisteredDevices\":{\"nvidia.com/gpu\":[\"GPU-77a702db-e37f-3a74-d46d-c5713f66058c\",\"GPU-9b341c59-f96b-ba85-c137-78c3652fea65\",\"GPU-c1e9f249-b37b-81c2-a8d9-ba5ca0294841\"]}},\"Checksum\":4148283274}[root@node2 kubelet]# [root@node2 kubelet]# [root@node2 kubelet]# 此时的拓扑管理器的策略结果输出如下，虽然有部分cpu和gpu不在同一个numa组，认为cpu和gpu的合并分配结果仍满足numa亲和性 Dec 29 15:13:13 node2 kubelet[117175]: I1229 15:13:13.740680 117175 topology_manager.go:187] [topologymanager] Topology Admit Handler Dec 29 15:13:13 node2 kubelet[117175]: I1229 15:13:13.740755 117175 scope_container.go:80] [topologymanager] TopologyHints for pod '16cpu-numa-batch-pod_default(9388acc6-a396-4f03-a353-ce153da46aaf)', con","date":"2020-12-29","objectID":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/:8:3","tags":["K8S"],"title":"K8S基于NUMA亲和性的资源分配特性测试","uri":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/"},{"categories":["K8S"],"content":"附录 ","date":"2020-12-29","objectID":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/:9:0","tags":["K8S"],"title":"K8S基于NUMA亲和性的资源分配特性测试","uri":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/"},{"categories":["K8S"],"content":"kubelet numa拓扑亲和性资源分配方案： Kubernetes Topology Manager Moves to Beta - Align Up! ","date":"2020-12-29","objectID":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/:9:1","tags":["K8S"],"title":"K8S基于NUMA亲和性的资源分配特性测试","uri":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/"},{"categories":["K8S"],"content":"测试pod 配置 16cpu-2gpu-numa-kubebatch-pod.yaml apiVersion:v1kind:Podmetadata:name:16cpu-2gpu-numa-kubebatch-podlabels:app:myappversion:v1spec:schedulerName:kube-batchcontainers:- name:appimage:docker.io/busybox:latestimagePullPolicy:IfNotPresentcommand:[\"sleep\",\"3600\"]securityContext:privileged:trueresources:limits:cpu:\"16\"memory:\"100Mi\"nvidia.com/gpu:2requests:cpu:\"16\"memory:\"100Mi\"nvidia.com/gpu:2affinity:nodeAffinity:requiredDuringSchedulingIgnoredDuringExecution:# 硬策略nodeSelectorTerms:- matchExpressions:- key:node-role.kubernetes.io/nodeoperator:NotInvalues:- \"true\" ","date":"2020-12-29","objectID":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/:9:2","tags":["K8S"],"title":"K8S基于NUMA亲和性的资源分配特性测试","uri":"/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/"},{"categories":["K8S"],"content":"Centos 7环境下，安装NVIDIA Container和K8S的GPU插件的操作命令","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85nvidia-docker2nvidia-container-v2%E5%92%8Cnvidia-k8s-gpu%E6%8F%92%E4%BB%B6/","tags":["Docker","K8S"],"title":"安装NVIDIA Docker2(NVIDIA Container V2)和NVIDIA K8S-GPU插件","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85nvidia-docker2nvidia-container-v2%E5%92%8Cnvidia-k8s-gpu%E6%8F%92%E4%BB%B6/"},{"categories":["K8S"],"content":"Centos 7环境下，安装NVIDIA Container和K8S的GPU插件的操作命令 Setting up NVIDIA Container Toolkit NVIDIA Docker参考NVIDIA官网教程 NVIDIA Container Toolkit 官方安装说明 NVIDIA k8s-device-plugin 参考项目地址 k8s-device-plugin ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85nvidia-docker2nvidia-container-v2%E5%92%8Cnvidia-k8s-gpu%E6%8F%92%E4%BB%B6/:0:0","tags":["Docker","K8S"],"title":"安装NVIDIA Docker2(NVIDIA Container V2)和NVIDIA K8S-GPU插件","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85nvidia-docker2nvidia-container-v2%E5%92%8Cnvidia-k8s-gpu%E6%8F%92%E4%BB%B6/"},{"categories":["K8S"],"content":"NVIDIA Docker依赖 sudo yum install -y tar bzip2 make automake gcc gcc-c++ vim pciutils elfutils-libelf-devel libglvnd-devel iptables ### Setup the official Docker CE repository: sudo yum-config-manager --add-repo=https://download.docker.com/linux/centos/docker-ce.repo ### Now you can observe the packages available from the docker-ce repo: sudo yum repolist -v #### 生成yum缓存 sudo yum makecache ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85nvidia-docker2nvidia-container-v2%E5%92%8Cnvidia-k8s-gpu%E6%8F%92%E4%BB%B6/:1:0","tags":["Docker","K8S"],"title":"安装NVIDIA Docker2(NVIDIA Container V2)和NVIDIA K8S-GPU插件","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85nvidia-docker2nvidia-container-v2%E5%92%8Cnvidia-k8s-gpu%E6%8F%92%E4%BB%B6/"},{"categories":["K8S"],"content":"NVIDIA Docker2 ### Clear installed old version package # rpm -qa|grep nvidia # yum info installed |grep nvidia sudo yum remove -y nvidia-docker sudo yum remove -y nvidia-docker2 ## 如果原有版本使用rpm方式安装，则清理rpm包 rpm -qa|grep nvidia |grep -E \"libnvidia-container|nvidia-container-runtime\" |xargs rpm -e ### Setup the stable repository and the GPG key: distribution=$(. /etc/os-release;echo $ID$VERSION_ID) \\ \u0026\u0026 curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.repo | sudo tee /etc/yum.repos.d/nvidia-docker.repo sudo yum clean expire-cache ### 生成yum缓存 #sudo yum makecache sudo yum install -y nvidia-docker2 ### Restart the Docker daemon to complete the installation after setting the default runtime: sudo systemctl restart docker ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85nvidia-docker2nvidia-container-v2%E5%92%8Cnvidia-k8s-gpu%E6%8F%92%E4%BB%B6/:2:0","tags":["Docker","K8S"],"title":"安装NVIDIA Docker2(NVIDIA Container V2)和NVIDIA K8S-GPU插件","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85nvidia-docker2nvidia-container-v2%E5%92%8Cnvidia-k8s-gpu%E6%8F%92%E4%BB%B6/"},{"categories":["K8S"],"content":"验证 ### t this point, a working setup can be tested by running a base CUDA container: sudo docker run --rm --gpus all nvidia/cuda:11.0-base nvidia-smi 安装成功，如下结果 +-----------------------------------------------------------------------------+ | NVIDIA-SMI 450.80.02 Driver Version: 450.80.02 CUDA Version: 11.0 | |-------------------------------+----------------------+----------------------+ | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |===============================+======================+======================| | 0 Tesla P100-PCIE... Off | 00000000:3B:00.0 Off | Off | | N/A 37C P0 33W / 250W | 0MiB / 16280MiB | 0% Default | | | | N/A | +-------------------------------+----------------------+----------------------+ | 1 Tesla P100-PCIE... Off | 00000000:86:00.0 Off | Off | | N/A 37C P0 32W / 250W | 0MiB / 16280MiB | 0% Default | | | | N/A | +-------------------------------+----------------------+----------------------+ | 2 Tesla P100-PCIE... Off | 00000000:D8:00.0 Off | Off | | N/A 36C P0 27W / 250W | 0MiB / 16280MiB | 4% Default | | | | N/A | +-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=============================================================================| | No running processes found | +-----------------------------------------------------------------------------+ ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85nvidia-docker2nvidia-container-v2%E5%92%8Cnvidia-k8s-gpu%E6%8F%92%E4%BB%B6/:3:0","tags":["Docker","K8S"],"title":"安装NVIDIA Docker2(NVIDIA Container V2)和NVIDIA K8S-GPU插件","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85nvidia-docker2nvidia-container-v2%E5%92%8Cnvidia-k8s-gpu%E6%8F%92%E4%BB%B6/"},{"categories":["K8S"],"content":"NVIDIA K8S Device plugin 这里使用镜像方式，更多方式，参考k8s-device-plugin ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85nvidia-docker2nvidia-container-v2%E5%92%8Cnvidia-k8s-gpu%E6%8F%92%E4%BB%B6/:4:0","tags":["Docker","K8S"],"title":"安装NVIDIA Docker2(NVIDIA Container V2)和NVIDIA K8S-GPU插件","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85nvidia-docker2nvidia-container-v2%E5%92%8Cnvidia-k8s-gpu%E6%8F%92%E4%BB%B6/"},{"categories":["K8S"],"content":"拉取镜像 docker pull nvidia/k8s-device-plugin:v0.7.3 docker tag nvidia/k8s-device-plugin:v0.7.3 nvidia/k8s-device-plugin:devel ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85nvidia-docker2nvidia-container-v2%E5%92%8Cnvidia-k8s-gpu%E6%8F%92%E4%BB%B6/:4:1","tags":["Docker","K8S"],"title":"安装NVIDIA Docker2(NVIDIA Container V2)和NVIDIA K8S-GPU插件","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85nvidia-docker2nvidia-container-v2%E5%92%8Cnvidia-k8s-gpu%E6%8F%92%E4%BB%B6/"},{"categories":["K8S"],"content":"运行镜像 以下方式2选1： Without compatibility for the CPUManager static policy: docker run \\ -it \\ --security-opt=no-new-privileges \\ --cap-drop=ALL \\ --network=none \\ -v /var/lib/kubelet/device-plugins:/var/lib/kubelet/device-plugins \\ nvidia/k8s-device-plugin:devel With compatibility for the CPUManager static policy: docker run \\ -it \\ --privileged \\ --network=none \\ -v /var/lib/kubelet/device-plugins:/var/lib/kubelet/device-plugins \\ nvidia/k8s-device-plugin:devel --pass-device-specs ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85nvidia-docker2nvidia-container-v2%E5%92%8Cnvidia-k8s-gpu%E6%8F%92%E4%BB%B6/:4:2","tags":["Docker","K8S"],"title":"安装NVIDIA Docker2(NVIDIA Container V2)和NVIDIA K8S-GPU插件","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85nvidia-docker2nvidia-container-v2%E5%92%8Cnvidia-k8s-gpu%E6%8F%92%E4%BB%B6/"},{"categories":["K8S"],"content":"附录 手动安装nvidia-docker(在有外网机器上面进行)， 未测试验证，仅供参考 distribution=$(. /etc/os-release;echo $ID$VERSION_ID) curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.repo | sudo tee /etc/yum.repos.d/nvidia-docker.repo yum install --downloadonly nvidia-docker2 --downloaddir=/tmp/nvidia ##在拷贝到没有网路的服务器上面执行以下命令 rpm -ivh libnvidia-container1-1.1.1-1.x86_64.rpm libnvidia-container-tools-1.1.1-1.x86_64.rpm rpm -ivh nvidia-container-runtime-3.2.0-1.x86_64.rpm nvidia-container-toolkit-1.1.2-2.x86_64.rpm ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85nvidia-docker2nvidia-container-v2%E5%92%8Cnvidia-k8s-gpu%E6%8F%92%E4%BB%B6/:5:0","tags":["Docker","K8S"],"title":"安装NVIDIA Docker2(NVIDIA Container V2)和NVIDIA K8S-GPU插件","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85nvidia-docker2nvidia-container-v2%E5%92%8Cnvidia-k8s-gpu%E6%8F%92%E4%BB%B6/"},{"categories":["K8S"],"content":"国内环境安装部署k8s","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"上周末k8s刚刚发布了1.20.1版本，抢鲜安装体验下。 由于网络原因，访问谷歌外网不是很方便，所以本文采用国内可访问的资源进行安装，资源包括：k8s二进制文件和镜像文件 安装方式采用kubespray，项目地址 ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:0:0","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"k8s版本包 k8s社区版本发布地址如下 https://storage.googleapis.com/kubernetes-release/release/ 分别有server、node、client三种版本包二进制文件。下载方式如下： wget https://storage.googleapis.com/kubernetes-release/release/v1.20.1/kubernetes-server-linux-amd64.tar.gz wget https://storage.googleapis.com/kubernetes-release/release/v1.20.1/kubernetes-node-linux-amd64.tar.gz wget https://storage.googleapis.com/kubernetes-release/release/v1.20.1/kubernetes-client-linux-amd64.tar.gz 上面这些地址无法直接访问。可以改由下面方式下载： 通过 CHANGELOG-1.20里面的指定的位置，下载指定版本 如1.12.1 实际上，对于安装部署，只要node中的版本包即可。 wget https://storage.googleapis.com/kubernetes-release/release/v1.20.1/kubernetes-node-linux-amd64.tar.gz ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:1:0","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"kubespray 说明 安装脚本采用kubespray，本文使用了目前最新的release版本1.14.2 kubespray-1.14.2 只支持到了k8s1.19，所以后面我们需要修改kubespray。 首先看下kubespray关于离线安装的事项说明 如果采用离线方式安装 Configure Inventory Once all artifacts are accessible from your internal network, adjust the following variables in your inventory to match your environment: # Registry overrides gcr_image_repo: \"{{ registry_host }}\" docker_image_repo: \"{{ registry_host }}\" quay_image_repo: \"{{ registry_host }}\" kubeadm_download_url: \"{{ files_repo }}/kubernetes/{{ kube_version }}/kubeadm\" kubectl_download_url: \"{{ files_repo }}/kubernetes/{{ kube_version }}/kubectl\" kubelet_download_url: \"{{ files_repo }}/kubernetes/{{ kube_version }}/kubelet\" # etcd is optional if you **DON'T** use etcd_deployment=host etcd_download_url: \"{{ files_repo }}/kubernetes/etcd/etcd-{{ etcd_version }}-linux-amd64.tar.gz\" cni_download_url: \"{{ files_repo }}/kubernetes/cni/cni-plugins-linux-{{ image_arch }}-{{ cni_version }}.tgz\" crictl_download_url: \"{{ files_repo }}/kubernetes/cri-tools/crictl-{{ crictl_version }}-{{ ansible_system | lower }}-{{ image_arch }}.tar.gz\" # If using Calico calicoctl_download_url: \"{{ files_repo }}/kubernetes/calico/{{ calico_ctl_version }}/calicoctl-linux-{{ image_arch }}\" # CentOS/Redhat ## Docker docker_rh_repo_base_url: \"{{ yum_repo }}/docker-ce/$releasever/$basearch\" docker_rh_repo_gpgkey: \"{{ yum_repo }}/docker-ce/gpg\" ## Containerd extras_rh_repo_base_url: \"{{ yum_repo }}/centos/$releasever/extras/$basearch\" extras_rh_repo_gpgkey: \"{{ yum_repo }}/containerd/gpg\" # Fedora ## Docker docker_fedora_repo_base_url: \"{{ yum_repo }}/docker-ce/{{ ansible_distribution_major_version }}/{{ ansible_architecture }}\" docker_fedora_repo_gpgkey: \"{{ yum_repo }}/docker-ce/gpg\" ## Containerd containerd_fedora_repo_base_url: \"{{ yum_repo }}/containerd\" containerd_fedora_repo_gpgkey: \"{{ yum_repo }}/docker-ce/gpg\" # Debian ## Docker docker_debian_repo_base_url: \"{{ debian_repo }}/docker-ce\" docker_debian_repo_gpgkey: \"{{ debian_repo }}/docker-ce/gpg\" ## Containerd containerd_debian_repo_base_url: \"{{ ubuntu_repo }}/containerd\" containerd_debian_repo_gpgkey: \"{{ ubuntu_repo }}/containerd/gpg\" containerd_debian_repo_repokey: 'YOURREPOKEY' # Ubuntu ## Docker docker_ubuntu_repo_base_url: \"{{ ubuntu_repo }}/docker-ce\" docker_ubuntu_repo_gpgkey: \"{{ ubuntu_repo }}/docker-ce/gpg\" ## Containerd containerd_ubuntu_repo_base_url: \"{{ ubuntu_repo }}/containerd\" containerd_ubuntu_repo_gpgkey: \"{{ ubuntu_repo }}/containerd/gpg\" containerd_ubuntu_repo_repokey: 'YOURREPOKEY' # If using helm helm_stable_repo_url: \"{{ helm_registry }}\" 一些k8s组件程序文件，如 kubelet 保存路径如下: {{ local_release_dir }}/kubelet-{{ kube_version }}-{{ image_arch }} ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:2:0","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"kubespray 安装 安装python3环境 参考脚本部署Python3 安装 ansible pip3 install -r requirements.txt # 或者 # 临时指定python的pip源，进行安装 pip3 install -i https://pypi.douban.com/simple -r requirements.txt 自定义部署配置文件 # Copy ``inventory/sample`` as ``inventory/mycluster`` # cp -rfp inventory/sample inventory/mycluster cp -rfp inventory/sample inventory/deploy_cluster 接着对deploy_cluster和源码脚本进行可修改，详见下文 执行kubespray安装或卸载 # 这里我修改了自定义部署配置目录为 deploy_cluster， 并修改其中的配置参数 ansible-playbook -i inventory/deploy_cluster/inventory.ini --become --become-user=root cluster.yml -vvv # 卸载命令 ansible-playbook -i inventory/deploy_cluster/inventory.ini --become --become-user=root reset.yml -vvv ## 清理程序和文件目录 rm -rf /etc/kubernetes rm -rf /var/lib/kubelet rm -rf /etc/ssl/etcd 卸载时 并没有清理/tmp/release，另外reset后再执行安装，会发现/usr/local/bin/下没有kubeadm，需要从安装目录把kubeadm拷贝过去 ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:3:0","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"示例 aist_cluster环境安装和卸载 ansible版本 确认使用ansible2.9.6 安装命令 /usr/local/python3/bin/ansible-playbook -i inventory/aist_cluster/inventory.ini --become --become-user=root cluster.yml -vvvvv 卸载命令 /usr/local/python3/bin/ansible-playbook -i inventory/aist_cluster/inventory.ini --become --become-user=root reset.yml -vvvvv ## 清理程序和文件目录 rm -rf /etc/kubernetes rm -rf /var/lib/kubelet rm -rf /etc/ssl/etcd ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:3:1","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"kubespray 修改 ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:4:0","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"脚本修改 修改点说明 ### 下载校验关闭 由于安装的是新版本1.20.原有kubespray并不支持，所以需要把其对二进制文件的下载校验关闭 把手动替换的几个程序文件的校验操作关闭 # kubeadm # sha256: \"{{ kubeadm_binary_checksum }}\" # sha256: \"{{ kubelet_binary_checksum }}\" # sha256: \"{{ kubectl_binary_checksum }}\" ### 修改下载地址包括二进制文件和镜像 ### 已有下载文件的下载关闭 把 download tasks/main.yaml download | Get kubeadm binary and list of required images 注释掉 kubespray-2.14.2\\roles\\download\\defaults\\main.yaml ---local_release_dir:/tmp/releasesdownload_cache_dir:/tmp/kubespray_cache# do not delete remote cache files after using them# NOTE: Setting this parameter to TRUE is only really useful when developing kubespraydownload_keep_remote_cache:false# Only useful when download_run_once is false: Localy cached files and images are# uploaded to kubernetes nodes. Also, images downloaded on those nodes are copied# back to the ansible runner's cache, if they are not yet preset.download_force_cache:false# Used to only evaluate vars from download roleskip_downloads:false# Optionally skip kubeadm images download#skip_kubeadm_images: falseskip_kubeadm_images:truekubeadm_images:{}# if this is set to true will only download files once. Doesn't work# on Flatcar Container Linux by Kinvolk unless the download_localhost is true and localhost# is running another OS type. Default compress level is 1 (fastest).download_run_once:falsedownload_compress:1# if this is set to true will download containerdownload_container:true# if this is set to true, uses the localhost for download_run_once mode# (requires docker and sudo to access docker). You may want this option for# local caching of docker images or for Flatcar Container Linux by Kinvolk cluster nodes.# Otherwise, uses the first node in the kube-master group to store images# in the download_run_once mode.download_localhost:false# Always pull images if set to True. Otherwise check by the repo's tag/digest.download_always_pull:false# Some problems may occur when downloading files over https proxy due to ansible bug# https://github.com/ansible/ansible/issues/32750. Set this variable to False to disable# SSL validation of get_url module. Note that kubespray will still be performing checksum validation.download_validate_certs:true# Use the first kube-master if download_localhost is not setdownload_delegate:\"{% if download_localhost %}localhost{% else %}{{ groups['kube-master'][0] }}{% endif %}\"# Arch of Docker images and needed packagesimage_arch:\"{{host_architecture | default('amd64')}}\"# Versions# add by wangb#kube_version: v1.18.10kube_version:v1.20.1kubeadm_version:\"{{ kube_version }}\"# add by wangb#etcd_version: v3.4.3etcd_version:v3.4.13# gcr and kubernetes image repo definegcr_image_repo:\"gcr.io\"kube_image_repo:\"k8s.gcr.io\"# docker image repo definedocker_image_repo:\"docker.io\"# quay image repo definequay_image_repo:\"quay.io\"# TODO(mattymo): Move calico versions to roles/network_plugins/calico/defaults# after migration to container downloadcalico_version:\"v3.15.2\"calico_ctl_version:\"{{ calico_version }}\"calico_cni_version:\"{{ calico_version }}\"calico_policy_version:\"{{ calico_version }}\"calico_typha_version:\"{{ calico_version }}\"typha_enabled:falseflannel_version:\"v0.12.0\"cni_version:\"v0.8.7\"weave_version:2.7.0pod_infra_version:\"3.2\"contiv_version:1.2.1cilium_version:\"v1.8.3\"kube_ovn_version:\"v1.3.0\"kube_router_version:\"v1.0.1\"multus_version:\"v3.6\"ovn4nfv_ovn_image_version:\"v1.0.0\"ovn4nfv_k8s_plugin_image_version:\"v1.1.0\"# Get kubernetes major version (i.e. 1.17.4 =\u003e 1.17)kube_major_version:\"{{ kube_version | regex_replace('^v([0-9])+\\\\.([0-9]+)\\\\.[0-9]+', 'v\\\\1.\\\\2') }}\"crictl_supported_versions:# add by wangbv1.20:\"v1.20.1\"v1.19:\"v1.19.0\"v1.18:\"v1.18.0\"v1.17:\"v1.17.0\"crictl_version:\"{{ crictl_supported_versions[kube_major_version] }}\"# Download URLs#kubelet_download_url: \"https://storage.googleapis.com/kubernetes-release/release/{{ kube_version }}/bin/linux/{{ image_arch }}/kubelet\"#kubectl_download_url: \"https://storage.googleapis.com/kubernetes-release/release/{{ kube_version }}/bin/linux/{{ image_a","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:4:1","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"文件服务file server 自定义文件服务file server，为kubespray提供下载文件 [root@node2 file_server]# ll tmp/kubernetes/v1.20.1/ total 306004 -rw-r--r-- 1 root root 40783872 Dec 21 17:41 calicoctl-linux-amd64 -rw-r--r-- 1 root root 39641346 Dec 21 17:41 cni-plugins-linux-amd64-v0.8.7.tgz -rw-r--r-- 1 root root 39219200 Dec 18 20:21 kubeadm -rw-r--r-- 1 root root 40230912 Dec 18 20:21 kubectl -rw-r--r-- 1 root root 113982312 Dec 18 20:21 kubelet -rw-r--r-- 1 root root 39485440 Dec 18 20:21 kube-proxy kubespray会把其中的文件下载到暂存目录/tmp/release下 ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:4:2","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"下载缓存目录/tmp/release [root@node2 deploy-kube-batch]# ll /tmp/releases/ total 267444 -rwxr-xr-x 1 root root 40783872 Dec 22 17:14 calicoctl -rwxr-xr-x 1 root root 39641346 Dec 22 17:14 cni-plugins-linux-amd64-v0.8.7.tgz ###drwxr-xr-x 2 root root 6 Dec 22 17:14 images -rwxr-xr-x 1 root root 39219200 Dec 22 17:14 kubeadm-v1.20.1-amd64 -rwxr-xr-x 1 root root 40230912 Dec 22 17:14 kubectl-v1.20.1-amd64 -rwxr-xr-x 1 root root 113982312 Dec 22 17:14 kubelet-v1.20.1-amd64 ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:4:3","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"命令目录文件 可以把下载后的文件 kubeadm kubectl kubelet 放置到/usr/local/bin目录下。 安装完成后的命令目录文件如下（其它文件是有kubspray下载完成的）： [root@node131 releases]# ll /usr/local/bin 总用量 206112 -rwxr-x---. 1 root root 351 12月 21 14:52 etcd -rwxr-xr-x. 1 root root 17620576 8月 25 03:22 etcdctl drwx------. 2 root root 30 12月 21 14:50 etcd-scripts -rwxr-x---. 1 root root 39219200 12月 21 15:18 kubeadm -rwxr-x---. 1 root root 40230912 12月 21 15:18 kubectl -rwxr-xr-x. 1 root root 113982312 12月 21 15:10 kubelet drwxr-xr-x. 2 kube root 6 12月 21 13:49 kubernetes-scripts 二进制文件下载 安装过程中，某些二进制文件会下载很慢或者失败，则手动下载完成后 https://github.com/containernetworking/plugins/releases/download/v0.8.7/cni-plugins-linux-amd64-v0.8.7.tgz 再把 下载 cni 部分注释掉 cni，如下： # cni:# enabled: true# file: true# version: \"{{ cni_version }}\"# dest: \"{{local_release_dir}}/cni-plugins-linux-{{ image_arch }}-{{ cni_version }}.tgz\"## sha256: \"{{ cni_binary_checksum }}\"# url: \"{{ cni_download_url }}\"# unarchive: false# owner: \"root\"# mode: \"0755\"# groups:# - k8s-cluster calicoctl下载地址 https://github.com/projectcalico/calicoctl/releases/download/v3.15.2/calicoctl-linux-amd64 ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:4:4","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"k8s镜像下载 编辑下载脚本 需要按部署k8s版本修改版本参数 download_k8s_images.sh #!/bin/bash # 关闭防火墙 # setenforce 0 # systemctl stop firewalld.service # use cmd to list images # ./kubeadm config images list --kubernetes-version=v1.20.1 # origin images # k8s.gcr.io/kube-apiserver:v1.20.1 # k8s.gcr.io/kube-controller-manager:v1.20.1 # k8s.gcr.io/kube-scheduler:v1.20.1 # k8s.gcr.io/kube-proxy:v1.20.1 # k8s.gcr.io/pause:3.2 # k8s.gcr.io/etcd:3.4.13-0 # k8s.gcr.io/coredns:1.7.0 echo \"START downloading k8s.gcr.io/images...\" images=( kube-apiserver:v1.20.1 kube-controller-manager:v1.20.1 kube-scheduler:v1.20.1 kube-proxy:v1.20.1 pause:3.2 # etcd:3.4.13-0 # etcd:3.4.3 coredns:1.7.0 # requests for kubespray k8s-dns-node-cache:1.15.13 # cluster-proportional-autoscaler-amd64:1.8.1 kube-registry-proxy:0.4 #metrics-server/metrics-server:v0.3.7 # metrics v0.3.7 找不到，改用v0.3.6 # metrics-server-amd64:v0.3.6 # ingress-nginx/controller:v0.35.0 addon-resizer:1.8.11 ) for imageName in ${images[@]} ; do docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/${imageName} docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/${imageName} k8s.gcr.io/${imageName} docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/${imageName} done # custom docker pull docker pull registry.cn-hangzhou.aliyuncs.com/ringtail/cluster-proportional-autoscaler-amd64:v1.3.0 docker tag registry.cn-hangzhou.aliyuncs.com/ringtail/cluster-proportional-autoscaler-amd64:v1.3.0 k8s.gcr.io/cluster-proportional-autoscaler-amd64:v1.3.0 docker rmi registry.cn-hangzhou.aliyuncs.com/ringtail/cluster-proportional-autoscaler-amd64:v1.3.0 docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/metrics-server-amd64:v0.3.6 docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/metrics-server-amd64:v0.3.6 k8s.gcr.io/metrics-server-amd64:v0.3.6 docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/metrics-server-amd64:v0.3.6 docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/nginx-ingress-controller:0.25.1 docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/nginx-ingress-controller:0.25.1 k8s.gcr.io/nginx-ingress-controller:0.25.1 docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/nginx-ingress-controller:0.25.1 # [root@node131 ~]# docker images # REPOSITORY TAG IMAGE ID CREATED SIZE # registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy v1.20.1 e3f6fcd87756 2 days ago 118MB # registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver v1.20.1 75c7f7112080 2 days ago 122MB # registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager v1.20.1 2893d78e47dc 2 days ago 116MB # registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler v1.20.1 4aa0b4397bbb 2 days ago 46.4MB # registry.cn-hangzhou.aliyuncs.com/google_containers/coredns 1.7.0 bfe3a36ebd25 6 months ago 45.2MB # registry.cn-hangzhou.aliyuncs.com/google_containers/pause 3.2 80d28bedfe5d 10 months ago 683kB # [root@node131 ~]# docker images # REPOSITORY TAG IMAGE ID CREATED SIZE # k8s.gcr.io/kube-proxy v1.20.1 e3f6fcd87756 2 days ago 118MB # k8s.gcr.io/kube-controller-manager v1.20.1 2893d78e47dc 2 days ago 116MB # k8s.gcr.io/kube-apiserver v1.20.1 75c7f7112080 2 days ago 122MB # k8s.gcr.io/kube-scheduler v1.20.1 4aa0b4397bbb 2 days ago 46.4MB # k8s.gcr.io/coredns 1.7.0 bfe3a36ebd25 6 months ago 45.2MB # k8s.gcr.io/pause 3.2 80d28bedfe5d 10 months ago 683kB echo \"END downloading k8s.gcr.io/images...\" echo \"\" echo \"\" echo \"\" echo \"START downloading quay.io/images...\" # docker pull quay-mirror.qiniu.com/coreos/flannel # docker pull quay.io/coreos/etcd:v3.4.13 echo \"END downloading quay.io/images...\" 执行脚本 bash download_k8s_images.sh ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:4:5","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"非下载方式说明 如果没有file server服务。 需要把手动把命令目录文件拷贝到/usr/local/bin kubectl kubeadm kubelet 同时把其它下载文件如网络插件cni等下载包，放到/tmp/release目录下 ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:5:0","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"k8s相关镜像 REPOSITORY TAG IMAGE ID CREATED SIZE k8s.gcr.io/kube-proxy v1.20.1 e3f6fcd87756 4 days ago 118MB k8s.gcr.io/kube-controller-manager v1.20.1 2893d78e47dc 4 days ago 116MB k8s.gcr.io/kube-apiserver v1.20.1 75c7f7112080 4 days ago 122MB k8s.gcr.io/kube-scheduler v1.20.1 4aa0b4397bbb 4 days ago 46.4MB nginx 1.19 ae2feff98a0c 7 days ago 133MB calico/node latest 048e0ac26968 4 weeks ago 165MB kubernetesui/dashboard-amd64 v2.0.4 46d0a29c3f61 3 months ago 225MB calico/node v3.15.2 cc7508d4d2d4 4 months ago 262MB calico/cni v3.15.2 5dadc388f979 4 months ago 110MB calico/kube-controllers v3.15.2 fbbc4a1a0e98 4 months ago 52.9MB quay.io/coreos/etcd v3.4.13 d1985d404385 4 months ago 83.8MB k8s.gcr.io/addon-resizer 1.8.11 b7db21b30ad9 5 months ago 32.8MB coredns/coredns 1.7.0 bfe3a36ebd25 6 months ago 45.2MB k8s.gcr.io/coredns 1.7.0 bfe3a36ebd25 6 months ago 45.2MB kubernetesui/metrics-scraper v1.0.5 2cd72547f23f 6 months ago 36.7MB k8s.gcr.io/k8s-dns-node-cache 1.15.13 3f7a09f7cade 7 months ago 107MB k8s.gcr.io/pause 3.2 80d28bedfe5d 10 months ago 683kB k8s.gcr.io/metrics-server-amd64 v0.3.6 9dd718864ce6 14 months ago 39.9MB k8s.gcr.io/nginx-ingress-controller 0.25.1 0439eb3e11f1 16 months ago 511MB k8s.gcr.io/cluster-proportional-autoscaler-amd64 v1.3.0 33813c948942 2 years ago 45.8MB k8s.gcr.io/kube-registry-proxy 0.4 60dc18151daf 3 years ago 188MB k8s核心组件版本：1.20.1 etcd版本：3.4.13 ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:6:0","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"k8s组件适配 ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:7:0","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"kube-batch [root@node2 kube-batch]# ./deploy.sh configmap/kube-batch created Warning: rbac.authorization.k8s.io/v1beta1 ClusterRoleBinding is deprecated in v1.17+, unavailable in v1.22+; use rbac.authorization.k8s.io/v1 ClusterRoleBinding clusterrolebinding.rbac.authorization.k8s.io/default-sa-admin created deployment.apps/kube-batch created Warning: apiextensions.k8s.io/v1beta1 CustomResourceDefinition is deprecated in v1.16+, unavailable in v1.22+; use apiextensions.k8s.io/v1 CustomResourceDefinition customresourcedefinition.apiextensions.k8s.io/podgroups.scheduling.incubator.k8s.io created Warning: apiextensions.k8s.io/v1beta1 CustomResourceDefinition is deprecated in v1.16+, unavailable in v1.22+; use apiextensions.k8s.io/v1 CustomResourceDefinition customresourcedefinition.apiextensions.k8s.io/queues.scheduling.incubator.k8s.io created Warning: apiextensions.k8s.io/v1beta1 CustomResourceDefinition is deprecated in v1.16+, unavailable in v1.22+; use apiextensions.k8s.io/v1 CustomResourceDefinition customresourcedefinition.apiextensions.k8s.io/podgroups.scheduling.sigs.dev created Warning: apiextensions.k8s.io/v1beta1 CustomResourceDefinition is deprecated in v1.16+, unavailable in v1.22+; use apiextensions.k8s.io/v1 CustomResourceDefinition customresourcedefinition.apiextensions.k8s.io/queues.scheduling.sigs.dev created service/kube-batch-prometheus-discovery created queue.scheduling.incubator.k8s.io/default created queue.scheduling.incubator.k8s.io/emergency-queue created queue.scheduling.incubator.k8s.io/00000000000000000000000000000000 created apiextensions.k8s.io/v1beta1 需要转换为 apiextensions.k8s.io/v1 ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:7:1","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"安装完成状态 [root@node2 inventory]# kubectl get po -A -owide NAMESPACE NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES default myapp-batch-pod 1/1 Running 3 3h11m 10.233.96.8 node2 \u003cnone\u003e \u003cnone\u003e default myapp-pod 1/1 Running 17 3h53m 10.233.95.9 gpu53 \u003cnone\u003e \u003cnone\u003e kube-system calico-kube-controllers-67f55f8858-xxnrs 1/1 Running 3 18h 10.151.11.53 gpu53 \u003cnone\u003e \u003cnone\u003e kube-system calico-node-5ww7v 1/1 Running 1 17h 10.151.11.61 node2 \u003cnone\u003e \u003cnone\u003e kube-system calico-node-9fkz2 1/1 Running 2 17h 10.151.11.53 gpu53 \u003cnone\u003e \u003cnone\u003e kube-system coredns-8677555d68-bjkl2 1/1 Running 2 18h 10.233.96.5 node2 \u003cnone\u003e \u003cnone\u003e kube-system dns-autoscaler-5fb74f6dd4-wj62q 0/1 Running 2 18h 10.233.96.6 node2 \u003cnone\u003e \u003cnone\u003e kube-system kube-apiserver-node2 1/1 Running 2 18h 10.151.11.61 node2 \u003cnone\u003e \u003cnone\u003e kube-system kube-batch-56858cf46f-tmnsb 1/1 Running 0 3h25m 10.233.96.7 node2 \u003cnone\u003e \u003cnone\u003e kube-system kube-controller-manager-node2 1/1 Running 2 18h 10.151.11.61 node2 \u003cnone\u003e \u003cnone\u003e kube-system kube-proxy-77tw9 1/1 Running 2 18h 10.151.11.61 node2 \u003cnone\u003e \u003cnone\u003e kube-system kube-proxy-8vsdb 1/1 Running 3 18h 10.151.11.53 gpu53 \u003cnone\u003e \u003cnone\u003e kube-system kube-scheduler-node2 1/1 Running 2 18h 10.151.11.61 node2 \u003cnone\u003e \u003cnone\u003e kube-system kubernetes-dashboard-dfb67d98c-b8n5j 1/1 Running 4 18h 10.233.95.7 gpu53 \u003cnone\u003e \u003cnone\u003e kube-system kubernetes-metrics-scraper-54df648466-4jcc2 1/1 Running 3 18h 10.233.95.8 gpu53 \u003cnone\u003e \u003cnone\u003e kube-system nginx-proxy-gpu53 1/1 Running 3 18h 10.151.11.53 gpu53 \u003cnone\u003e \u003cnone\u003e kube-system nodelocaldns-m26kx 1/1 Running 2 18h 10.151.11.61 node2 \u003cnone\u003e \u003cnone\u003e kube-system nodelocaldns-qm62v 1/1 Running 3 18h 10.151.11.53 gpu53 \u003cnone\u003e \u003cnone\u003e [root@node2 inventory]# [root@node2 inventory]# [root@node2 inventory]# [root@node2 inventory]# kubectl get no -owide NAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIME gpu53 Ready \u003cnone\u003e 18h v1.20.1 10.151.11.53 \u003cnone\u003e CentOS Linux 7 (Core) 3.10.0-862.el7.x86_64 docker://19.3.12 node2 Ready control-plane,master 18h v1.20.1 10.151.11.61 \u003cnone\u003e CentOS Linux 7 (Core) 3.10.0-862.el7.x86_64 docker://19.3.12 说明：dns-autoscaler没有起来，是因为其版本过低。与集群k8s版本不匹配导致，其不影响k8s组件测试 ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:8:0","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"问题 ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:9:0","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"coredns等报错：connect: no route to host 现象： dial tcp 10.233.0.1:443: connect: no route to host 执行下面命令解决 systemctl stop kubelet systemctl stop docker iptables --flush iptables -tnat --flush systemctl start docker systemctl start kubelet The route problem can be solved by flush iptables. 类似网络路由问题，都可以使用上面命令解决 ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:9:1","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"coredns pod 没有起来 HTTP probe failed with statuscode: 503 2月 02 10:09:19 node131 kubelet[36705]: I0202 10:09:19.484131 36705 prober.go:117] Readiness probe for \"coredns-8677555d68-tjw4l_kube-system(863c8ab1-0f68-437e-a8fc-735cc65a5ba6):coredns\" failed (failure): HTTP probe failed with statuscode: 503 2月 02 10:09:24 node131 kubelet[36705]: I0202 10:09:24.626538 36705 setters.go:86] Using node IP: \"192.168.182.131\" 2月 02 10:09:29 node131 kubelet[36705]: I0202 10:09:29.484193 36705 prober.go:117] Readiness probe for \"coredns-8677555d68-tjw4l_kube-system(863c8ab1-0f68-437e-a8fc-735cc65a5ba6):coredns\" failed (failure): HTTP probe failed with statuscode: 503 2月 02 10:09:34 node131 kubelet[36705]: I0202 10:09:34.691889 36705 setters.go:86] Using node IP: \"192.168.182.131\" 2月 02 10:09:39 node131 kubelet[36705]: I0202 10:09:39.484596 36705 prober.go:117] Readiness probe for \"coredns-8677555d68-tjw4l_kube-system(863c8ab1-0f68-437e-a8fc-735cc65a5ba6):coredns\" failed (failure): HTTP probe failed with statuscode: 503 查看防火墙，并关闭防火墙 查看防火墙的状态的命令为： sudo systemctl status firewalld 打开防火墙的方式有两种，一种是打开后重启会恢复回原来的状态，命令为： sudo systemctl start firewalld 另一种是打开后重启不会恢复到原来的状态，命令为： sudo systemctl enable firewalld 这种方式输入命令后要重启系统才会生效。 关闭防火墙的方式也有两种，和打开相对应，命令分别为 sudo systemctl stop firewalld sudo systemctl disable firewalld ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:9:2","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"dns-autoscaler 报错 dns-autoscaler Update failure: the server could not find the requested resource E1222 01:07:18.706470 1 autoscaler_server.go:120] Update failure: the server could not find the requested resource 由于dns-autoscaler安装部署使用了低版本，现象分析可能是由于接口不匹配导致 ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:9:3","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"创建pod报错 networkPlugin cni failed to set up pod “myapp-pod_default” network: failed to Statfs “/proc/62177/ns/net”: no such file or directory networkPlugin cni failed to set up pod network: failed to Statfs: no such file or directory 有人建议操作如下： I executed following commands: sudo systemctl stop kubelet docker ps docker stop [all running containers id] rm -rf /etc/cni/net.d/* sudo kubeadm reset sudo iptables -F \u0026\u0026 sudo iptables -t nat -F \u0026\u0026 sudo iptables -t mangle -F \u0026\u0026 sudo iptables -X sudo systemctl restart docker.service https://github.com/kubernetes/kubernetes/issues/90429 https://github.com/kubernetes/kubernetes/issues/72044 https://github.com/vmware-tanzu/antrea/issues/831 仔细分析系统日志/var/log/messages，发现Memory cgroup out of memory导致 Dec 22 14:58:50 node131 kernel: Memory cgroup stats for /kubepods.slice/kubepods-pod7458ce47_f199_4abc_bced_747429207f75.slice/docker-efdd061c291cc737e425bfe6b7f25a69352d75a99415143955098311908588c8.scope: cache:0KB rss:2048KB rss_huge:0KB mapped_file:0KB swap:0KB inactive_anon:0KB active_anon:2008KB inactive_file:0KB active_file:0KB unevictable:0KB Dec 22 14:58:50 node131 kernel: [ pid ] uid tgid total_vm rss nr_ptes swapents oom_score_adj name Dec 22 14:58:50 node131 kernel: [17978] 0 17978 39699 2343 27 0 -998 runc:[2:INIT] Dec 22 14:58:50 node131 kernel: Memory cgroup out of memory: Kill process 17983 (runc:[2:INIT]) score 4628 or sacrifice child Dec 22 14:58:50 node131 kernel: Killed process 17978 (runc:[2:INIT]), UID 0, total-vm:158796kB, anon-rss:6420kB, file-rss:2952kB, shmem-rss:0kB Dec 22 14:58:50 node131 kubelet: W1222 14:58:50.043333 1923 helpers.go:198] readString: Failed to read \"/sys/fs/cgroup/memory/kubepods.slice/kubepods-pod7458ce47_f199_4abc_bced_747429207f75.slice/docker-efdd061c291cc737e425bfe6b7f25a69352d75a99415143955098311908588c8.scope/memory.limit_in_bytes\": read /sys/fs/cgroup/memory/kubepods.slice/kubepods-pod7458ce47_f199_4abc_bced_747429207f75.slice/docker-efdd061c291cc737e425bfe6b7f25a69352d75a99415143955098311908588c8.scope/memory.limit_in_bytes: no such device 修改pod 请求内存，一般是请求内存太小，导致实际使用内存超过限制，被系统杀掉该pod进程 ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:9:4","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"出现目录无法删除：Device or resource busy [root@gpu53 lib]# rm -rf kubelet/ rm: cannot remove ‘kubelet/pods/837704db-2bae-11eb-913c-6c92bf8c5840/volumes/kubernetes.io~secret/kube-proxy-token-8mdk5’: Device or resource busy rm: cannot remove ‘kubelet/pods/bce1b611-2bc3-11eb-9c41-6c92bf8c5840/volumes/kubernetes.io~secret/calico-node-token-d9dv8’: Device or resource busy rm: cannot remove ‘kubelet/pods/402d0c26-43fd-11eb-bdb1-6c92bf8c5840/volumes/kubernetes.io~secret/default-token-vlvfj’: Device or resource busy lsof没有信息，则查看挂载信息，并取消挂载。 # mount tmpfs on /var/lib/kubelet/pods/bce1b611-2bc3-11eb-9c41-6c92bf8c5840/volumes/kubernetes.io~secret/calico-node-token-d9dv8 type tmpfs (rw,relatime) tmpfs on /var/lib/kubelet/pods/837704db-2bae-11eb-913c-6c92bf8c5840/volumes/kubernetes.io~secret/kube-proxy-token-8mdk5 type tmpfs (rw,relatime) [root@gpu53 lib]# mount |grep kubelet tmpfs on /var/lib/kubelet/pods/837704db-2bae-11eb-913c-6c92bf8c5840/volumes/kubernetes.io~secret/kube-proxy-token-8mdk5 type tmpfs (rw,relatime) tmpfs on /var/lib/kubelet/pods/402d0c26-43fd-11eb-bdb1-6c92bf8c5840/volumes/kubernetes.io~secret/default-token-vlvfj type tmpfs (rw,relatime) [root@gpu53 lib]# [root@gpu53 lib]# [root@gpu53 lib]# umount /var/lib/kubelet/pods/837704db-2bae-11eb-913c-6c92bf8c5840/volumes/kubernetes.io~secret/kube-proxy-token-8mdk5 [root@gpu53 lib]# [root@gpu53 lib]# [root@gpu53 lib]# umount /var/lib/kubelet/pods/402d0c26-43fd-11eb-bdb1-6c92bf8c5840/volumes/kubernetes.io~secret/default-token-vlvfj [root@gpu53 lib]# [root@gpu53 lib]# rm -rf kubelet/ ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:9:5","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"calico node pod一直没有起来 Number of node(s) with BGP peering established = 0 网上解决方法如下： https://blog.csdn.net/qq_36783142/article/details/107912407 - name: IP_AUTODETECTION_METHOD value: \"interface=enp26s0f3\" 但此方式不能解决自己环境所遇问题。 自己分析应该是网络路由问题（原来环境残留的脏路由导致），做下清理处理 执行下面命令解决 systemctl stop kubelet systemctl stop docker iptables --flush iptables -tnat --flush systemctl start docker systemctl start kubelet ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:9:6","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"启动测试pod，Failed to create pod sandbox getting the final child’s pid from pipe caused: read init-p: connection reset by peer: unknown 报错如下： Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Scheduled 74s default-scheduler Successfully assigned default/myapp-pod to gpu53 Normal SandboxChanged 78s (x12 over 89s) kubelet Pod sandbox changed, it will be killed and re-created. Warning FailedCreatePodSandBox 77s (x13 over 90s) kubelet Failed to create pod sandbox: rpc error: code = Unknown desc = failed to start sandbox container for pod \"myapp-pod\": Error response from daemon: OCI runtime create failed: container_linux.go:370: starting container process caused: process_linux.go:338: getting the final child's pid from pipe caused: read init-p: connection reset by peer: unknown 检查内核参数 max_user_namespaces，并修改，该方式为临时生效。 [root@node2 ~]# cat /proc/sys/user/max_user_namespaces 0 [root@node2 ~]# [root@node2 ~]# [root@node2 ~]# echo 10000 \u003e /proc/sys/user/max_user_namespaces [root@node2 ~]# [root@node2 ~]# [root@node2 ~]# cat /proc/sys/user/max_user_namespaces 10000 [root@node2 ~]# 具体详细修改参数user namespaces方式， 参考配置 CentOS 7 系统启用 user namespaces ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:9:7","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"kuelet1.20 配置–cgroups-per-qos=False 时会导致kubelet无法正常启动 kuelet1.20 默认开启cgroups-per-qos kubelet启动的pod 所在cgroup组一般都在cgroup的kubepods.slice 目录下， ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:9:8","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"测试pod一直是ContainerCreating NAMESPACE NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES default myapp-pod 0/1 ContainerCreating 0 11m \u003cnone\u003e gpu53 \u003cnone\u003e \u003cnone\u003e k 系统日志打印信息如下： Dec 23 09:52:18 gpu53 kernel: Task in /kubepods.slice/kubepods-pod40b435fc_0bbb_4eeb_9bff_5ce1f473cb9e.slice/docker-1f0491dfbae47dcf8a6b8f5b6f94e50ef3da592420f2d25e34d87f30524f71f2.scope killed as a result of limit of /kubepods.slice/kubepods-pod40b435fc_0bbb_4eeb_9bff_5ce1f473cb9e.slice Dec 23 09:52:18 gpu53 kernel: memory: usage 2048kB, limit 2048kB, failcnt 861 Dec 23 09:52:18 gpu53 kernel: memory+swap: usage 2048kB, limit 9007199254740988kB, failcnt 0 Dec 23 09:52:18 gpu53 kernel: kmem: usage 0kB, limit 9007199254740988kB, failcnt 0 Dec 23 09:52:18 gpu53 kernel: Memory cgroup stats for /kubepods.slice/kubepods-pod40b435fc_0bbb_4eeb_9bff_5ce1f473cb9e.slice: cache:0KB rss:0KB rss_huge:0KB mapped_file:0KB swap:0KB inactive_anon:0KB active_anon:0KB inactive_file:0KB active_file:0KB unevictable:0KB Dec 23 09:52:18 gpu53 kernel: Memory cgroup stats for /kubepods.slice/kubepods-pod40b435fc_0bbb_4eeb_9bff_5ce1f473cb9e.slice/docker-1f0491dfbae47dcf8a6b8f5b6f94e50ef3da592420f2d25e34d87f30524f71f2.scope: cache:0KB rss:2048KB rss_huge:0KB mapped_file:0KB swap:0KB inactive_anon:0KB active_anon:2020KB inactive_file:0KB active_file:0KB unevictable:0KB Dec 23 09:52:18 gpu53 kernel: [ pid ] uid tgid total_vm rss nr_ptes swapents oom_score_adj name Dec 23 09:52:18 gpu53 kernel: [112691] 0 112691 5734 1041 13 0 -998 6 Dec 23 09:52:18 gpu53 kernel: Memory cgroup out of memory: Kill process 112691 (6) score 1998 or sacrifice child Dec 23 09:52:18 gpu53 kernel: Killed process 112691 (6) total-vm:22936kB, anon-rss:1944kB, file-rss:2220kB, shmem-rss:0kB Dec 23 09:52:18 gpu53 systemd: Stopped libcontainer container 1f0491dfbae47dcf8a6b8f5b6f94e50ef3da592420f2d25e34d87f30524f71f2. Dec 23 09:52:18 gpu53 systemd: Stopping libcontainer container 1f0491dfbae47dcf8a6b8f5b6f94e50ef3da592420f2d25e34d87f30524f71f2. Dec 23 09:52:18 gpu53 containerd: time=\"2020-12-23T09:52:18.227196277+08:00\" level=info msg=\"shim reaped\" id=1f0491dfbae47dcf8a6b8f5b6f94e50ef3da592420f2d25e34d87f30524f71f2 Dec 23 09:52:18 gpu53 dockerd: time=\"2020-12-23T09:52:18.237403201+08:00\" level=error msg=\"stream copy error: reading from a closed fifo\" Dec 23 09:52:18 gpu53 dockerd: time=\"2020-12-23T09:52:18.237413120+08:00\" level=error msg=\"stream copy error: reading from a closed fifo\" Dec 23 09:52:18 gpu53 dockerd: time=\"2020-12-23T09:52:18.271031114+08:00\" level=error msg=\"1f0491dfbae47dcf8a6b8f5b6f94e50ef3da592420f2d25e34d87f30524f71f2 cleanup: failed to delete container from containerd: no such container\" Dec 23 09:52:18 gpu53 dockerd: time=\"2020-12-23T09:52:18.271110530+08:00\" level=error msg=\"Handler for POST /v1.40/containers/1f0491dfbae47dcf8a6b8f5b6f94e50ef3da592420f2d25e34d87f30524f71f2/start returned error: OCI runtime create failed: container_linux.go:370: starting container process caused: process_linux.go:338: getting the final child's pid from pipe caused: read init-p: connection reset by peer: unknown\" Dec 23 09:52:18 gpu53 kubelet: E1223 09:52:18.271582 104914 remote_runtime.go:116] RunPodSandbox from runtime service failed: rpc error: code = Unknown desc = failed to start sandbox container for pod \"myapp-pod\": Error response from daemon: OCI runtime create failed: container_linux.go:370: starting container process caused: process_linux.go:338: getting the final child's pid from pipe caused: read init-p: connection reset by peer: unknown Dec 23 09:52:18 gpu53 kubelet: E1223 09:52:18.271680 104914 kuberuntime_sandbox.go:70] CreatePodSandbox for pod \"myapp-pod_default(40b435fc-0bbb-4eeb-9bff-5ce1f473cb9e)\" failed: rpc error: code = Unknown desc = failed to start sandbox container for pod \"myapp-pod\": Error response from daemon: OCI runtime create failed: container_linux.go:370: starting container process caused: process_linux.go:338: getting the final child's pid from pipe caused: ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:9:9","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"附录 ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:10:0","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"命令 给节点node2 打master标签 kubectl label node node2 node-role.kubernetes.io/master=true --overwrite 给节点gpu53 打node标签 kubectl label node gpu53 node-role.kubernetes.io/node=true --overwrite 强制删除某pod kubectl delete po myapp-pod --force --grace-period=0 docker 镜像批量打包 docker save $(docker images | grep -v REPOSITORY | awk 'BEGIN{OFS=\":\";ORS=\" \"}{print $1,$2}') -o k8s_packages.tar ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:10:1","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["K8S"],"content":"访问dashboard 使用kubectl proxy 使用kubectl proxy命令就可以使API server监听在本地的8001端口上 使用命令如下: kubectl proxy --address='0.0.0.0' --accept-hosts='^*$' 则在内网的任意节点浏览器中可以使用地址访问，当然该地址需要证书授权访问 curl http://192.168.182.131:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/ ","date":"2020-12-25","objectID":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/:10:2","tags":["K8S"],"title":"安装部署k8s","uri":"/posts/2020/12/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2k8s/"},{"categories":["Linux"],"content":"CentOS 7 启用 user namespaces（用户命名空间）","date":"2020-12-23","objectID":"/posts/2020/12/centos-7-%E5%90%AF%E7%94%A8-user-namespaces%E7%94%A8%E6%88%B7%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/","tags":["Linux","CentOS"],"title":"CentOS 7 启用 user namespaces（用户命名空间）","uri":"/posts/2020/12/centos-7-%E5%90%AF%E7%94%A8-user-namespaces%E7%94%A8%E6%88%B7%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["Linux"],"content":"在 CentOS 内核 3.8 或更高版本中，添加了 user namespaces （户名命名空间）功能。但是，该功能默认情况下是禁用的，原因是 Red Hat 希望该功能在社区中孵化更长时间，以确保该功能的稳定性和安全性。目前越来越多的软件开始涉及该功能，例如 Docker 等。 ","date":"2020-12-23","objectID":"/posts/2020/12/centos-7-%E5%90%AF%E7%94%A8-user-namespaces%E7%94%A8%E6%88%B7%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:0:0","tags":["Linux","CentOS"],"title":"CentOS 7 启用 user namespaces（用户命名空间）","uri":"/posts/2020/12/centos-7-%E5%90%AF%E7%94%A8-user-namespaces%E7%94%A8%E6%88%B7%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["Linux"],"content":"配置 CentOS 7 系统启用 user namespaces 注意：以下操作均在 root 用户下完成，或者你的超级用户。 查看系统内核版本： uname -r #3.10.0-1062.el7.x86_64 临时配置，重启会失效，可用作临时验证： # 查看系统 user namespaces 最大为 0 cat /proc/sys/user/max_user_namespaces #0 # 临时开启 user namespace ，向文件内写入一个整数。 echo 10000 \u003e /proc/sys/user/max_user_namespaces 永久配置，设置 CentOS 7 的 kernel 开启 user namespace ，默认情况下是禁用的。并且，写入/etc/sysctl.conf配置user.max_user_namespaces=10000，最后重启系统。 # kernel 设置 grubby --args=\"user_namespace.enable=1\" --update-kernel=\"$(grubby --default-kernel)\" # 写入配置文件 echo \"user.max_user_namespaces=10000\" \u003e\u003e /etc/sysctl.conf # 重启 reboot 如需关闭 user namespace ，使用如下命令： grubby --remove-args=\"user_namespace.enable=1\" --update-kernel=\"$(grubby --default-kernel)\" ","date":"2020-12-23","objectID":"/posts/2020/12/centos-7-%E5%90%AF%E7%94%A8-user-namespaces%E7%94%A8%E6%88%B7%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:1:0","tags":["Linux","CentOS"],"title":"CentOS 7 启用 user namespaces（用户命名空间）","uri":"/posts/2020/12/centos-7-%E5%90%AF%E7%94%A8-user-namespaces%E7%94%A8%E6%88%B7%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["Linux"],"content":"参考资料 https://www.redhat.com/en/blog/whats-next-containers-user-namespaces https://github.com/procszoo/procszoo/wiki/How-to-enable-%22user%22-namespace-in-RHEL7-and-CentOS7%3F https://superuser.com/questions/1294215/is-it-safe-to-enable-user-namespaces-in-centos-7-4-and-how-to-do-it ","date":"2020-12-23","objectID":"/posts/2020/12/centos-7-%E5%90%AF%E7%94%A8-user-namespaces%E7%94%A8%E6%88%B7%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:2:0","tags":["Linux","CentOS"],"title":"CentOS 7 启用 user namespaces（用户命名空间）","uri":"/posts/2020/12/centos-7-%E5%90%AF%E7%94%A8-user-namespaces%E7%94%A8%E6%88%B7%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["Docker"],"content":"脚本一键安装部署docker19.03","date":"2020-12-21","objectID":"/posts/2020/12/%E8%84%9A%E6%9C%AC%E9%83%A8%E7%BD%B2docker/","tags":["Docker"],"title":"脚本部署Docker","uri":"/posts/2020/12/%E8%84%9A%E6%9C%AC%E9%83%A8%E7%BD%B2docker/"},{"categories":["Docker"],"content":"脚本一键安装部署docker19.03 ","date":"2020-12-21","objectID":"/posts/2020/12/%E8%84%9A%E6%9C%AC%E9%83%A8%E7%BD%B2docker/:0:0","tags":["Docker"],"title":"脚本部署Docker","uri":"/posts/2020/12/%E8%84%9A%E6%9C%AC%E9%83%A8%E7%BD%B2docker/"},{"categories":["Docker"],"content":"安装脚本 使用阿里云镜像源 docker参数 native.cgroupdriver=systemd #!/bin/bash # 安装docker # VAR SET DOCKER_VERSION=\"19.03.8\" echo \"START to install docker $DOCKER_VERSION\" export REGISTRY_MIRROR=https://registry.cn-hangzhou.aliyuncs.com # a) 检查和卸载旧版本(如果之前有安装docker) echo \"check and uninstall old docker...\" yum remove -y docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine # b) 配置yum repository echo \"config yum repository...\" yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # c) 安装并启动docker echo \"install docker $DOCKER_VERSION\" yum install -y docker-ce-$DOCKER_VERSION docker-ce-cli-$DOCKER_VERSION containerd.io systemctl enable docker systemctl start docker # d) 修改docker Cgroup Driver为systemd echo \"config docker Cgroup Driver: systemd\" sed -i \"s#^ExecStart=/usr/bin/dockerd.*#ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --exec-opt native.cgroupdriver=systemd#g\" /usr/lib/systemd/system/docker.service # e) 设置 docker 镜像，提高 docker 镜像下载速度和稳定性 echo \"set docker mirror...\" curl -sSL https://kuboard.cn/install-script/set_mirror.sh | sh -s ${REGISTRY_MIRROR} systemctl daemon-reload systemctl restart docker docker version ","date":"2020-12-21","objectID":"/posts/2020/12/%E8%84%9A%E6%9C%AC%E9%83%A8%E7%BD%B2docker/:1:0","tags":["Docker"],"title":"脚本部署Docker","uri":"/posts/2020/12/%E8%84%9A%E6%9C%AC%E9%83%A8%E7%BD%B2docker/"},{"categories":["Python"],"content":"安装部署Python3","date":"2020-12-19","objectID":"/posts/2020/12/%E8%84%9A%E6%9C%AC%E9%83%A8%E7%BD%B2python3/","tags":["Python"],"title":"脚本部署Python3","uri":"/posts/2020/12/%E8%84%9A%E6%9C%AC%E9%83%A8%E7%BD%B2python3/"},{"categories":["Python"],"content":"脚本一键安装部署Python3 ","date":"2020-12-19","objectID":"/posts/2020/12/%E8%84%9A%E6%9C%AC%E9%83%A8%E7%BD%B2python3/:0:0","tags":["Python"],"title":"脚本部署Python3","uri":"/posts/2020/12/%E8%84%9A%E6%9C%AC%E9%83%A8%E7%BD%B2python3/"},{"categories":["Python"],"content":"安装脚本 centos系统自带默认python2 py3命令需要跟py2进行区别 #! /bin/bash yum -y install zlib-devel bzip2-devel libffi-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel wget gcc python-devel openssl sshpass wget https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tgz mkdir -p /usr/local/python3 tar -xf Python-3.7.1.tgz yum install libffi-devel -y cd Python-3.7.1 pwd ./configure --prefix=/usr/local/python3 make make install ln -s /usr/local/python3/bin/python3 /usr/bin/python3 ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 echo 'PATH=$PATH:$HOME/bin:/usr/local/python3/bin' \u003e\u003e/etc/profile echo 'export PATH' \u003e\u003e/etc/profile source /etc/profile ","date":"2020-12-19","objectID":"/posts/2020/12/%E8%84%9A%E6%9C%AC%E9%83%A8%E7%BD%B2python3/:1:0","tags":["Python"],"title":"脚本部署Python3","uri":"/posts/2020/12/%E8%84%9A%E6%9C%AC%E9%83%A8%E7%BD%B2python3/"},{"categories":["K8S"],"content":"如何使用perf-test的clusterloader进行性能测试","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"如何使用perf-test的clusterloader进行性能测试 ","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/:0:0","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"1 K8S的性能指标：SLIs/SLOs K8S的SLI (服务等级指标) 和 SLO (服务等级目标)： Kubernetes 社区提供的K8S系统性能测试指标定义。 社区参考文档：Kubernetes scalability and performance SLIs/SLOs 目前社区提供的官方正式的性能指标有3个，如下表： Status SLI SLO Official Latency of mutating API calls for single objects for every (resource, verb) pair, measured as 99th percentile over last 5 minutes In default Kubernetes installation, for every (resource, verb) pair, excluding virtual and aggregated resources and Custom Resource Definitions, 99th percentile per cluster-day1 \u003c= 1s Official Latency of non-streaming read-only API calls for every (resource, scope pair, measured as 99th percentile over last 5 minutes In default Kubernetes installation, for every (resource, scope) pair, excluding virtual and aggregated resources and Custom Resource Definitions, 99th percentile per cluster-day1 (a) \u003c= 1s if scope=resource (b) \u003c= 5s if scope=namespace (c) \u003c= 30s if scope=cluster Official Startup latency of schedulable stateless pods, excluding time to pull images and run init containers, measured from pod creation timestamp to when all its containers are reported as started and observed via watch, measured as 99th percentile over last 5 minutes In default Kubernetes installation, 99th percentile per cluster-day1 \u003c= 5s ","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/:1:0","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"2 clusterloader准备 从github上拉取perf-test项目，其中包含clusterloader2。perf-tests位置为：$GOPATH/src/k8s.io/perf-tests 需要选择与测试k8s集群匹配的版本，这里选择了1.14版本 进入clusterloader2目录，进行编译 export GOPATH=/home/wangb/goprojects cd $GOPATH/src/k8s.io/perf-tests/clusterloader2 go build -o clusterloader './cmd/' clusterloader2的测试配置文件在testing目录下。可以参考修改配置 按修改后的测试配置文件，指定参数变量，执行clusterloader测试 ","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/:2:0","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"3 clusterloader测试 ","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/:3:0","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"1. 运行命令 说明：运行命令前，需要根据测试场景，修改测试配置文件中的变量参数，配置文件包括有config.yaml， rc.yaml，deployment.yaml 具体配置参数说明，见下文。 # 进入clusterloader可执行文件目录，配置文件也需转移到了此位置 cd /home/wangb/perf-test/clusterloader2 # ssh访问参数 export KUBE_SSH_KEY_PATH=/root/.ssh/id_rsa # master节点信息 MASTER_NAME=node1 TEST_MASTER_IP=192.168.182.101 TEST_MASTER_INTERNAL_IP=192.168.182.101 KUBE_CONFIG=${HOME}/.kube/config # 测试配置文件 TEST_CONFIG='/home/wangb/perf-test/clusterloader2/testing/density/config2.yaml' # 测试报告目录位置 REPORT_DIR='./reports' # 测试日志打印文件 LOG_FILE='test.log' ./clusterloader --kubeconfig=$KUBE_CONFIG \\ --mastername=$TEST_MASTER_IP \\ --masterip=$MASTER_IP \\ --master-internal-ip=TEST_MASTER_INTERNAL_IP \\ --testconfig=$TEST_CONFIG \\ --report-dir=$REPORT_DIR \\ --alsologtostderr 2\u003e\u00261 | tee $LOG_FILE 运行命令可以指定nodes数量，不过这里默认使用集群全部节点。 ","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/:3:1","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"2. 测试配置文件 test config（默认） density 测试配置 Steps is the procedures you defined. Each step might contain phases, measurements Meansurement defines what you want to supervise or capture. Phase describes the attributes of some certain tasks. This config defines the following steps: Starting measurements : don’t care about what happens during preparation. Starting saturation pod measurements : same as above Creating saturation pods : the first case is saturation pods Collecting saturation pod measurements Starting latency pod measurements Creating latency pods : the second case is latency pods Waiting for latency pods to be running Deleting latency pods Waiting for latency pods to be deleted Collecting pod startup latency Deleting saturation pods Waiting for saturation pods to be deleted Collecting measurements So we can see the testing mainly gathers measurements during the CRUD of saturation pods and latency pods: saturation pods: pods in deployments with quite a large repliacas latency pods: pods in deployments with one replicas So you see the differences between the two modes. When saturation pods are created, replicas-controller in kube-controller-manager is handling one event. But in terms of latency pods, it’s hundreds of events. But what’s the difference anyway? It’s because the various rate-limiter inside kubernetes affects the performance of scheduler and controller-manager. In each case, what we’re concerned is the number of pods, deployments and namespaces. We all know that kubernetes limits the pods/node, pods/namespace, so it’s quite essential to adust relative parameters to achieve a reasonable load. test config.yaml（默认配置） # ASSUMPTIONS:# - Underlying cluster should have 100+ nodes.# - Number of nodes should be divisible by NODES_PER_NAMESPACE (default 100).#Constants{{$DENSITY_RESOURCE_CONSTRAINTS_FILE := DefaultParam .DENSITY_RESOURCE_CONSTRAINTS_FILE \"\"}}{{$NODE_MODE := DefaultParam .NODE_MODE \"allnodes\"}}{{$NODES_PER_NAMESPACE := DefaultParam .NODES_PER_NAMESPACE 100}}{{$PODS_PER_NODE := DefaultParam .PODS_PER_NODE 30}}{{$DENSITY_TEST_THROUGHPUT := DefaultParam .DENSITY_TEST_THROUGHPUT 20}}# LATENCY_POD_MEMORY and LATENCY_POD_CPU are calculated for 1-core 4GB node.# Increasing allocation of both memory and cpu by 10%# decreases the value of priority function in scheduler by one point.# This results in decreased probability of choosing the same node again.{{$LATENCY_POD_CPU := DefaultParam .LATENCY_POD_CPU 100}}{{$LATENCY_POD_MEMORY := DefaultParam .LATENCY_POD_MEMORY 350}}{{$MIN_LATENCY_PODS := 500}}{{$MIN_SATURATION_PODS_TIMEOUT := 180}}{{$ENABLE_CHAOSMONKEY := DefaultParam .ENABLE_CHAOSMONKEY false}}{{$ENABLE_SYSTEM_POD_METRICS:= DefaultParam .ENABLE_SYSTEM_POD_METRICS true}}{{$ENABLE_RESTART_COUNT_CHECK := DefaultParam .ENABLE_RESTART_COUNT_CHECK false}}{{$RESTART_COUNT_THRESHOLD_OVERRIDES:= DefaultParam .RESTART_COUNT_THRESHOLD_OVERRIDES \"\"}}#Variables{{$namespaces := DivideInt .Nodes $NODES_PER_NAMESPACE}}{{$podsPerNamespace := MultiplyInt $PODS_PER_NODE $NODES_PER_NAMESPACE}}{{$totalPods := MultiplyInt $podsPerNamespace $namespaces}}{{$latencyReplicas := DivideInt (MaxInt $MIN_LATENCY_PODS .Nodes) $namespaces}}{{$totalLatencyPods := MultiplyInt $namespaces $latencyReplicas}}{{$saturationRCTimeout := DivideFloat $totalPods $DENSITY_TEST_THROUGHPUT | AddInt $MIN_SATURATION_PODS_TIMEOUT}}# saturationRCHardTimeout must be at least 20m to make sure that ~10m node# failure won't fail the test. See https://github.com/kubernetes/kubernetes/issues/73461#issuecomment-467338711{{$saturationRCHardTimeout := MaxInt $saturationRCTimeout 1200}}name:densityautomanagedNamespaces:{{$namespaces}}tuningSets:- name:Uniform5qpsqpsLoad:qps:5{{if $ENABLE_CHAOSMONKEY}}chaosMonkey:nodeFailure:failureRate:0.01interval:1mjitterFactor:10.0simulatedDowntime:10m{{end}}steps:- measurements:- Identifier:APIResponsivenessMethod:APIResponsivenessParams:action:reset- Identifier:TestMetricsMethod:TestMetricsParams:action:startnodeMode:{{$NODE_MOD","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/:3:2","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"3. clusterloader2 源码简析 解析测试配置信息，执行测试测试用例 clusterloader2/cmd/clusterloader.go void main(){ // 构造clusterLoaderConfig // 构造framework，即各种k8s client f, err := framework.NewFramework( \u0026clusterLoaderConfig.ClusterConfig, getClientsNumber(clusterLoaderConfig.ClusterConfig.Nodes), ) // 遍历测试配置文件（可多个），按配置用例运行测试 for _, clusterLoaderConfig.TestConfigPath = range testConfigPaths { test.RunTest(f, prometheusFramework, \u0026clusterLoaderConfig) } } // RunTest runs test based on provided test configuration. func RunTest(clusterFramework, prometheusFramework *framework.Framework, clusterLoaderConfig *config.ClusterLoaderConfig) *errors.ErrorList { // simpleContext上下文信息 ctx := CreateContext(clusterLoaderConfig, clusterFramework, prometheusFramework, state.NewState()) testConfigFilename := filepath.Base(clusterLoaderConfig.TestConfigPath) // 按参数 设置override config 和 nodes参数 mapping, errList := config.GetMapping(clusterLoaderConfig) if errList != nil { return errList } // 使用emplateProvider根据mapping信息把testConfig的模板文件渲染成可用的api.Config testConfig, err := ctx.GetTemplateProvider().TemplateToConfig(testConfigFilename, mapping) if err != nil { return errors.NewErrorList(fmt.Errorf(\"config reading error: %v\", err)) } return Test.ExecuteTest(ctx, testConfig) } // api.Config 定义 // Config is a structure that represents configuration // for a single test scenario. type Config struct { // Name of the test case. Name string `json: name` // AutomanagedNamespaces is a number of automanaged namespaces. AutomanagedNamespaces int32 `json: automanagedNamespaces` // Steps is a sequence of test steps executed in serial. Steps []Step `json: steps` // TuningSets is a collection of tuning sets that can be used by steps. TuningSets []TuningSet `json: tuningSets` // ChaosMonkey is a config for simulated component failures. ChaosMonkey ChaosMonkeyConfig `json: chaosMonkey` } RunTest 又调用了 ExecuteTest，示例代码如下： 循环steps，按顺序执行ExecuteStep // ExecuteTest executes test based on provided configuration. func (ste *simpleTestExecutor) ExecuteTest(ctx Context, conf *api.Config) { // auto set test namespace ctx.GetClusterFramework().SetAutomanagedNamespacePrefix(fmt.Sprintf(\"test-%s\", util.RandomDNS1123String(6))) // clear test resource defer cleanupResources(ctx) // create test namespace err = ctx.GetClusterFramework().CreateAutomanagedNamespaces(int(conf.AutomanagedNamespaces)) // 遍历steps，分步执行，如果某step出错stepErr，则退出。 for i := range conf.Steps { if stepErrList := ste.ExecuteStep(ctx, \u0026conf.Steps[i]); !stepErrList.IsEmpty() { errList.Concat(stepErrList) if isErrsCritical(stepErrList) { return errList } } } // 输出测试汇总信息 for _, summary := range ctx.GetMeasurementManager().GetSummaries() { if ctx.GetClusterLoaderConfig().ReportDir == \"\" { klog.Infof(\"%v: %v\", summary.SummaryName(), summary.SummaryContent()) } else { // TODO(krzysied): Remember to keep original filename style for backward compatibility. filePath := path.Join(ctx.GetClusterLoaderConfig().ReportDir, summary.SummaryName()+\"_\"+conf.Name+\"_\"+summary.SummaryTime().Format(time.RFC3339)+\".\"+summary.SummaryExt()) ioutil.WriteFile(filePath, []byte(summary.SummaryContent()), 0644) } } } 可以看出 每个step中的Measurements和Phases都是并发执行的。 而且在每个step中，要么执行measurement.exec，要么执行phase.exec clusterloader2/pkg/test/simple_test_executor.go // ExecuteStep executes single test step based on provided step configuration. func (ste *simpleTestExecutor) ExecuteStep(ctx Context, step *api.Step) *errors.ErrorList { var wg wait.Group errList := errors.NewErrorList() if len(step.Measurements) \u003e 0 { for i := range step.Measurements { // index is created to make i value unchangeable during thread execution. index := i wg.Start(func() { err := ctx.GetMeasurementManager().Execute(step.Measurements[index].Method, step.Measurements[index].Identifier, step.Measurements[index].Params) if err != nil { errList.Append(fmt.Errorf(\"measurement call %s - %s error: %v\", step.Measurements[index].Method, step.Measurements[index].Identifier, err)) } }) } } else { for i := range step.Phases {","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/:3:3","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"4. 部署测试 .1 k8s-2节点环境 在本地虚拟机2节点的测试环境中，需要修改测试配置文件和pod部署脚本。 测试配置文件主要修改参数有 Nodes，属于配置文件上下文参数，如果不指定，测试工具会抓取实际环境中的可用的节点数，进行设置 NODES_PER_NAMESPACE， 每个ns下的nodes数。这里需注意: NODES \u003e NODES_PER_NAMESPACE PODS_PER_NODE，每个节点下的pod数 MIN_LATENCY_PODS这个数值会跟 PODS_PER_NODE比较 选取最大的，作为LATENCY测试的参数。因为LATENCY测试一般使用较多pod 数，即$MIN_LATENCY_PODS 测试中会有测试使用的资源参数，这里需要对实际情况进行config.yaml调整。 LATENCY_POD_CPU LATENCY_POD_MEMORY 其它自定义资源数量，可以在config.yaml或者rc.yaml和deployment文件中添加配置 .1 部署config.yaml 这里主要修改如下： 上述的测试配置参数 主要修改参数有 NODES_PER_NAMESPACE PODS_PER_NODE MIN_LATENCY_PODS LATENCY_POD_CPU LATENCY_POD_MEMORY DENSITY_TEST_THROUGHPUT measurement-TestMetrics 原有测试工具解析收集Metrics操作异常导致测试失败，详见后面问题描述 # ASSUMPTIONS:# - Underlying cluster should have 100+ nodes.# - Number of nodes should be divisible by NODES_PER_NAMESPACE (default 100).#Constants{{$DENSITY_RESOURCE_CONSTRAINTS_FILE := DefaultParam .DENSITY_RESOURCE_CONSTRAINTS_FILE \"\"}}#{{$NODE_MODE := DefaultParam .NODE_MODE \"allnodes\"}}{{$NODE_MODE := DefaultParam .NODE_MODE \"master\"}}{{$NODES_PER_NAMESPACE := DefaultParam .NODES_PER_NAMESPACE 1}}{{$PODS_PER_NODE := DefaultParam .PODS_PER_NODE 2}}{{$DENSITY_TEST_THROUGHPUT := DefaultParam .DENSITY_TEST_THROUGHPUT 20}}# LATENCY_POD_MEMORY and LATENCY_POD_CPU are calculated for 1-core 4GB node.# Increasing allocation of both memory and cpu by 10%# decreases the value of priority function in scheduler by one point.# This results in decreased probability of choosing the same node again.{{$LATENCY_POD_CPU := DefaultParam .LATENCY_POD_CPU 5}}{{$LATENCY_POD_MEMORY := DefaultParam .LATENCY_POD_MEMORY 3}}{{$MIN_LATENCY_PODS := 20}}{{$MIN_SATURATION_PODS_TIMEOUT := 180}}{{$ENABLE_CHAOSMONKEY := DefaultParam .ENABLE_CHAOSMONKEY false}}{{$ENABLE_SYSTEM_POD_METRICS:= DefaultParam .ENABLE_SYSTEM_POD_METRICS false}}{{$ENABLE_RESTART_COUNT_CHECK := DefaultParam .ENABLE_RESTART_COUNT_CHECK false}}{{$RESTART_COUNT_THRESHOLD_OVERRIDES:= DefaultParam .RESTART_COUNT_THRESHOLD_OVERRIDES \"\"}}#Variables{{$namespaces := DivideInt .Nodes $NODES_PER_NAMESPACE}}{{$podsPerNamespace := MultiplyInt $PODS_PER_NODE $NODES_PER_NAMESPACE}}{{$totalPods := MultiplyInt $podsPerNamespace $namespaces}}{{$latencyReplicas := DivideInt (MaxInt $MIN_LATENCY_PODS .Nodes) $namespaces}}{{$totalLatencyPods := MultiplyInt $namespaces $latencyReplicas}}{{$saturationRCTimeout := DivideFloat $totalPods $DENSITY_TEST_THROUGHPUT | AddInt $MIN_SATURATION_PODS_TIMEOUT}}# saturationRCHardTimeout must be at least 20m to make sure that ~10m node# failure won't fail the test. See https://github.com/kubernetes/kubernetes/issues/73461#issuecomment-467338711{{$saturationRCHardTimeout := MaxInt $saturationRCTimeout 1200}}name:densityautomanagedNamespaces:{{$namespaces}}tuningSets:- name:Uniform5qpsqpsLoad:qps:5{{if $ENABLE_CHAOSMONKEY}}chaosMonkey:nodeFailure:failureRate:0.01interval:1mjitterFactor:10.0simulatedDowntime:10m{{end}}steps:- measurements:- Identifier:APIResponsivenessMethod:APIResponsivenessParams:action:reset- Identifier:TestMetricsMethod:TestMetricsParams:action:startnodeMode:{{$NODE_MODE}}resourceConstraints:{{$DENSITY_RESOURCE_CONSTRAINTS_FILE}}systemPodMetricsEnabled:{{$ENABLE_SYSTEM_POD_METRICS}}restartCountThresholdOverrides:{{YamlQuote $RESTART_COUNT_THRESHOLD_OVERRIDES 4}}enableRestartCountCheck:{{$ENABLE_RESTART_COUNT_CHECK}}# Create saturation pods- measurements:- Identifier:SaturationPodStartupLatencyMethod:PodStartupLatencyParams:action:startlabelSelector:group = saturationthreshold:{{$saturationRCTimeout}}s- measurements:- Identifier:WaitForRunningSaturationRCsMethod:WaitForControlledPodsRunningParams:action:startapiVersion:v1kind:ReplicationControllerlabelSelector:group = saturationoperationTimeout:{{$saturationRCHardTimeout}}s- phases:- namespaceRange:min:1max:{{$namespaces}}replicasPerNamespace:1tuningSet:Uniform5qpsobjectBundle:- basename:saturation-rcobjectTemplatePath:rc.yamltemplateFillMap:Replicas:{{$podsPerNamespace}}Group:saturationCpuRequest:1mMemoryRequest:10M- measurements:- Identifier:SchedulingTh","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/:3:4","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"4 对自定义调度器测试 ","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/:4:0","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"源码修改 对自定义调度器kube-batch测试，pod延时的计算，原有代码使用的是k8s调度器的event，这里需要修改成kube-batch，如下 在pod_startup_latency.go中 func (p *podStartupLatencyMeasurement) gatherScheduleTimes(c clientset.Interface) error { // custom cheduler add by wangb const CustomSchedulerName = \"kube-batch\" selector := fields.Set{ \"involvedObject.kind\": \"Pod\", //\"source\": corev1.DefaultSchedulerName, \"source\": CustomSchedulerName, }.AsSelector().String() options := metav1.ListOptions{FieldSelector: selector} schedEvents, err := c.CoreV1().Events(p.namespace).List(options) if err != nil { return err } for _, event := range schedEvents.Items { key := createMetaNamespaceKey(event.InvolvedObject.Namespace, event.InvolvedObject.Name) if _, ok := p.createTimes[key]; ok { p.scheduleTimes[key] = event.FirstTimestamp } } return nil } 重新编译成 custom_clusterloader ","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/:4:1","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"配置文件 修改下test.config 和 rc.yaml test.config 中注意pod资源使用，适当调整大些 rc.yaml中，要对container同时设置limts和requests ","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/:4:2","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"custom_clusterloader运行命令 # 自定义clusterloader程序：custom_clusterloader cd /home/wangb/perf-test/clusterloader2 # ssh访问参数 export KUBE_SSH_KEY_PATH=/root/.ssh/id_rsa # master节点信息 MASTER_NAME=node1 TEST_MASTER_IP=192.168.182.101 TEST_MASTER_INTERNAL_IP=192.168.182.101 KUBE_CONFIG=${HOME}/.kube/config # 测试配置文件 TEST_CONFIG='/home/wangb/perf-test/clusterloader2/testing/density/config-batch.yaml' # 测试报告目录位置 REPORT_DIR='./reports' # 测试日志打印文件 LOG_FILE='test.log' ./custom_clusterloader --kubeconfig=$KUBE_CONFIG \\ --mastername=$TEST_MASTER_IP \\ --masterip=$MASTER_IP \\ --master-internal-ip=TEST_MASTER_INTERNAL_IP \\ --testconfig=$TEST_CONFIG \\ --report-dir=$REPORT_DIR \\ --alsologtostderr 2\u003e\u00261 | tee $LOG_FILE ","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/:4:3","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"5 问题 ","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/:5:0","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"1. 提示 Getting master name error: master node not found和 Getting master internal ip error: didn’t find any InternalIP master IPs mastername和 internalip 参数需要配置 I1211 11:10:31.302599 118141 clusterloader.go:105] ClusterConfig.Nodes set to 2 E1211 11:10:31.304485 118141 clusterloader.go:113] Getting master name error: master node not found E1211 11:10:31.307705 118141 clusterloader.go:122] Getting master external ip error: didn't find any ExternalIP master IPs E1211 11:10:31.309369 118141 clusterloader.go:131] Getting master internal ip error: didn't find any InternalIP master IPs I1211 11:10:31.309388 118141 clusterloader.go:206] Using config: {ClusterConfig:{KubeConfigPath:/root/.kube/config Nodes:2 Provider: MasterIPs:[] MasterInternalIPs:[] MasterName: KubemarkRootKubeConfigPath:} ReportDir:./reports EnablePrometheusServer:false TearDownPrometheusServer:false TestConfigPath: TestOverridesPath:[] PrometheusConfig:{EnableServer:false TearDownServer:true ScrapeEtcd:false ScrapeNodeExporter:false ScrapeKubelets:false ScrapeKubeProxy:true SnapshotProject:}} I1211 11:10:31.311334 118141 cluster.go:56] Listing cluster nodes: I1211 11:10:31.311348 118141 cluster.go:68] Name: node1, clusterIP: 192.168.182.101, externalIP: , isSchedulable: true I1211 11:10:31.311354 118141 cluster.go:68] Name: node2, clusterIP: 192.168.182.102, externalIP: , isSchedulable: true I1211 11:10:31.314575 118141 clusterloader.go:167] -------------------------------------------------------------------------------- I1211 11:10:31.314588 118141 clusterloader.go:168] Running /home/wangb/perf-test/clusterloader2/testing/density/config.yaml I1211 11:10:31.314591 118141 clusterloader.go:169] -------------------------------------------------------------------------------- ","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/:5:1","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"2. Errors: [measurement call TestMetrics - TestMetrics error: [unexpected error (code: 0) in ssh connection to master: \u0026errors.errorString{s:“error getting signer for provider : ‘GetSigner(…) not implemented for ‘\"}] 测试配置了TestMetrics measurement，但是没有通过。 ssh问题，参数不正确，还需要自定义环境变量配置KUBE_SSH_KEY_PATH=/root/.ssh/id_rsa E1211 11:34:39.085551 19551 test_metrics.go:185] TestMetrics: [unexpected error (code: 0) in ssh connection to master: \u0026errors.errorString{s:\"error getting signer for provider : 'GetSigner(...) not implemented for '\"} unexpected error (code: 0) in ssh connection to master: \u0026errors.errorString{s:\"error getting signer for provider : 'GetSigner(...) not implemented for '\"}] I1211 11:34:49.103215 19551 simple_test_executor.go:345] Resources cleanup time: 10.017395168s E1211 11:34:49.103273 19551 clusterloader.go:177] -------------------------------------------------------------------------------- E1211 11:34:49.103291 19551 clusterloader.go:178] Test Finished E1211 11:34:49.103295 19551 clusterloader.go:179] Test: /home/wangb/perf-test/clusterloader2/testing/density/config.yaml E1211 11:34:49.103298 19551 clusterloader.go:180] Status: Fail E1211 11:34:49.103301 19551 clusterloader.go:182] Errors: [measurement call TestMetrics - TestMetrics error: [unexpected error (code: 0) in ssh connection to master: \u0026errors.errorString{s:\"error getting signer for provider : 'GetSigner(...) not implemented for '\"}] measurement call APIResponsiveness - APIResponsiveness error: top latency metric: there should be no high-latency requests, but: [got: {Resource:endpoints Subresource: Verb:GET Scope:namespace Latency:{Perc50:1.046ms Perc90:4.871ms Perc99:1.588679s} Count:33}; expected perc99 \u003c= 1s] measurement call TestMetrics - TestMetrics error: [unexpected error (code: 0) in ssh connection to master: \u0026errors.errorString{s:\"error getting signer for provider : 'GetSigner(...) not implemented for '\"} unexpected error (code: 0) in ssh connection to master: \u0026errors.errorString{s:\"error getting signer for provider : 'GetSigner(...) not implemented for '\"}]] E1211 11:34:49.103310 19551 clusterloader.go:184] -------------------------------------------------------------------------------- F1211 11:34:49.106925 19551 clusterloader.go:276] 1 tests have failed! ","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/:5:2","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"3. 告警提示：Master node is not registered. Grabbing metrics from Scheduler, ControllerManager and ClusterAutoscaler is disabled. W1214 10:00:44.212402 40729 metrics_grabber.go:81] Master node is not registered. Grabbing metrics from Scheduler, ControllerManager and ClusterAutoscaler is disabled. I1214 10:00:44.268795 40729 resource_usage.go:124] ResourceUsageSummary: gathering resource usage... I1214 10:00:44.268822 40729 container_resource_gatherer.go:172] Closed stop channel. Waiting for 0 workers I1214 10:00:44.268851 40729 container_resource_gatherer.go:180] Waitgroup finished. I1214 10:00:44.268935 40729 system_pod_metrics.go:82] skipping collection of system pod metrics E1214 10:00:44.268946 40729 test_metrics.go:185] TestMetrics: [text format parsing error in line 1: invalid metric name] I1214 10:00:54.301192 40729 simple_test_executor.go:345] Resources cleanup time: 10.031663914s E1214 10:00:54.301219 40729 clusterloader.go:177] -------------------------------------------------------------------------------- E1214 10:00:54.301222 40729 clusterloader.go:178] Test Finished E1214 10:00:54.301225 40729 clusterloader.go:179] Test: /home/wangb/perf-test/clusterloader2/testing/density/config2.yaml E1214 10:00:54.301227 40729 clusterloader.go:180] Status: Fail E1214 10:00:54.301229 40729 clusterloader.go:182] Errors: [measurement call TestMetrics - TestMetrics error: [text format parsing error in line 1: invalid metric name]] E1214 10:00:54.301233 40729 clusterloader.go:184] -------------------------------------------------------------------------------- F1214 10:00:54.305222 40729 clusterloader.go:276] 1 tests have failed! 排查过程，结合分析源码： 如果没有注册master节点，则测试不会统计调度器和controllers等组件信息 分处理逻辑，发现clusterloader2对master节点的判断条件不符合测试集群环境，如下。需要修改下clusterloader2的代码 // TODO: find a better way of figuring out if given node is a registered master. func IsMasterNode(nodeName string) bool { // We are trying to capture \"master(-...)?$\" regexp. // However, using regexp.MatchString() results even in more than 35% // of all space allocations in ControllerManager spent in this function. // That's why we are trying to be a bit smarter. if strings.HasSuffix(nodeName, \"master\") { return true } if len(nodeName) \u003e= 10 { return strings.HasSuffix(nodeName[:len(nodeName)-3], \"master-\") } return false } 原有代码程序对master节点判断逻辑为：nodename为master或者master-开头 修改代码：在system.IsMasterNode(node.Name) 引用处，新增条件： node.Labels[“node-role.kubernetes.io/master”] == “true” ，作为master节点判断 ","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/:5:3","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"4. EtcdMetrics信息获取不到：EtcdMetrics: failed to collect etcd database size E1214 11:06:03.936128 2312 etcd_metrics.go:121] EtcdMetrics: failed to collect etcd database size 或者上报错误：TestMetrics: [text format parsing error in line 1: invalid metric name] E1211 11:42:36.545827 30129 test_metrics.go:185] TestMetrics: [text format parsing error in line 1: invalid metric name] https://github.com/kubernetes/perf-tests/issues/875 提的问题没有人解答 最初先把testMetic测试项关闭，暂时规避该问题。可能跟metric服务数据采集有关。后来排查了下日志打印信息，发现有多处报错，要逐个排查。 分析源码应该是获取不到etcd的metrics导致，修改代码如下： measurement/common/simple/etcd_metrics func (e *etcdMetricsMeasurement) getEtcdMetrics(host, provider string) ([]*model.Sample, error) { // Etcd is only exposed on localhost level. We are using ssh method if provider == \"gke\" { klog.Infof(\"%s: not grabbing etcd metrics through master SSH: unsupported for gke\", e) return nil, nil } // In https://github.com/kubernetes/kubernetes/pull/74690, mTLS is enabled for etcd server // http://localhost:2382 is specified to bypass TLS credential requirement when checking // etcd /metrics and /health. //if samples, err := e.sshEtcdMetrics(\"curl http://localhost:2382/metrics\", host, provider); err == nil { // return samples, nil //} // fix: 问题错误信息：EtcdMetrics: failed to collect etcd database size // 这里需要根据实际测试环境情况，进行硬编码配置。 add by wangb // 先ssh，再执行metrics的cmd if samples, err := e.sshEtcdMetrics(\"curl https://localhost:2379/metrics -k --cert /etc/ssl/etcd/ssl/ca.pem --key /etc/ssl/etcd/ssl/ca-key.pem\", host, provider); err == nil { return samples, nil } // Use old endpoint if new one fails. return e.sshEtcdMetrics(\"curl http://localhost:2379/metrics\", host, provider) } 按上述修改后，再重新编译，问题解决 ","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/:5:4","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"5.报错找不到资源 TestMetrics: [the server could not find the requested resource (get pods kube-scheduler-192.168.182.101:10251)] I1214 14:14:20.039016 126597 resource_usage.go:124] ResourceUsageSummary: gathering resource usage... I1214 14:14:20.039058 126597 container_resource_gatherer.go:172] Closed stop channel. Waiting for 1 workers I1214 14:14:20.039075 126597 resource_gather_worker.go:90] Closing worker for node1 I1214 14:14:20.039082 126597 container_resource_gatherer.go:180] Waitgroup finished. I1214 14:14:20.039181 126597 system_pod_metrics.go:82] skipping collection of system pod metrics E1214 14:14:20.039193 126597 test_metrics.go:185] TestMetrics: [the server could not find the requested resource (get pods kube-scheduler-192.168.182.101:10251)] I1214 14:14:30.103890 126597 simple_test_executor.go:345] Resources cleanup time: 10.064213743s E1214 14:14:30.104163 126597 clusterloader.go:177] -------------------------------------------------------------------------------- E1214 14:14:30.104170 126597 clusterloader.go:178] Test Finished E1214 14:14:30.104173 126597 clusterloader.go:179] Test: /home/wangb/perf-test/clusterloader2/testing/density/config2.yaml E1214 14:14:30.104176 126597 clusterloader.go:180] Status: Fail E1214 14:14:30.104178 126597 clusterloader.go:182] Errors: [measurement call TestMetrics - TestMetrics error: [the server could not find the requested resource (delete pods kube-scheduler-192.168.182.101:10251)] measurement call TestMetrics - TestMetrics error: [the server could not find the requested resource (get pods kube-scheduler-192.168.182.101:10251)]] E1214 14:14:30.104180 126597 clusterloader.go:184] -------------------------------------------------------------------------------- F1214 14:14:30.104658 126597 clusterloader.go:276] 1 tests have failed! 分析可能是 view resource no match 查询资源url不正确导致？ 分析代码如下，可能是在msternode下构造request时有问题，定位原因为restclient构造url有问题。改用curl方式（可本地测试通过）直接获取调度器metrics common/simple/scheduler_latency.go // Sends request to kube scheduler metrics func (s *schedulerLatencyMeasurement) sendRequestToScheduler(c clientset.Interface, op, host, provider, masterName string) (string, error) { opUpper := strings.ToUpper(op) if opUpper != \"GET\" \u0026\u0026 opUpper != \"DELETE\" { return \"\", fmt.Errorf(\"unknown REST request\") } nodes, err := c.CoreV1().Nodes().List(metav1.ListOptions{}) if err != nil { return \"\", err } var masterRegistered = false for _, node := range nodes.Items { if node.Labels[\"node-role.kubernetes.io/master\"] == \"true\" || system.IsMasterNode(node.Name) { masterRegistered = true } } var responseText string // masterRegistered时，client接口处理有问题，统一改使用curl -X 方式处理GET和DELETE add by wangb start _ = masterRegistered //if masterRegistered { // ctx, cancel := context.WithTimeout(context.Background(), singleRestCallTimeout) // defer cancel() // // body, err := c.CoreV1().RESTClient().Verb(opUpper). // Context(ctx). // Namespace(metav1.NamespaceSystem). // Resource(\"pods\"). // Name(fmt.Sprintf(\"kube-scheduler-%v:%v\", masterName, ports.InsecureSchedulerPort)). // SubResource(\"proxy\"). // Suffix(\"metrics\"). // Do().Raw() // // if err != nil { // return \"\", err // } // responseText = string(body) //} else { // // If master is not registered fall back to old method of using SSH. // if provider == \"gke\" { // klog.Infof(\"%s: not grabbing scheduler metrics through master SSH: unsupported for gke\", s) // return \"\", nil // } // // cmd := \"curl -X \" + opUpper + \" http://localhost:10251/metrics\" // sshResult, err := measurementutil.SSH(cmd, host+\":22\", provider) // if err != nil || sshResult.Code != 0 { // return \"\", fmt.Errorf(\"unexpected error (code: %d) in ssh connection to master: %#v\", sshResult.Code, err) // } // responseText = sshResult.Stdout //} // curl http://localhost:10251/metrics 这个命令测试可用 cmd := \"curl -X \" + opUpper + \" http://localhost:10251/metrics\" sshResult, err := measurementutil.SSH(cmd, host+\":22\", provider) if err != nil || sshResult.Code != 0 { return \"\", fmt.Errorf(\"unexpected error (code: %d)","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/:5:5","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"6. 测试结果指标异常输出 不是问题，这是测试工具成功生效，并返回提示断言信息 I1214 15:25:56.117594 96634 wait_for_controlled_pods.go:235] WaitForControlledPodsRunning: running 0, deleted 2, timeout: 0, unknown: 0 I1214 15:25:56.117625 96634 wait_for_controlled_pods.go:249] WaitForControlledPodsRunning: 0/0 ReplicationControllers are running with all pods I1214 15:25:56.124212 96634 simple_test_executor.go:128] Step \"Deleting saturation pods\" ended I1214 15:25:56.245924 96634 api_responsiveness.go:119] APIResponsiveness: WARNING Top latency metric: {Resource:endpoints Subresource: Verb:PUT Scope:namespace Latency:{Perc50:2.65ms Perc90:22.594ms Perc99:1.122221s} Count:22}; threshold: 1s I1214 15:25:56.245949 96634 api_responsiveness.go:119] APIResponsiveness: WARNING Top latency metric: {Resource:namespaces Subresource: Verb:GET Scope:cluster Latency:{Perc50:11.99ms Perc90:1.005472s Perc99:1.084129s} Count:13}; threshold: 1s I1214 15:25:56.245957 96634 api_responsiveness.go:119] APIResponsiveness: WARNING Top latency metric: {Resource:nodes Subresource:status Verb:PATCH Scope:cluster Latency:{Perc50:1.00345s Perc90:1.00345s Perc99:1.00345s} Count:1}; threshold: 1s I1214 15:25:56.245962 96634 api_responsiveness.go:119] APIResponsiveness: Top latency metric: {Resource:pods Subresource:status Verb:PATCH Scope:namespace Latency:{Perc50:3.777ms Perc90:13.656ms Perc99:173.072ms} Count:88}; threshold: 1s I1214 15:25:56.245966 96634 api_responsiveness.go:119] APIResponsiveness: Top latency metric: {Resource:pods Subresource: Verb:GET Scope:namespace Latency:{Perc50:1.88ms Perc90:11.522ms Perc99:87.668ms} Count:156}; threshold: 1s I1214 15:25:56.821263 96634 resource_usage.go:124] ResourceUsageSummary: gathering resource usage... I1214 15:25:56.823909 96634 container_resource_gatherer.go:172] Closed stop channel. Waiting for 1 workers I1214 15:25:56.824075 96634 resource_gather_worker.go:90] Closing worker for node1 I1214 15:25:56.824118 96634 container_resource_gatherer.go:180] Waitgroup finished. I1214 15:25:56.824313 96634 system_pod_metrics.go:82] skipping collection of system pod metrics I1214 15:26:06.865304 96634 simple_test_executor.go:345] Resources cleanup time: 10.040658542s E1214 15:26:06.865325 96634 clusterloader.go:177] -------------------------------------------------------------------------------- E1214 15:26:06.865328 96634 clusterloader.go:178] Test Finished E1214 15:26:06.865330 96634 clusterloader.go:179] Test: /home/wangb/perf-test/clusterloader2/testing/density/config2.yaml E1214 15:26:06.865335 96634 clusterloader.go:180] Status: Fail E1214 15:26:06.865338 96634 clusterloader.go:182] Errors: [measurement call APIResponsiveness - APIResponsiveness error: top latency metric: there should be no high-latency requests, but: [got: {Resource:endpoints Subresource: Verb:PUT Scope:namespace Latency:{Perc50:2.65ms Perc90:22.594ms Perc99:1.122221s} Count:22}; expected perc99 \u003c= 1s got: {Resource:namespaces Subresource: Verb:GET Scope:cluster Latency:{Perc50:11.99ms Perc90:1.005472s Perc99:1.084129s} Count:13}; expected perc99 \u003c= 1s got: {Resource:nodes Subresource:status Verb:PATCH Scope:cluster Latency:{Perc50:1.00345s Perc90:1.00345s Perc99:1.00345s} Count:1}; expected perc99 \u003c= 1s]] E1214 15:26:06.865341 96634 clusterloader.go:184] -------------------------------------------------------------------------------- F1214 15:26:06.866736 96634 clusterloader.go:276] 1 tests have failed! 由上看出，由于时延性能指标超过门限值1s，测试工具认为测试不通过。 修改下 测试配置文件中的PODS_PER_NODE参数，由10改为2，负载变小，则测试通过 I1214 15:35:53.874477 111782 wait_for_controlled_pods.go:235] WaitForControlledPodsRunning: running 0, deleted 2, timeout: 0, unknown: 0 I1214 15:35:53.874751 111782 wait_for_controlled_pods.go:249] WaitForControlledPodsRunning: 0/0 ReplicationControllers are running with all pods I1214 15:35:53.874765 111782 simple_test_executor.go:128] Step \"Deleting saturation pods\" ended I1214 15:35:53.956315 111782 api_responsiveness.go:119] APIResponsiveness: Top latency metric: {Resource:replicationcontrollers Su","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/:5:6","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"6 总结 perf-test clusterloader2工具主要提供了性能压测，可配置性好，方便编写测试用例，并且统计了相应的性能指标 clusterloader2内置实现了k8s指标采集处理和指标阈值定义，参考文档：Kubernetes scalability and performance SLIs/SLOs clusterloader2没有详细的使用说明文档，目前来看不是可以拿来直接运行使用。所遇到问题一般只能依靠自己解决。 由于上面第3点，所遇问题较多，一般多涉及测试工具环境配置参数，另外clusterloader2对一些参数使用的是硬编码方式，导致无法直接使用原有工具，只能修改源码进行测试适配。 测试使用clusterloader2，需要详细了解其设计方案，才能运行测试用例 进行集群测试，需要了解集群测试指标定义，再编写测试配置 测试时需要预估下测试pod数量和内存占用情况，否则会引起OOM。 clusterloader2并不是一个拿来即用的测试工具，还需结合测试环境进行改造适配，更像是K8S内部使用的类似脚手架的东西 ","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/:6:0","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"7 附录 参考命令 批量删除k8s测试命名空间及其资源，这里测试数据默认使用了test-开头的命令规则 kubectl get ns |grep test- |awk '{print $1}' |xargs kubectl delete ns --force --grace-period=0 测试中如果出现异常，系统会残留有测试使用的资源参数，这里需要对实际情况进行调整 测试完成后的测试资源清理（如果测试后有测试数据资源残留的话）： 测试ns、rc、pod清理 hollow-node 桩节点清理 K8S的SLI (服务等级指标) 和 SLO (服务等级目标) Kubernetes 社区提供了 SLI (服务等级指标) 和 SLO (服务等级目标) 系统性能测试、分析文档 Kubernetes scalability and performance SLIs/SLOs。模拟出一个 K8s cluster（Kubemark cluster），不受资源限制。cluster 中 master 是真实的机器，所有的 nodes 是 Hollow nodes。Hollow nodes 不会调用Docker，测试一套 K8s API 调用的完整流程，不会真正创建 pod。 社区开发了 perf-test/clusterloader2，可配置性好，并且统计了相应的性能指标 kubemark 不调用 CRI 接口之外，其它行为和 kubelet 基本一致 ","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/:7:0","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"Etcd监控指标 参考: https://github.com/coreos/etcd/blob/master/Documentation/metrics.md 领导者相关 etcd_server_has_leader etcd是否有leader etcd_server_leader_changes_seen_total etcd的leader变换次数 etcd_debugging_mvcc_db_total_size_in_bytes 数据库的大小 process_resident_memory_bytes 进程驻留内存 网络相关 grpc_server_started_total grpc(高性能、开源的通用RPC(远程过程调用)框架)服务器启动总数 etcd_network_client_grpc_received_bytes_total 接收到grpc客户端的字节总数 etcd_network_client_grpc_sent_bytes_total 发送给grpc客户端的字节总数 etcd_network_peer_received_bytes_total etcd网络对等方接收的字节总数(对等网络，即对等计算机网络，是一种在对等者（Peer）之间分配任务和工作负载的分布式应用架构，是对等计算模型在应用层形成的一种组网或网络形式) etcd_network_peer_sent_bytes_total etcd网络对等方发送的字节总数 提案相关 etcd_server_proposals_failed_total 目前正在处理的提案(提交会议讨论决定的建议。)数量 etcd_server_proposals_pending 失败提案总数 etcd_server_proposals_committed_total 已落实共识提案的总数。 etcd_server_proposals_applied_total 已应用的共识提案总数。 这些指标描述了磁盘操作的状态。 etcd_disk_backend_commit_duration_seconds_sum etcd磁盘后端提交持续时间秒数总和 etcd_disk_backend_commit_duration_seconds_bucket etcd磁盘后端提交持续时间 快照 etcd_debugging_snap_save_total_duration_seconds_sum etcd快照保存用时 文件 process_open_fds{service=“etcd-k8s”} 打开文件描述符的数量 process_max_fds{service=“etcd-k8s”} 打开文件描述符的最大数量 etcd_disk_wal_fsync_duration_seconds_sum Wal(预写日志系统)调用的fsync(将文件数据同步到硬盘)的延迟分布 etcd_disk_wal_fsync_duration_seconds_bucket 后端调用的提交的延迟分布 参考文章 Kubernetes测试系列 - 性能测试 kubernetes性能指标体系：clusterloader2 clusterloader2的漫漫踩坑路：最详细解析与使用指南 clusterloader2设计说明：Cluster loader vision etcd指标监控，参考文章 ","date":"2020-12-15","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/:7:1","tags":["K8S"],"title":"K8S集群性能测试-clusterloader","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-clusterloader/"},{"categories":["K8S"],"content":"了解如何使用kubemark对k8s组件进行性能测试","date":"2020-12-08","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/","tags":["K8S"],"title":"K8S集群性能测试-kubemark","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/"},{"categories":["K8S"],"content":"了解如何使用kubemark对k8s组件进行性能测试 ","date":"2020-12-08","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/:0:0","tags":["K8S"],"title":"K8S集群性能测试-kubemark","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/"},{"categories":["K8S"],"content":"1 背景 项目想对k8s组件进行集群性能测试。原有组件如调度器，已有的测试工具多是单元测试。需要寻找一种可以对k8s集群进行性能测试。比如多多节点大集群规模下的调度器性能指标如何？ 考虑使用k8s项目自带的性能测试组件kubemark。 ","date":"2020-12-08","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/:1:0","tags":["K8S"],"title":"K8S集群性能测试-kubemark","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/"},{"categories":["K8S"],"content":"2 kubemark ","date":"2020-12-08","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/:2:0","tags":["K8S"],"title":"K8S集群性能测试-kubemark","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/"},{"categories":["K8S"],"content":"介绍 kubemark 是 K8s 官方给出的性能测试工具，能够不受任何资源限制，模拟出一个大规模 K8s 集群。其主要架构如图所示:需要一个外部 K8s 集群（external cluster） 以及一个机器节点运行 kubemark master，即另外一个 K8s 集群，但是只有一个 master 节点。我们需要在 external cluster 中部署运行 hollow pod，这些 pod 会主动向 kubemark 集群注册，并成为 kubemark 集群中的 hollow node(虚拟节点)。然后我们就可以在 kubemark 集群中进行 e2e 测试。虽然与真实集群的稍微有点误差，不过可以代表真实集群的数据。 本文则只构造了kubemark组件，且只使用了测试集群，即外部 K8s 集群（external cluster），未使用第2个kubemark集群。目的为测试集群中的master组件，如调度器和控制器等。另外，此方式还可以自己使用第三方测试工具和框架 ","date":"2020-12-08","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/:2:1","tags":["K8S"],"title":"K8S集群性能测试-kubemark","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/"},{"categories":["K8S"],"content":"kubemark构造 1. 编译kubemark 在 K8s 源码路径下构建 kubemark，生成的二进制文件在 _output/bin 目录下。 # KUBE_BUILD_PLATFORMS=linux/amd64 make kubemark GOFLAGS=-v GOGCFLAGS=\"-N -l\" make kubemark GOGCFLAGS=\"-N -l\" 2. 构建kubemark镜像 将生成的 kubemark 二进制文件从 _output/bin 复制到 cluster/images/kubemark 目录下。 cp _output/bin/kubemark cluster/images/kubemark/ 并在该目录下执行构建镜像命令，生成镜像：staging-registry.cn-hangzhou.aliyuncs.com/google_containers/kubemark:v1.14.8。 # IMAGE_TAG=v1.14.3 make build cd cluster/images/kubemark/ IMAGE_TAG=v1.14.8 make build 3. 保存镜像至kubemark.tar 4. kubemark部署到测试集群 在测试集群中的所有node节点中，导入该kubemark镜像。用于启动桩节点。 接下来进行桩节点hollow-node启动配置操作 # 以下命令在测试集群的master节点上执行 # 从kubemark-master节点（191节点）拷贝过来kubeconfig文件，到测试集群的master节点中 scp -r 192.168.182.191:/root/.kube/config /home/wangb/ kubectl create ns kubemark kubectl create configmap node-configmap -n kubemark --from-literal=content.type=\"test-cluster\" # kubectl create secret generic kubeconfig --type=Opaque --namespace=kubemark --from-file=kubelet.kubeconfig=config --from-file=kubeproxy.kubeconfig=config kubectl create secret generic kubeconfig --type=Opaque --namespace=kubemark --from-file=kubelet.kubeconfig=/root/.kube/config --from-file=kubeproxy.kubeconfig=/root/.kube/config 5. 在测试集群中启动hollow nodes kubectl create -f hollow-node-sts.yaml -n kubemark ","date":"2020-12-08","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/:2:2","tags":["K8S"],"title":"K8S集群性能测试-kubemark","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/"},{"categories":["K8S"],"content":"测试pod 启动桩节点，hollow-node-sts.yaml的默认配置如下： apiVersion:v1kind:Servicemetadata:name:hollow-nodenamespace:kubemarkspec:clusterIP:Noneports:- port:80protocol:TCPtargetPort:80selector:name:hollow-node---apiVersion:apps/v1kind:StatefulSetmetadata:name:hollow-nodenamespace:kubemarkspec:podManagementPolicy:Parallelreplicas:6selector:matchLabels:name:hollow-nodeserviceName:hollow-nodetemplate:metadata:labels:name:hollow-nodespec:initContainers:- name:init-inotify-limitimage:docker.io/busybox:latestimagePullPolicy:IfNotPresentcommand:['sysctl','-w','fs.inotify.max_user_instances=200']securityContext:privileged:truevolumes:- name:kubeconfig-volumesecret:secretName:kubeconfig- name:logs-volumehostPath:path:/var/logcontainers:- name:hollow-kubeletimage:staging-registry.cn-hangzhou.aliyuncs.com/google_containers/kubemark:v1.14.8imagePullPolicy:IfNotPresentports:- containerPort:4194- containerPort:10250- containerPort:10255env:- name:CONTENT_TYPEvalueFrom:configMapKeyRef:name:node-configmapkey:content.type- name:NODE_NAMEvalueFrom:fieldRef:fieldPath:metadata.namecommand:- /bin/sh- -c- /kubemark --morph=kubelet --name=$(NODE_NAME) --kubeconfig=/kubeconfig/kubelet.kubeconfig $(CONTENT_TYPE) --alsologtostderr --v=2volumeMounts:- name:kubeconfig-volumemountPath:/kubeconfigreadOnly:true- name:logs-volumemountPath:/var/logresources:requests:cpu:20mmemory:50MsecurityContext:privileged:true- name:hollow-proxyimage:staging-registry.cn-hangzhou.aliyuncs.com/google_containers/kubemark:v1.14.8imagePullPolicy:IfNotPresentenv:- name:CONTENT_TYPEvalueFrom:configMapKeyRef:name:node-configmapkey:content.type- name:NODE_NAMEvalueFrom:fieldRef:fieldPath:metadata.namecommand:- /bin/sh- -c- /kubemark --morph=proxy --name=$(NODE_NAME) --use-real-proxier=false --kubeconfig=/kubeconfig/kubeproxy.kubeconfig $(CONTENT_TYPE) --alsologtostderr --v=2volumeMounts:- name:kubeconfig-volumemountPath:/kubeconfigreadOnly:true- name:logs-volumemountPath:/var/logresources:requests:cpu:20mmemory:50Mtolerations:- effect:NoExecutekey:node.kubernetes.io/unreachableoperator:Exists- effect:NoExecutekey:node.kubernetes.io/not-readyoperator:Existsaffinity:nodeAffinity:requiredDuringSchedulingIgnoredDuringExecution:# 硬策略nodeSelectorTerms:- matchExpressions:- key:nameoperator:NotInvalues:- hollow-node- key:node-role.kubernetes.io/masteroperator:NotInvalues:- \"true\" 由上可知，hollow-node实际上是启动过了kubelet和proxy的2个进程，后来分析源码确实如此。 写个测试pod，验证桩node是否可用，test-pod.yaml如下 apiVersion:v1kind:Podmetadata:name:myapp-podlabels:app:myappversion:v1spec:containers:- name:appimage:docker.io/busybox:latestimagePullPolicy:IfNotPresentcommand:['sleep','3600']securityContext:privileged:trueaffinity:nodeAffinity:requiredDuringSchedulingIgnoredDuringExecution:# 硬策略nodeSelectorTerms:- matchExpressions:- key:node-role.kubernetes.io/nodeoperator:NotInvalues:- \"true\" 节点信息 hollow-node-0, 此信息为默认信息 Name: hollow-node-0 Roles: \u003cnone\u003e Labels: beta.kubernetes.io/arch=amd64 beta.kubernetes.io/os=linux kubernetes.io/arch=amd64 kubernetes.io/hostname=hollow-node-0 kubernetes.io/os=linux Annotations: node.alpha.kubernetes.io/ttl: 0 CreationTimestamp: Mon, 07 Dec 2020 17:25:15 +0800 Taints: \u003cnone\u003e Unschedulable: false Conditions: Type Status LastHeartbeatTime LastTransitionTime Reason Message ---- ------ ----------------- ------------------ ------ ------- MemoryPressure False Tue, 08 Dec 2020 09:37:21 +0800 Mon, 07 Dec 2020 17:25:15 +0800 KubeletHasSufficientMemory kubelet has sufficient memory available DiskPressure False Tue, 08 Dec 2020 09:37:21 +0800 Mon, 07 Dec 2020 17:25:15 +0800 KubeletHasNoDiskPressure kubelet has no disk pressure PIDPressure False Tue, 08 Dec 2020 09:37:21 +0800 Mon, 07 Dec 2020 17:25:15 +0800 KubeletHasSufficientPID kubelet has sufficient PID available Ready True Tue, 08 Dec 2020 09:37:21 +0800 Mon, 07 Dec 2020 17:25:15 +0800 KubeletReady kubelet is posting ready status Addresses: InternalIP: 10.233.96.39 Hostname: hollow-node-0 Capacity: cpu: 1 ephemeral-storage: 0 memory: 3840Mi pods: 110 Allocatable: cpu: 1 ","date":"2020-12-08","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/:2:3","tags":["K8S"],"title":"K8S集群性能测试-kubemark","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/"},{"categories":["K8S"],"content":"kubemark源码 程序入口 kubemark根据参数Morph，可执行kubelet和proxy流程，从而实现节点组件功能。 cmd/kubemark/hollow-node.go func run(config *hollowNodeConfig) { if !knownMorphs.Has(config.Morph) { klog.Fatalf(\"Unknown morph: %v. Allowed values: %v\", config.Morph, knownMorphs.List()) } // create a client to communicate with API server. clientConfig, err := config.createClientConfigFromFile() if err != nil { klog.Fatalf(\"Failed to create a ClientConfig: %v. Exiting.\", err) } client, err := clientset.NewForConfig(clientConfig) if err != nil { klog.Fatalf(\"Failed to create a ClientSet: %v. Exiting.\", err) } if config.Morph == \"kubelet\" { cadvisorInterface := \u0026cadvisortest.Fake{ NodeName: config.NodeName, } containerManager := cm.NewStubContainerManager() fakeDockerClientConfig := \u0026dockershim.ClientConfig{ DockerEndpoint: libdocker.FakeDockerEndpoint, EnableSleep: true, WithTraceDisabled: true, } hollowKubelet := kubemark.NewHollowKubelet( config.NodeName, client, cadvisorInterface, fakeDockerClientConfig, config.KubeletPort, config.KubeletReadOnlyPort, containerManager, maxPods, podsPerCore, ) hollowKubelet.Run() } if config.Morph == \"proxy\" { client, err := clientset.NewForConfig(clientConfig) if err != nil { klog.Fatalf(\"Failed to create API Server client: %v\", err) } iptInterface := fakeiptables.NewFake() sysctl := fakesysctl.NewFake() execer := \u0026fakeexec.FakeExec{} eventBroadcaster := record.NewBroadcaster() recorder := eventBroadcaster.NewRecorder(legacyscheme.Scheme, v1.EventSource{Component: \"kube-proxy\", Host: config.NodeName}) hollowProxy, err := kubemark.NewHollowProxyOrDie( config.NodeName, client, client.CoreV1(), iptInterface, sysctl, execer, eventBroadcaster, recorder, config.UseRealProxier, config.ProxierSyncPeriod, config.ProxierMinSyncPeriod, ) if err != nil { klog.Fatalf(\"Failed to create hollowProxy instance: %v\", err) } hollowProxy.Run() } } hollow_kubelet pkg/kubemark/hollow_kubelet type HollowKubelet struct { KubeletFlags *options.KubeletFlags KubeletConfiguration *kubeletconfig.KubeletConfiguration KubeletDeps *kubelet.Dependencies } func NewHollowKubelet( nodeName string, client *clientset.Clientset, cadvisorInterface cadvisor.Interface, dockerClientConfig *dockershim.ClientConfig, kubeletPort, kubeletReadOnlyPort int, containerManager cm.ContainerManager, maxPods int, podsPerCore int, ) *HollowKubelet { // ----------------- // Static config // ----------------- f, c := GetHollowKubeletConfig(nodeName, kubeletPort, kubeletReadOnlyPort, maxPods, podsPerCore) // ----------------- // Injected objects // ----------------- volumePlugins := emptydir.ProbeVolumePlugins() volumePlugins = append(volumePlugins, secret.ProbeVolumePlugins()...) volumePlugins = append(volumePlugins, projected.ProbeVolumePlugins()...) d := \u0026kubelet.Dependencies{ KubeClient: client, HeartbeatClient: client, DockerClientConfig: dockerClientConfig, CAdvisorInterface: cadvisorInterface, Cloud: nil, OSInterface: \u0026containertest.FakeOS{}, ContainerManager: containerManager, VolumePlugins: volumePlugins, TLSOptions: nil, OOMAdjuster: oom.NewFakeOOMAdjuster(), Mounter: mount.New(\"\" /* default mount path */), Subpather: \u0026subpath.FakeSubpath{}, } return \u0026HollowKubelet{ KubeletFlags: f, KubeletConfiguration: c, KubeletDeps: d, } } // Starts this HollowKubelet and blocks. func (hk *HollowKubelet) Run() { if err := kubeletapp.RunKubelet(\u0026options.KubeletServer{ KubeletFlags: *hk.KubeletFlags, KubeletConfiguration: *hk.KubeletConfiguration, }, hk.KubeletDeps, false); err != nil { klog.Fatalf(\"Failed to run HollowKubelet: %v. Exiting.\", err) } select {} } hollow_proxy pkg/kubemark/hollow_proxy type HollowProxy struct { ProxyServer *proxyapp.ProxyServer } type FakeProxier struct{} func (*FakeProxier) Sync() {} func (*FakeProxier) SyncLoop() { select {} } func (*FakeProxier) OnServiceAdd(service *v1.Service) {} func (*FakeProxier) OnServiceUpdate(oldService, service *v1.Service) {} func (*FakeProxier) OnServiceDelete(service *v1.Service) {} func (*FakeProxier) OnServiceSynced() {} func ","date":"2020-12-08","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/:2:4","tags":["K8S"],"title":"K8S集群性能测试-kubemark","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/"},{"categories":["K8S"],"content":"kubemark总结 kubemark实际上是个K8S组件，包含了kubelet和一个controller，模拟桩节点主要使用了kubelet功能。 kubemark通过在真实节点上构造批量的hollow-node的pod方式，模拟运行了大量的桩节点。这些桩节点可以定时跟master同步状态和信息。 kubemark一般用于测试master节点上的组件的性能测试，比如测试调度器和控制器组件性能。 kubemark由于其构造方式，决定其不能测试node节点组件，比如kubelet性能和网络等。 ","date":"2020-12-08","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/:2:5","tags":["K8S"],"title":"K8S集群性能测试-kubemark","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/"},{"categories":["K8S"],"content":"3 测试框架 可参考k8s的perf-test Kubernetes测试系列 - 性能测试 kubernetes性能指标体系：clusterloader2 clusterloader2的漫漫踩坑路：最详细解析与使用指南 clusterloader2设计说明：Cluster loader vision ","date":"2020-12-08","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/:3:0","tags":["K8S"],"title":"K8S集群性能测试-kubemark","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/"},{"categories":["K8S"],"content":"4 问题 ","date":"2020-12-08","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/:4:0","tags":["K8S"],"title":"K8S集群性能测试-kubemark","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/"},{"categories":["K8S"],"content":"kubemark的hollow node 启动后，报错： 此时node状态为为not ready I0223 04:37:53.577861 6 kubelet_node_status.go:468] Recording NodeHasSufficientPID event message for node hollow-node-1 I0223 04:37:53.577871 6 kubelet_node_status.go:468] Recording NodeNotReady event message for node hollow-node-1 I0223 04:37:53.577879 6 setters.go:526] Node became not ready: {Type:Ready Status:False LastHeartbeatTime:2021-02-23 04:37:53.577865902 +0000 UTC m=+46.268886946 LastTransitionTime:2021-02-23 04:37:53.577865902 +0000 UTC m=+46.268886946 Reason:KubeletNotReady Message:Missing node capacity for resources: pods} I0223 04:37:53.640378 6 reconciler.go:154] Reconciler: start to sync state 编译kubemark时，需要设置nodesstatus的maxpods数量 v1.ResourcePods: *resource.NewQuantity(maxpods, resource.DecimalSI) ","date":"2020-12-08","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/:4:1","tags":["K8S"],"title":"K8S集群性能测试-kubemark","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/"},{"categories":["K8S"],"content":"如果启动kubemark的hollow node 状态为not ready，查看log报错信息 E0223 06:15:30.382797 6 reflector.go:126] k8s.io/kubernetes/pkg/kubelet/config/apiserver.go:47: Failed to list *v1.Pod: Get \"https://192.168.182.101:6443/api/v1/pods?fieldSelector=spec.nodeName%3Dhollow-node-0\u0026limit=500\u0026resourceVersion=0\": dial tcp 192.168.182.101:6443: i/o timeout I0223 06:15:30.383089 6 trace.go:81] Trace[432657393]: \"Reflector k8s.io/kubernetes/pkg/kubelet/kubelet.go:451 ListAndWatch\" (started: 2021-02-23 06:15:00.377839254 +0000 UTC m=+0.144897671) (total time: 30.005174003s): Trace[432657393]: [30.005174003s] [30.005174003s] END E0223 06:15:30.383123 6 reflector.go:126] k8s.io/kubernetes/pkg/kubelet/kubelet.go:451: Failed to list *v1.Node: Get \"https://192.168.182.101:6443/api/v1/nodes?fieldSelector=metadata.name%3Dhollow-node-0\u0026limit=500\u0026resourceVersion=0\": dial tcp 192.168.182.101:6443: i/o timeout E0223 06:15:30.402640 6 kubelet.go:2246] node \"hollow-node-0\" not found E0223 06:15:30.502860 6 kubelet.go:2246] node \"hollow-node-0\" not found 此时可能为网络原因，停止kubelet和docker服务，清理下网络即可解决 ","date":"2020-12-08","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/:4:2","tags":["K8S"],"title":"K8S集群性能测试-kubemark","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/"},{"categories":["K8S"],"content":"5 附录 参考操作命令。。。 [root@test-master ~]# kubectl get secret -A |grep kubeconfig kubemark kubeconfig Opaque 2 94s [root@test-master ~]# kubectl describe secret -nkubemark kubeconfig Name: kubeconfig Namespace: kubemark Labels: \u003cnone\u003e Annotations: \u003cnone\u003e Type: Opaque Data ==== kubelet.kubeconfig: 5463 bytes kubeproxy.kubeconfig: 5463 bytes #### 如果要删除刚刚创建的secret和 configmap kubectl delete secret -nkubemark kubeconfig kubectl delete configmap -n kubemark node-configmap kubectl delete ns kubemark --force --grace-period=0 #### 强制删除资源 kubectl delete po --force --grace-period=0 -nkube-system kube-proxy-p6k42 ### 删除kubemark命名空间下所有node资源 kubectl delete no --all -n kubemark #### 设置master节点不可调度 # kubectl cordon nodename kubectl cordon node1 # kubectl uncordon nodename #取消 #### 节点打标签 kubectl label node node1 accessswitch=switch1 kubectl label node node1 groupId=defaultGroup kubectl label node node1 node-role.kubernetes.io/master=true kubectl label node node1 node-role.kubernetes.io/node=true kubectl label node node1 switchtype=ether kubectl label node node2 accessswitch=switch1 kubectl label node node2 groupId=defaultGroup kubectl label node node2 node-role.kubernetes.io/node=true kubectl label node node2 switchtype=ether 修改hollow-node信息，不是node的全部信息都可以修改更新，如capacity等字段无法更新 kubectl patch node hollow-node-0 -p '{\"spec\":{\"unschedulable\":true}}' e2e测试 编译e2e.test make WHAT=“test/e2e/e2e.test” # 进入k8s项目，进行测试工具编译 make WHAT=\"test/e2e/e2e.test\" # 在目录下能够看到输出文件如下： [root@node1 k8s1.14.8modify-wangb]# ll _output/bin/ -h total 241M -rwxr-xr-x. 1 root root 5.9M Dec 7 10:04 conversion-gen -rwxr-xr-x. 1 root root 5.9M Dec 7 10:04 deepcopy-gen -rwxr-xr-x. 1 root root 5.9M Dec 7 10:04 defaulter-gen -rwxr-xr-x. 1 root root 110M Dec 7 17:01 e2e.test -rwxr-xr-x. 1 root root 3.5M Dec 7 10:04 go2make -rwxr-xr-x. 1 root root 2.0M Dec 7 10:04 go-bindata -rwxr-xr-x. 1 root root 99M Dec 7 10:05 kubemark -rwxr-xr-x. 1 root root 10M Dec 7 10:04 openapi-gen # 把 e2e.test 文件拷贝到测试集群的master节点上 需要注意：网上的搜到的文章大多数都是编译e2e的二进制文件直接运行 #./e2e.test --kube-master=192.168.182.101 --host=https://192.168.182.101:6443 --ginkgo.focus=\"\\[Performance\\]\" --provider=local --kubeconfig=kubemark.kubeconfig --num-nodes=10 --v=3 --ginkgo.failFast --e2e-output-dir=. --report-dir=. ./e2e.test --kube-master=192.168.182.101 --host=https://192.168.182.101:6443 --ginkgo.focus=\"\\[Performance\\]\" --provider=local --kubeconfig=/root/.kube/config --num-nodes=4 --v=3 --ginkgo.failFast --e2e-output-dir=. --report-dir=. 但其实e2e的性能用例已经被移出主库了 https://github.com/kubernetes/kubernetes/pull/83322，所以在2019.10.1之后出的版本用上面的命令是无法运行性能测试的 Deployment中pod创建的流程 apiserver收到创建deployment的请求，存储至etcd，告知controller-manager controller-manager创建pod的壳子，打上creationTimeStamp，发送请求到apiserver apiserver收到创建pod的请求，发送至etcd，推送到scheduler。 schduler选择node，填充nodeName，向apiserver更新pod信息。此时pod处于pending状态，pod也没有真正创建。 apiserver向etcd更新pod信息，同时推送到相应节点的kubelet kubelet创建pod，填充HostIP与resourceVersion，向apiserver发送更新请求，pod处于pending状态 apiserver更新pod信息至etcd，同时kubelet继续创建pod。等到容器都处于running状态，kubelet再次发送pod的更新请求给apiserver，此时pod running apiserver收到请求，更新到etcd中，并推送到informer中，informer记录下watchPhase ","date":"2020-12-08","objectID":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/:5:0","tags":["K8S"],"title":"K8S集群性能测试-kubemark","uri":"/posts/2020/12/k8s%E9%9B%86%E7%BE%A4%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-kubemark/"},{"categories":["音乐"],"content":"收集了一些经典好吹的口琴谱子，【持续更新。。。】","date":"2018-09-26","objectID":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/","tags":["音乐","口琴"],"title":"口琴简谱集","uri":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/"},{"categories":["音乐"],"content":"收集了一些经典好吹的口琴谱子，【持续更新。。。】 ","date":"2018-09-26","objectID":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/:0:0","tags":["音乐","口琴"],"title":"口琴简谱集","uri":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/"},{"categories":["音乐"],"content":"布鲁斯口琴C调第1把位音阶图 ","date":"2018-09-26","objectID":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/:1:0","tags":["音乐","口琴"],"title":"口琴简谱集","uri":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/"},{"categories":["音乐"],"content":"送别 ","date":"2018-09-26","objectID":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/:2:0","tags":["音乐","口琴"],"title":"口琴简谱集","uri":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/"},{"categories":["音乐"],"content":"爱尔兰画眉 ","date":"2018-09-26","objectID":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/:3:0","tags":["音乐","口琴"],"title":"口琴简谱集","uri":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/"},{"categories":["音乐"],"content":"天空之城 ","date":"2018-09-26","objectID":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/:4:0","tags":["音乐","口琴"],"title":"口琴简谱集","uri":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/"},{"categories":["音乐"],"content":"星之所在 ","date":"2018-09-26","objectID":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/:5:0","tags":["音乐","口琴"],"title":"口琴简谱集","uri":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/"},{"categories":["音乐"],"content":"追梦人 ","date":"2018-09-26","objectID":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/:6:0","tags":["音乐","口琴"],"title":"口琴简谱集","uri":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/"},{"categories":["音乐"],"content":"平凡之路 ","date":"2018-09-26","objectID":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/:7:0","tags":["音乐","口琴"],"title":"口琴简谱集","uri":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/"},{"categories":["音乐"],"content":"喀秋莎 ","date":"2018-09-26","objectID":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/:8:0","tags":["音乐","口琴"],"title":"口琴简谱集","uri":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/"},{"categories":["音乐"],"content":"三套车 ","date":"2018-09-26","objectID":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/:9:0","tags":["音乐","口琴"],"title":"口琴简谱集","uri":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/"},{"categories":["音乐"],"content":"啊，朋友再见 ","date":"2018-09-26","objectID":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/:10:0","tags":["音乐","口琴"],"title":"口琴简谱集","uri":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/"},{"categories":["音乐"],"content":"The girl I left behind me 演奏视频地址 ","date":"2018-09-26","objectID":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/:11:0","tags":["音乐","口琴"],"title":"口琴简谱集","uri":"/posts/2018/09/%E5%8F%A3%E7%90%B4%E7%AE%80%E8%B0%B1%E9%9B%86/"},{"categories":["Linux"],"content":" 配置国内阿里yum源 ","date":"2017-06-26","objectID":"/posts/2017/06/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/:0:0","tags":["Linux"],"title":"centos7切换国内yum源","uri":"/posts/2017/06/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/"},{"categories":["Linux"],"content":"yum源配置步骤 根据官网的说明，分别有 CentOS 6、CentOS 7、CentOS 8等配置操作步骤。 ","date":"2017-06-26","objectID":"/posts/2017/06/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/:1:0","tags":["Linux"],"title":"centos7切换国内yum源","uri":"/posts/2017/06/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/"},{"categories":["Linux"],"content":"1. 备份操作 备份，将 CentOS-Base.repo 为CentOS-Base.repo.backup mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup ","date":"2017-06-26","objectID":"/posts/2017/06/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/:1:1","tags":["Linux"],"title":"centos7切换国内yum源","uri":"/posts/2017/06/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/"},{"categories":["Linux"],"content":"2. 下载yum源配置文件 下载新的 http://mirrors.aliyun.com/repo/Centos-7.repo，并命名为CentOS-Base.repo wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 或者 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo ","date":"2017-06-26","objectID":"/posts/2017/06/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/:1:2","tags":["Linux"],"title":"centos7切换国内yum源","uri":"/posts/2017/06/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/"},{"categories":["Linux"],"content":"3. 清除缓存 # 清除系统所有的yum缓存 yum clean all # 生成yum缓存 yum makecache ","date":"2017-06-26","objectID":"/posts/2017/06/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/:1:3","tags":["Linux"],"title":"centos7切换国内yum源","uri":"/posts/2017/06/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/"},{"categories":["Linux"],"content":"epel源 安装和配置 ","date":"2017-06-26","objectID":"/posts/2017/06/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/:2:0","tags":["Linux"],"title":"centos7切换国内yum源","uri":"/posts/2017/06/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/"},{"categories":["Linux"],"content":"1. 查看可用的epel源 yum list | grep epel-release 示例： [java@localhost yum.repos.d]$ yum list | grep epel-release epel-release.noarch 7-11 extras [java@localhost yum.repos.d]$ ","date":"2017-06-26","objectID":"/posts/2017/06/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/:2:1","tags":["Linux"],"title":"centos7切换国内yum源","uri":"/posts/2017/06/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/"},{"categories":["Linux"],"content":"2. 安装 epel yum install -y epel-release ","date":"2017-06-26","objectID":"/posts/2017/06/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/:2:2","tags":["Linux"],"title":"centos7切换国内yum源","uri":"/posts/2017/06/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/"},{"categories":["Linux"],"content":"3. 配置阿里镜像提供的epel源 wget -O /etc/yum.repos.d/epel-7.repo http://mirrors.aliyun.com/repo/epel-7.repo 或者 curl -o /etc/yum.repos.d/epel-7.repo http://mirrors.aliyun.com/repo/epel-7.repo ","date":"2017-06-26","objectID":"/posts/2017/06/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/:2:3","tags":["Linux"],"title":"centos7切换国内yum源","uri":"/posts/2017/06/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/"},{"categories":["Linux"],"content":"4. 清除缓存 # 清除系统所有的yum缓存 yum clean all # 生成yum缓存 yum makecache ","date":"2017-06-26","objectID":"/posts/2017/06/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/:2:4","tags":["Linux"],"title":"centos7切换国内yum源","uri":"/posts/2017/06/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/"},{"categories":["Linux"],"content":"5. 其它命令 #查看所有的yum源： yum repolist all #查看可用的yum源： yum repolist enabled ","date":"2017-06-26","objectID":"/posts/2017/06/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/:2:5","tags":["Linux"],"title":"centos7切换国内yum源","uri":"/posts/2017/06/centos7%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85yum%E6%BA%90/"},{"categories":["Python"],"content":" 用 virtualenv 来管理多个开发环境，virtualenvwrapper 使得virtualenv变得更好用 ","date":"2017-04-28","objectID":"/posts/2017/04/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:0","tags":["Python"],"title":"Python虚拟环境搭建","uri":"/posts/2017/04/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Python"],"content":"python虚拟环境搭建 # 安装虚拟环境 pip install virtualenv ","date":"2017-04-28","objectID":"/posts/2017/04/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:0","tags":["Python"],"title":"Python虚拟环境搭建","uri":"/posts/2017/04/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Python"],"content":"安装配置 安装: (sudo) pip install virtualenv virtualenvwrapper Linux/Mac OSX 下： 修改~/.bash_profile或其它环境变量相关文件(如 .bashrc 或用 ZSH 之后的 .zshrc)，添加以下语句 export WORKON_HOME=$HOME/.virtualenvs export PROJECT_HOME=$HOME/workspace source /usr/local/bin/virtualenvwrapper.sh #修改后使之立即生效(也可以重启终端使之生效)： source ~/.bash_profile Windows 下： pip install virtualenvwrapper-win 1.设置环境变量 设置WORK_HOME环境变量：例如，WORK_HOME ： D:\\virtualenv 2.新建虚拟环境 mkvirtualenv virtualtest 注：因为前一步设置了WORK_HOME，所有虚拟环境将安装到 E:\\virtualenv 3.查看安装的所有虚拟环境 workon 使用方法： mkvirtualenv env_test：创建运行环境env_test workon env_test: 工作在 env_test 环境 或 从其它环境切换到 env_test 环境 deactivate: 退出终端环境 其它的： rmvirtualenv ENV：删除运行环境ENV mkproject mic：创建mic项目和运行环境mic mktmpenv：创建临时运行环境 lsvirtualenv: 列出可用的运行环境 lssitepackages: 列出当前环境安装了的包 创建的环境是独立的，互不干扰 列出所有虚拟环境 lsvirtualenv 激活虚拟环境 workon venv 进入虚拟环境目录 cdvirtualenv 进入虚拟环境的site-packages目录 cdsitepackages 列出site-packages目录的所有软件包 lssitepackages 停止虚拟环境 deactivate 删除虚拟环境 rmvitualenv venv ","date":"2017-04-28","objectID":"/posts/2017/04/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:1","tags":["Python"],"title":"Python虚拟环境搭建","uri":"/posts/2017/04/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Python"],"content":"重建Python环境 冻结环境 所谓 冻结(freeze) 环境，就是将当前环境的软件包等固定下来: # 安装包列表保存到文件packages.txt中 pip freeze \u003ed:\\packages.txt　 重建环境 重建(rebuild) 环境就是在部署的时候，在生产环境安装好对应版本的软件包，不要出现版本兼容等问题: pip install -r d:\\packages.txt # 配合pip，可以批量安装对应版本的软件包，快速重建环境，完成部署。 ","date":"2017-04-28","objectID":"/posts/2017/04/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:2","tags":["Python"],"title":"Python虚拟环境搭建","uri":"/posts/2017/04/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Python"],"content":"PIP安装：更换安装源，使用国内镜像。 对于Python开发用户来讲，经常使用PIP安装软件包。但是由于PIP默认安装源是在国外，经常出现下载后安装出错问题。所以把PIP安装源替换成国内镜像，可以大幅提升下载速度，还可以提高安装成功率。 国内源： 新版ubuntu要求使用https源，要注意。 清华：https://pypi.tuna.tsinghua.edu.cn/simple 阿里云：http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学：http://pypi.hustunique.com/ 山东理工大学：http://pypi.sdutlinux.org/  豆瓣：http://pypi.douban.com/simple/ 临时使用： 可以在使用pip的时候加参数-i http://pypi.douban.com/simple/ 例如：pip install -i http://pypi.douban.com/simple/ django，这样就会从豆瓣这边的镜像去安装django库。   永久修改，一劳永逸： Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹) 内容如下： [global] index-url = https://pypi.douban.com/simple/ [install] trusted-host=mirrors.aliyun.com windows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini。内容同上。 ","date":"2017-04-26","objectID":"/posts/2017/04/pip%E5%AE%89%E8%A3%85%E6%9B%B4%E6%8D%A2%E5%AE%89%E8%A3%85%E6%BA%90%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/:0:0","tags":["Python"],"title":"PIP安装：更换安装源，使用国内镜像","uri":"/posts/2017/04/pip%E5%AE%89%E8%A3%85%E6%9B%B4%E6%8D%A2%E5%AE%89%E8%A3%85%E6%BA%90%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/"},{"categories":["Python"],"content":" 项目中有时会写些py脚本文件，为当作项目工具，方便无Python环境下使用，所以需要打包成exe文件。 ","date":"2017-03-12","objectID":"/posts/2017/03/python%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85exe/:0:0","tags":["Python"],"title":"Python如何打包exe","uri":"/posts/2017/03/python%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85exe/"},{"categories":["Python"],"content":"Python打包exe Q：py生成exe，总共需几步？ A：总共分三步！ ","date":"2017-03-12","objectID":"/posts/2017/03/python%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85exe/:1:0","tags":["Python"],"title":"Python如何打包exe","uri":"/posts/2017/03/python%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85exe/"},{"categories":["Python"],"content":"1. 安装PyInstaller pip install PyInstaller 注意：安装包名区分大小写 ","date":"2017-03-12","objectID":"/posts/2017/03/python%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85exe/:1:1","tags":["Python"],"title":"Python如何打包exe","uri":"/posts/2017/03/python%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85exe/"},{"categories":["Python"],"content":"2. 打包脚本:TargetPy2exe.py.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" @version: ?? @author: Binge @file: TargetPy2exe.py.py @time: 2017-02-07 11:21 @description: convert py to exe by pyinstaller \"\"\" from PyInstaller.__main__ import run if __name__ == '__main__': # 设置打包exe参数：目标py、打包参数 # -F 打包成一个exe文件 # -w 使用窗口，无控制台 # -c 使用控制台，无窗口 # --icon = 图标路径 # --upx-dir 使用upx压缩 # upx391w ups程序目录文件路径 # opts = ['tvn_process.py', '-F'] opts = ['tvn_process.py', '-F', '-w'] # opts = ['tvn_process.py', '-F', '-c'] # opts = ['tvn_process.py', '-F', '-w', '--upx-dir', 'upx391w'] # opts = ['tvn_process.py', '-F', '-w','--icon=tvn_process.ico','--upx-dir','upx391w'] run(opts) ","date":"2017-03-12","objectID":"/posts/2017/03/python%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85exe/:1:2","tags":["Python"],"title":"Python如何打包exe","uri":"/posts/2017/03/python%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85exe/"},{"categories":["Python"],"content":"3. 运行打包脚本，即可生成exe文件","date":"2017-03-12","objectID":"/posts/2017/03/python%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85exe/:1:3","tags":["Python"],"title":"Python如何打包exe","uri":"/posts/2017/03/python%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85exe/"},{"categories":["生活"],"content":"2016年小结","date":"2017-01-24","objectID":"/posts/2017/01/20166%E4%BA%86%E4%BB%80%E4%B9%88/","tags":["生活"],"title":"2016，6了什么","uri":"/posts/2017/01/20166%E4%BA%86%E4%BB%80%E4%B9%88/"},{"categories":["生活"],"content":" “夕阳最美时，也总是将近黄昏。 世上有很多事都是这样子的，尤其是一些特别辉煌美好的事。 所以你不必伤感，也不用惋惜，纵然到江湖去赶上了春，也不必留住它。 因为这就是人生，有些事你留也留不住。 你一定要先学会忍受它的无情，才会懂得享受它的温柔。 ” ——古龙 ","date":"2017-01-24","objectID":"/posts/2017/01/20166%E4%BA%86%E4%BB%80%E4%B9%88/:0:0","tags":["生活"],"title":"2016，6了什么","uri":"/posts/2017/01/20166%E4%BA%86%E4%BB%80%E4%B9%88/"},{"categories":["生活"],"content":"前言 年关将至，总会回想起这一年，完成了哪些事情，未完成哪些事情，收获了什么。。。 想来想去，都是些小事情。这点小事，虽不值得大书特写轰轰烈烈纪念，但还是添两笔，记录一下。 ","date":"2017-01-24","objectID":"/posts/2017/01/20166%E4%BA%86%E4%BB%80%E4%B9%88/:0:1","tags":["生活"],"title":"2016，6了什么","uri":"/posts/2017/01/20166%E4%BA%86%E4%BB%80%E4%B9%88/"},{"categories":["生活"],"content":"小结 一、学习 技术变得快，还要赶紧追。 用小站来整理学习笔记，效果不错。 阿尔法狗来了。。。 二、爱好 锻炼：2016没有练，腹肌木有了，胸肌木有了，嘛都木有了。 单车：这一年，断断续续骑了段时间，没有拉100公里以上的长途，速度也没飚过40公里时速。属于慢速短途悠闲骑。 其它没有玩耍的就不再啰嗦。 三、小站 小站开张半年，只攒了（复制）5篇文章，看来忙（懒）得不轻。 借索大侠的话说：“程序猿应该有自己的空间吧，虽然这个东西并不算什么”。有了小站，也方便做资料整理和学习记录。 四、其它 什么都木有干！！！ 五、计划 设定小目标，希望能够完成它。 加强锻炼，召回腹肌。 小站常更新。 ","date":"2017-01-24","objectID":"/posts/2017/01/20166%E4%BA%86%E4%BB%80%E4%B9%88/:0:2","tags":["生活"],"title":"2016，6了什么","uri":"/posts/2017/01/20166%E4%BA%86%E4%BB%80%E4%B9%88/"},{"categories":["生活"],"content":"后记 还有一事：前段时间坐三角翼小飞机，体验了爬升、俯冲、失重下降、大转弯、低空过场等动作。所以，以后如果有人问：你咋不上天呢？我就可以答：我真上过天，还吼过。。。 希望新一年，自己能够像小飞机那样飞得潇洒！ 最后，祝各位看官：鸡年大吉，万事如意~~~ 友情推荐 Tuantuan.G：是设计师，也是小伙伴。有想法，有理念。爱画画，有创意。从视觉设计，到UI平面。哪怕通宵达旦，也要设计漂亮。。。去她那里逛逛吧：@Tuantuan.G 索洪波：是程序员，也是段子手，低调深刻有内涵。去他的小站看看吧：@索洪波 ","date":"2017-01-24","objectID":"/posts/2017/01/20166%E4%BA%86%E4%BB%80%E4%B9%88/:0:3","tags":["生活"],"title":"2016，6了什么","uri":"/posts/2017/01/20166%E4%BA%86%E4%BB%80%E4%B9%88/"},{"categories":["JS"],"content":" 从网上整理的JavaScript的正则表达式，实际项目使用时，还需再做测验 ——Binge 技巧 整数或者小数：^[0-9]+.{0,1}[0-9]{0,2}$ 只能输入数字：\"^[0-9]*$\"。 只能输入n位的数字：\"^\\d{n}$\"。 只能输入至少n位的数字：\"^\\d{n,}$\"。 只能输入m~n位的数字：。\"^\\d{m,n}$\" 只能输入零和非零开头的数字：\"^(0|[1-9][0-9]*)$\"。 只能输入有两位小数的正实数：\"^[0-9]+(.[0-9]{2})?$\"。 只能输入有1~3位小数的正实数：\"^[0-9]+(.[0-9]{1,3})?$\"。 只能输入非零的正整数：\"^+?[1-9][0-9]*$\"。 只能输入非零的负整数：\"^-[1-9][0-9*$\"。 只能输入长度为3的字符：\"^.{3}$\"。 只能输入由26个英文字母组成的字符串：\"^[A-Za-z]+$\"。 只能输入由26个大写英文字母组成的字符串：\"^[A-Z]+$\"。 只能输入由26个小写英文字母组成的字符串：\"^[a-z]+$\"。 只能输入由数字和26个英文字母组成的字符串：\"^[A-Za-z0-9]+$\"。 只能输入由数字、26个英文字母或者下划线组成的字符串：\"^\\w+$\"。 验证用户密码：\"^[a-zA-Z]\\w{5,17}$“正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。 验证是否含有^%\u0026',;=?$\"等字符：\"[^%\u0026',;=?$\\x22]+\"。 只能输入汉字：\"^[\\u4e00-\\u9fa5]{0,}$” 验证Email地址：\"^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*$\"。 验证InternetURL：\"^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%\u0026=]*)?$\"。 验证电话号码：\"^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$“正确格式为：“XXX-XXXXXXX”、“XXXX-XXXXXXXX”、“XXX-XXXXXXX”、“XXX-XXXXXXXX”、“XXXXXXX\"和\"XXXXXXXX”。 验证身份证号（15位或18位数字）：\"^\\d{15}|\\d{18}$\"。 验证一年的12个月：\"^(0?[1-9]|1[0-2])$“正确格式为：“01\"～\"09\"和\"1\"～\"12”。 验证一个月的31天：\"^((0?[1-9])|((1|2)[0-9])|30|31)$“正确格式为；“01\"～\"09\"和\"1\"～\"31”。 匹配中文字符的正则表达式： [\\u4e00-\\u9fa5] 匹配双字节字符(包括汉字在内)：[^\\x00-\\xff] 应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） String.prototype.len=function(){return this.replace(/[^\\x00-\\xff]/g,\"aa\").length;} 技巧 匹配空行的正则表达式：\\n[\\s| ]*\\r 匹配html标签的正则表达式：\u003c(.)\u003e(.)\u003c/(.)\u003e|\u003c(.)/\u003e 匹配首尾空格的正则表达式：(^\\s*)|(\\s*$) 应用：javascript中没有像vbscript那样的trim函数，我们就可以利用这个表达式来实现，如下： String.prototype.trim = function() { return this.replace(/(^\\s*)|(\\s*$)/g, \"\"); } 利用正则表达式分解和转换IP地址： 下面是利用正则表达式匹配IP地址，并将IP地址转换成对应数值的Javascript程序： function IP2V(ip) { re=/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)/g //匹配IP地址的正则表达式 if(re.test(ip)) { return RegExp.$1*Math.pow(255,3))+RegExp.$2*Math.pow(255,2))+RegExp.$3*255+RegExp.$4*1 } else { throw new Error(\"Not a valid IP address!\") } } 不过上面的程序如果不用正则表达式，而直接用split函数来分解可能更简单，程序如下： var ip=\"10.100.20.168\" ip=ip.split(\".\") alert(\"IP值是：\"+(ip[0]*255*255*255+ip[1]*255*255+ip[2]*255+ip[3]*1)) 匹配Email地址的正则表达式：\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)* 匹配网址URL的正则表达式：http://([\\w-]+.)+[\\w-]+(/[\\w- ./?%\u0026=]*)? 利用正则表达式限制网页表单里的文本框输入内容： 用正则表达式限制只能输入中文： var onkeyup=\"value=value.replace(/[^\\u4E00-\\u9FA5]/g,'')\" var onbeforepaste=\"clipboardData.setData('text',clipboardData.getData('text').replace(/[^\\u4E00-\\u9FA5]/g,''))\" 用正则表达式限制只能输入全角字符： var onkeyup=\"value=value.replace(/[^\\uFF00-\\uFFFF]/g,'')\" var onbeforepaste=\"clipboardData.setData('text',clipboardData.getData('text').replace(/[^\\uFF00-\\uFFFF]/g,''))\" 用正则表达式限制只能输入数字： var onkeyup=\"value=value.replace(/[^\\d]/g,'') \" var onbeforepaste=\"clipboardData.setData('text',clipboardData.getData('text').replace(/[^\\d]/g,''))\" 用正则表达式限制只能输入数字和英文： var onkeyup=\"value=value.replace(/[\\W]/g,'') \" var onbeforepaste=\"clipboardData.setData('text',clipboardData.getData('text').replace(/[^\\d]/g,''))\" 技巧 匹配中文字符的正则表达式： [\\u4e00-\\u9fa5] 评注：匹配中文还真是个头疼的事，有了这个表达式就好办了 匹配双字节字符(包括汉字在内)：[^\\x00-\\xff] 评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） 匹配空白行的正则表达式：\\n\\s*\\r 评注：可以用来删除空白行 匹配HTML标记的正则表达式：\u003c(\\S*?)[^\u003e]*\u003e.*?|\u003c.*? /\u003e 评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力 匹配首尾空白字符的正则表达式：^\\s*|\\s*$ 评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式 匹配Email地址的正则表达式：\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)* 评注：表单验证时很实用 匹配网址URL的正则表达式：[a-zA-z]+://[^\\s]* 评注：网上流传的版本功能很有限，上面这个基本可以满足需求 匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 评注：表单验证时很实用 匹配国内电话号码：\\d{3}-\\d{8}|\\d{4}-\\d{7} 评注：匹配形式如 0511-4405222 或 021-87888822 匹配腾讯QQ号：[1-9][0-9]{4,} 评注：腾讯QQ号从10000开始 匹配中国邮政编码：[1-9]\\d{5}(?!\\d) 评注：中国邮政编码为6位数字 匹配身份证：\\d{15}|\\d{18} 评注：中国的身份证为15位或18位 匹配ip地址：\\d+.\\d+.\\d+.\\d+ 评注：提取ip地址时有用 匹配特定数字： ^[1-9]\\d*$　//匹配正整数 ^-[1-9]\\d*$ //匹配负整数 ^-?[1-9]\\d*$　//匹配整数 ^[1-9]\\d*|0$　//匹配非负整数（正整数 + 0） ^-[1-9]\\d*|0$　//匹配非正整数（负整数 + 0） ^[1-9]\\d*.\\d*|0.\\d*[1-9]\\d*$　//匹配正浮点数 ^-([1-9]\\d*.\\d*|0.\\d*[1-9]\\d*)$　//匹配负浮点数 ^-?([1-9]\\d*.\\d*|0.\\d*[1-9]\\d*|0?.0+|0)$　//匹配浮点数 ^[1-9]\\d*.\\d*|0.\\d*[1-9]\\d*|0?.0+|0$　//匹配非负浮点数（正浮点数 + 0） ^(-([1-9]\\d*.\\d*|0.\\d*[1-9]\\d*))|0?.0+|0$　//匹配非正浮点数（负浮点数 + 0） 评注：处理大量数据时有用，具体应用时注意修正 匹配特定字符串： ^[A-Za-z]+$　//匹配由26个英文字母组成的字符串 ^[A-Z]+$　//匹配由26个英文字母的大写组成的字符串 ^[a-z]+$　//匹配由","date":"2016-09-06","objectID":"/posts/2016/09/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%A4%A7%E5%85%A8/:0:0","tags":["JS"],"title":"JS正则表达式大全","uri":"/posts/2016/09/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%A4%A7%E5%85%A8/"},{"categories":["JS"],"content":" JQuery源码-Deferred 寥寥代码，犀利锋锐，设计思想，值得学习 ——Binge Deferred的概念请看第一篇 http://www.cnblogs.com/aaronjs/p/3348569.html   ****************** 构建Deferred对象时候的流程图**************************   **********************源码解析**********************   因为callback被剥离出去后，整个deferred就显得非常的精简 jQuery.extend({ Deferred : \u003c/span\u003e\u003cspan style=\"color:rgb(0,0,255); line-height:1.5!important\"\u003efunction\u003c/span\u003e\u003cspan style=\"line-height:1.5!important\"\u003e(){} when : \u003c/span\u003e\u003cspan style=\"color:rgb(0,0,255); line-height:1.5!important\"\u003efunction\u003c/span\u003e\u003cspan style=\"line-height:1.5!important\"\u003e() )} 对于extend的继承这个东东，在之前就提及过jquery如何处理内部jquery与init相互引用this的问题 对于JQ的整体架构一定要弄懂 http://www.cnblogs.com/aaronjs/p/3278578.html 所以当jQuery.extend只有一个参数的时候，其实就是对jQuery静态方法的一个扩展 我们在具体看看2个静态方法内部都干了些什么： Deferred整体结构： 源码精简了部分代码 Deferred: function( func ) {var tuples =[//action, add listener, listener list, final state [ “resolve”, “done”, jQuery.Callbacks(“once memory”), “resolved”], [ “reject”, “fail”, jQuery.Callbacks(“once memory”), “rejected”], [ “notify”, “progress”, jQuery.Callbacks(“memory”) ] ], state = “pending”, promise ={ state: function() {}, always: function() {}, then: function( /fnDone, fnFail, fnProgress /) { },//Get a promise for this deferred //If obj is provided, the promise aspect is added to the object promise: function( obj ) {} }, deferred ={}; jQuery.each( tuples, function( i, tuple ) { deferred[ tuple[0] + “With” ] =list.fireWith; }); promise.promise( deferred ); //All done! returndeferred; }, 显而易见Deferred是个工厂类，返回的是内部构建的deferred对象 tuples 创建三个$.Callbacks对象，分别表示成功，失败，处理中三种状态 创建了一个promise对象，具有state、always、then、primise方法 扩展primise对象生成最终的Deferred对象，返回该对象 这里其实就是3个处理,但是有个优化代码的地方,就是把共性的代码给抽象出来,通过动态生成了 具体源码分析: Deferred自身则围绕这三个对象进行更高层次的抽象 触发回调函数列表执行(函数名) 添加回调函数（函数名） 回调函数列表（jQuery.Callbacks对象） deferred最终状态（第三组数据除外） var tuples =[//action, add listener, listener list, final state [ “resolve”, “done”, jQuery.Callbacks(“once memory”), “resolved”], [ “reject”, “fail”, jQuery.Callbacks(“once memory”), “rejected”], [ “notify”, “progress”, jQuery.Callbacks(“memory”) ] ], 这里抽象出2组阵营： 1组：回调方法/事件订阅  done，fail，progress 2组：通知方法/事件发布  resolve，reject，notify，resolveWith，rejectWith，notifyWith tuples 元素集 其实是把相同有共同特性的代码的给合并成一种结构，然后通过一次处理 jQuery.each( tuples, function( i, tuple ) {var list = tuple[ 2], stateString = tuple[ 3]; promise[ tuple[1] ] =list.add;if( stateString ) { list.add(function() { state =stateString;//[ reject_list | resolve_list ].disable; progress_list.lock }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2].lock ); } deferred[ tuple[0] ] = function() { deferred[ tuple[0] + “With” ]( this === deferred ? promise : this, arguments );return this; }; deferred[ tuple[0] + “With” ] =list.fireWith; }); 对于tuples的3条数据集是分2部分处理的 第一部分将回调函数存入 promise[ tuple[1] ] = list.add; 其实就是给promise赋予3个回调函数 promise.done = $.Callbacks(“once memory”).add promise.fail = $.Callbacks(“once memory”).add promise.progressl = $.Callbacks(“memory”).add 如果存在deferred最终状态 默认会预先向doneList,failList中的list添加三个回调函数 if( stateString ) { list.add(function() {//state = [ resolved | rejected ] state =stateString;//[ reject_list | resolve_list ].disable; progress_list.lock }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2].lock ); } ************************************************************* 这里有个小技巧 i ^ 1 按位异或运算符 所以实际上第二个传参数是1、0索引对调了，所以取值是failList.disable与doneList.disable ************************************************************* 通过stateString有值这个条件，预先向doneList,failList中的list添加三个回调函数 分别是: doneList : [changeState, failList.disable, processList.lock] failList : [changeState, doneList.disable, processList.lock] changeState 改变状态的匿名函数，deferred的状态，分为三种：pending(初始状态), resolved(解决状态), rejected(拒绝状态) 不论deferred对象最终是resolve（还是reject），在首先改变对象状态之后，都会disable另一个函数列表failList(或者doneList) 然后lock processList保持其状态，最后执行剩下的之前done（或者fail）进来的回调函数 所以第一步最终都是围绕这add方法 done/fail/是list.add也就是 callbacks.add ，将回调函数存入回调对象中 第二部分很简单，给deferred对象扩充6个方法 resolve/reject/notify 是 callbacks.fireWith ，执行回调函数 resolveWith/rejectWith/notifyWith 是 callbacks.fireWith 队列方法引用 最后合并prom","date":"2016-08-03","objectID":"/posts/2016/08/javascript-%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1-02/:0:0","tags":["JS"],"title":"JavaScript 模式设计-02","uri":"/posts/2016/08/javascript-%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1-02/"},{"categories":["JS"],"content":" “The key is to acknowledge from the start that you have no idea how this will grow. When you accept that you don’t know everything, you begin to design the system defensively. You identify the key areas that may change, which often is very easy when you put a little bit of time into it. For instance, you should expect that any part of the app that communicates with another system will likely change, so you need to abstract that away.” ——一切皆可变，所以要抽象。 模块论 大家可能都或多或少地使用了模块化的代码，模块是一个完整的强健程序架构的一部分，每个模块都是为了单独的目的为创建的，回到Gmail，我们来个例子，chat聊天模块看起来是个单独的一部分，其实它是有很多单独的子模块来构成，例如里面的表情模块其实就是单独的子模块，也被用到了发送邮件的窗口上。 另外一个是模块可以动态加载，删除和替换。 在JavaScript里，我们有几种方式来实现模块，大家熟知的是module模式和对象字面量,如果你已经熟悉这些，请忽略此小节，直接跳到CommonJS部分。 Module模式 module模式是一个比较流行的设计模式，它可以通过大括号封装私有的变量，方法，状态的，通过包装这些内容，一般全局的对象不能直接访问，在这个设计模式里，只返回一个API，其它的内容全部被封装成私有的了。 另外，这个模式和自执行的函数表达式比较相似，唯一的不同是module返回的是对象，而自执行函数表达式返回的是function。 众所周知， JavaScript不想其它语言一样有访问修饰符，不能为每个字段或者方法声明private,public修饰符，那这个模式我们是如何实现的呢？那就是return一个对象，里面包括一些公开的方法，这些方法有能力去调用内部的对象。 看一下，下面的代码，这段代码是一个自执行代码，声明里包括了一个全局的对象basketModule， basket数组是一个私有的，所以你的整个程序是不能访问这个私有数组的，同时我们return了一个对象，其内包含了3个方法（例如addItem,getItemCount,getTotal)，这3个方法可以访问私有的basket数组。 var basketModule = (function() { var basket = []; //privatereturn { //exposed to public　addItem: function(values) { basket.push(values); }, getItemCount: function() { return basket.length; }, getTotal: function(){ var q = this.getItemCount(),p=0; while(q--){ p+= basket[q].price; } return p; } } }()); 同时注意，我们return的对象直接赋值给了basketModule，所以我们可以像下面一样使用： //basketModule is an object with properties which can also be methodsbasketModule.addItem({item:'bread',price:0.5}); basketModule.addItem({item:'butter',price:0.3}); console.log(basketModule.getItemCount()); console.log(basketModule.getTotal()); //however, the following will not work:console.log(basketModule.basket);//(undefined as not inside the returned object)console.log(basket); //(only exists within the scope of the closure) 那在各个流行的类库（如Dojo, jQuery)里是如何来做呢？ Dojo Dojo试图使用dojo.declare来提供class风格的声明方式，我们可以利用它来实现Module模式，例如如果你想再store命名空间下声明basket对象，那么可以这么做： //traditional way var store = window.store || {}; store.basket = store.basket || {}; //using dojo.setObject dojo.setObject(\"store.basket.object\", (function() { var basket = []; function privateMethod() { console.log(basket); } return { publicMethod: function(){ privateMethod(); } }; }())); 结合dojo.provide一起来使用，非常强大。 YUI 下面的代码是YUI原始的实现方式： YAHOO.store.basket = function () { //\"private\" variables: var myPrivateVar = \"I can be accessed only within YAHOO.store.basket .\"; //\"private\" method: var myPrivateMethod = function () { YAHOO.log(\"I can be accessed only from within YAHOO.store.basket\"); } return { myPublicProperty: \"I'm a public property.\", myPublicMethod: function () { YAHOO.log(\"I'm a public method.\"); //Within basket, I can access \"private\" vars and methods: YAHOO.log(myPrivateVar); YAHOO.log(myPrivateMethod()); //The native scope of myPublicMethod is store so we can //access public members using \"this\": YAHOO.log(this.myPublicProperty); } }; } ();   jQuery jQuery里有很多Module模式的实现，我们来看一个不同的例子，一个library函数声明了一个新的library，然后创建该library的时候，在document.ready里自动执行init方法。 function library(module) { $(function() { if (module.init) { module.init(); } }); return module; } var myLibrary = library(function() { return { init: function() { /*implementation*/ } }; }()); 对象自面量 对象自面量使用大括号声明，并且使用的时候不需要使用new关键字，如果对一个模块里的属性字段的publice/private不是很在意的话，可以使用这种方式，不过请注意这种方式和JSON的不同。对象自面量： var item={name: \"tom\", value:123} JSON: var item={\"name\":\"tom\", \"value\":123} 。 var myModule = { myProperty: 'someValue', //object literals can contain properties and methods. //here, another object is defined for configuration //purposes: myConfig: { useCaching: true, language: 'en' }, //a very basic method myMethod: function () { console.log('I can haz functionality?'); }, //output a value based on current configuration myMethod2: function () { console.log('Caching is:' + (this.myConfig.useCaching) ? 'enabled' : 'disabled'); }, /","date":"2016-07-11","objectID":"/posts/2016/07/javascript-%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1-01/:0:0","tags":["JS"],"title":"JavaScript 模式设计-01","uri":"/posts/2016/07/javascript-%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1-01/"},{"categories":["生活"],"content":"开博了，等你来 “只有初恋般的热情和宗教般的意志，人才可能成就某种事业。” ——路遥 ","date":"2016-06-06","objectID":"/posts/2016/06/welcome-to-binge-blog/:0:0","tags":["生活"],"title":"Welcome to Binge Blog","uri":"/posts/2016/06/welcome-to-binge-blog/"},{"categories":["生活"],"content":"前言 Binge Blog 终于慢腾腾地开通了。。。 两年前就想搭个站玩玩，结果各种原因未能实现。 直到今年，这种想法日益强烈，光说不干假把式，于是，利用两个周末时间，完成自己的小站。 这样，能有个地儿可以折腾点自己的东西，还是蛮有意思的。 正所谓：站不在大，好玩就中！ ","date":"2016-06-06","objectID":"/posts/2016/06/welcome-to-binge-blog/:0:1","tags":["生活"],"title":"Welcome to Binge Blog","uri":"/posts/2016/06/welcome-to-binge-blog/"},{"categories":["生活"],"content":"正文 关于小站： 1. 找空间 稳定； 大，大，大； 便于管理； 要流行； 要时尚； …… 于是，我选择了Octocat。。。 注：Octocat（章鱼猫）＝ Octopus（章鱼）+ Cat（猫） 2. 注册域名 刚开始，在godaddy注册了域名。没有VISA和paypal不要紧，可使用alipay支付宝。 用了两三天，便收到了godaddy的邮件通知：将要收回域名，付款将会全额退还。具体原因，此处不赘述。最后，收到退款，免费玩了三天域名。 分享下godaddy域名使用体会： 优点： com域名免认证，可快速生效； 可以使用优惠码，价格有优惠； 缺点： 国内会出现无法解析的问题，需要自己动手解决； 会公开域名注册人的信息（包括联系电话），如果想要隐私保护，需要额外付费才能享受信息保护服务。 以前的价格优势已无，对于部分域名注册费用还要比国内贵得多； 后来，就在万网注册个域名。com域名带认证，不到半天就搞定。 分享下万网域名使用体会： 流程简单，配置方便； 阿里云解析，生效速度很快。比如一些免认证的域名，一两分钟就能生效使用； 域名购买后，有账单发票，且有域名证书图片。便于用户声明域名所有权。 小站域名： bingerambo.com：外号binge名称域名已被国外注册。想起《第一滴血》里史泰龙扮演的硬汉兰博。于是就再加上rambo,便有了bingerambo。 3. 内容 自己整理：笔记和感想，有关技术、阅读、兴趣和其它杂谈。希望积跬步，致千里。 好友原创：好友写的文章，分享到小站。 欢迎投稿：文章、图片都可。 如果您的原创和投稿，入驻小站，都是小编我的荣幸。 4. 友情链接介绍 Tuantuan.G：是设计师，也是小伙伴。有想法，有理念。爱画画，有创意。从视觉设计，到UI平面。哪怕通宵达旦，也要设计漂亮。。。去她那里逛逛吧：@Tuantuan.G 索洪波：是程序员，也是段子手，低调深刻有内涵。去他的小站看看吧：@索洪波 ","date":"2016-06-06","objectID":"/posts/2016/06/welcome-to-binge-blog/:0:2","tags":["生活"],"title":"Welcome to Binge Blog","uri":"/posts/2016/06/welcome-to-binge-blog/"},{"categories":["生活"],"content":"后记 小站发布，记录点滴生活。。。 特别感谢 [Tuantuan.G]，在百忙之余，提供了丰富的图片素材。让我方便修图，配图攒文。同时，也对小站的完善提出了宝贵建议，并分享其原创作品。 感谢看到这里的你。。。 最后，希望来这儿逛的你，好心情~~~ ","date":"2016-06-06","objectID":"/posts/2016/06/welcome-to-binge-blog/:0:3","tags":["生活"],"title":"Welcome to Binge Blog","uri":"/posts/2016/06/welcome-to-binge-blog/"}]