<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>GO编程陷阱和常见错误 - 斌哥的小站|Binge Blog</title><meta name=Description content="斌哥的小站 | 这里是 @BingeRambo斌哥兰博的个人博客"><meta property="og:title" content="GO编程陷阱和常见错误"><meta property="og:description" content="Go 是一种简单而有趣的语言，但是，与任何其他语言一样，它也有一些陷阱……其中许多陷阱并不完全是 Go 的错。其中一些错误是自然陷阱。其他是由于错误的假设和缺少细节。"><meta property="og:type" content="article"><meta property="og:url" content="http://bingerambo.com/posts/2023/05/go%E7%BC%96%E7%A8%8B%E9%99%B7%E9%98%B1%E5%92%8C%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"><meta property="og:image" content="http://bingerambo.com/logo.png"><meta property="article:published_time" content="2023-05-29T08:43:17+08:00"><meta property="article:modified_time" content="2023-05-29T08:43:17+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://bingerambo.com/logo.png"><meta name=twitter:title content="GO编程陷阱和常见错误"><meta name=twitter:description content="Go 是一种简单而有趣的语言，但是，与任何其他语言一样，它也有一些陷阱……其中许多陷阱并不完全是 Go 的错。其中一些错误是自然陷阱。其他是由于错误的假设和缺少细节。"><meta name=application-name content="Binge Blog"><meta name=apple-mobile-web-app-title content="Binge Blog"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=http://bingerambo.com/posts/2023/05/go%E7%BC%96%E7%A8%8B%E9%99%B7%E9%98%B1%E5%92%8C%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/><link rel=prev href=http://bingerambo.com/posts/2023/03/%E5%AE%B9%E5%99%A8%E5%92%8Ckubernetes%E4%B8%AD%E7%9A%84%E9%80%80%E5%87%BA%E4%BB%A3%E7%A0%81%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/><link rel=next href=http://bingerambo.com/posts/2023/06/k8s%E6%9F%A5%E8%AF%A2%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/custom.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"GO编程陷阱和常见错误","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/bingerambo.com\/posts\/2023\/05\/go%E7%BC%96%E7%A8%8B%E9%99%B7%E9%98%B1%E5%92%8C%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF\/"},"image":["http:\/\/bingerambo.com\/images\/Apple-Devices-Preview.png"],"genre":"posts","keywords":"Go","wordcount":21388,"url":"http:\/\/bingerambo.com\/posts\/2023\/05\/go%E7%BC%96%E7%A8%8B%E9%99%B7%E9%98%B1%E5%92%8C%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF\/","datePublished":"2023-05-29T08:43:17+08:00","dateModified":"2023-05-29T08:43:17+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xxxx","logo":"http:\/\/bingerambo.com\/images\/avatar.png"},"author":{"@type":"Person","name":"Binge"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="斌哥的小站|Binge Blog"><span class=header-title-pre><i class="fas fa-biking fa-fw"></i></span>Binge Blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/><i class="fas fa-fw fa-archive"></i>文章 </a><a class=menu-item href=/tags/><i class="fas fa-fw fa-tag"></i>标签 </a><a class=menu-item href=/categories/><i class="fas fa-fw fa-th"></i>分类 </a><a class=menu-item href=/timeline/><i class="fas fa-cog fa-spin"></i>随记 </a><a class=menu-item href=/about/><i class="fas fa-fw fa-at"></i>关于 </a><a class=menu-item href=/search/><i class="fas fa-fw fa-search"></i>搜索 </a><a class=menu-item href=/friend/ title=Friend><i class="fas fa fa-user"></i>友链 </a><a class=menu-item href=https://github.com/bingerambo title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><a class=menu-item href=/><i class="fas fa fa-eye"></i><span id=busuanzi_value_site_uv></span></a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="斌哥的小站|Binge Blog"><span class=header-title-pre><i class="fas fa-biking fa-fw"></i></span>Binge Blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/><i class="fas fa-fw fa-archive"></i>文章</a><a class=menu-item href=/tags/><i class="fas fa-fw fa-tag"></i>标签</a><a class=menu-item href=/categories/><i class="fas fa-fw fa-th"></i>分类</a><a class=menu-item href=/timeline/><i class="fas fa-cog fa-spin"></i>随记</a><a class=menu-item href=/about/><i class="fas fa-fw fa-at"></i>关于</a><a class=menu-item href=/search/><i class="fas fa-fw fa-search"></i>搜索</a><a class=menu-item href=/friend/ title=Friend><i class="fas fa fa-user"></i>友链</a><a class=menu-item href=https://github.com/bingerambo title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><a class=menu-item href=/><i class="fas fa fa-eye"></i><span id=busuanzi_value_site_uv></span></a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">GO编程陷阱和常见错误</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=http://bingerambo.com title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>Binge</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/go/><i class="far fa-folder fa-fw"></i>Go</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2023-05-29>2023-05-29</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 21388 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 43 分钟&nbsp;
<i class="fa fa-eye fa-fw"></i>&nbsp;本文总阅读量 <span id=busuanzi_value_page_pv></span>次&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#概述><strong>概述</strong></a></li><li><a href=#1不能将左大括号放在单独的行上><strong>1.不能将左大括号放在单独的行上</strong></a></li><li><a href=#2未使用的变量><strong>2.未使用的变量</strong></a></li><li><a href=#3未使用的-import><strong>3.未使用的 import</strong></a></li><li><a href=#4短变量声明只能在函数内部使用><strong>4.短变量声明只能在函数内部使用</strong></a></li><li><a href=#5使用短变量声明重新声明变量><strong>5.使用短变量声明重新声明变量</strong></a></li><li><a href=#6不能使用短变量声明来设置字段值><strong>6.不能使用短变量声明来设置字段值</strong></a></li><li><a href=#7变量覆盖variable-shadowing><strong>7.变量覆盖（Variable Shadowing）</strong></a></li><li><a href=#8不能使用nil来初始化没有显式类型的变量><strong>8.不能使用“nil”来初始化没有显式类型的变量</strong></a></li><li><a href=#9使用nil切片和映射><strong>9.使用“nil”切片和映射</strong></a></li><li><a href=#10map-容量><strong>10.map 容量</strong></a></li><li><a href=#11字符串不能为nil><strong>11.字符串不能为“nil”</strong></a></li><li><a href=#12数组函数参数数组指针类型><strong>12.数组函数参数：数组指针类型</strong></a></li><li><a href=#13切片和数组range子句中的意外值><strong>13.切片和数组“range”子句中的意外值</strong></a></li><li><a href=#14切片和数组是一维的><strong>14.切片和数组是一维的</strong></a></li><li><a href=#15访问不存在的map的key><strong>15.访问不存在的map的key</strong></a></li><li><a href=#16字符串是不可变的><strong>16.字符串是不可变的</strong></a></li><li><a href=#17字符串和字节片之间的转换><strong>17.字符串和字节片之间的转换</strong></a></li><li><a href=#18字符串和索引运算符><strong>18.字符串和索引运算符</strong></a></li><li><a href=#19字符串并不总是-utf8-文本><strong>19.字符串并不总是 UTF8 文本</strong></a></li><li><a href=#20字符串长度><strong>20.字符串长度</strong></a></li><li><a href=#21多行切片数组和映射文字中缺少逗号><strong>21.多行切片、数组和映射文字中缺少逗号</strong></a></li><li><a href=#22logfatal-和-logpanic-不仅仅是日志><strong>22.log.Fatal 和 log.Panic 不仅仅是日志</strong></a></li><li><a href=#23内置数据结构操作不同步><strong>23.内置数据结构操作不同步</strong></a></li><li><a href=#24range子句中字符串的迭代值>24.<strong>“range”子句中字符串的迭代值</strong></a></li><li><a href=#25使用for-range子句遍历map><strong>25.使用“for range”子句遍历map</strong></a></li><li><a href=#26switch语句中的失败行为><strong>26.“switch”语句中的失败行为</strong></a></li><li><a href=#27增量和减量><strong>27.增量和减量</strong></a></li><li><a href=#28按位非运算符><strong>28.按位非运算符</strong></a></li><li><a href=#29运算符优先级差异><strong>29.运算符优先级差异</strong></a></li><li><a href=#30未导出的结构字段未编码><strong>30.未导出的结构字段未编码</strong></a></li><li><a href=#31带有活动-goroutines-的应用程序退出><strong>31.带有活动 Goroutines 的应用程序退出</strong></a></li><li><a href=#32目标接收器准备好后立即返回到无缓冲通道><strong>32.目标接收器准备好后立即返回到无缓冲通道</strong></a></li><li><a href=#33发送到关闭的通道会导致panic><strong>33.发送到关闭的通道会导致panic</strong></a></li><li><a href=#34使用零通道><strong>34.使用“零”通道</strong></a></li><li><a href=#35带有值接收器的方法不能更改原始值><strong>35.带有值接收器的方法不能更改原始值</strong></a></li><li><a href=#36关闭-http-响应正文><strong>36.关闭 HTTP 响应正文</strong></a></li><li><a href=#37关闭-http-连接><strong>37.关闭 HTTP 连接</strong></a></li><li><a href=#38json-编码器添加换行符><strong>38.JSON 编码器添加换行符</strong></a></li><li><a href=#39json-包转义键和字符串值中的特殊-html-字符><strong>39.JSON 包转义键和字符串值中的特殊 HTML 字符</strong></a></li><li><a href=#40将-json-数字解组为接口值><strong>40.将 JSON 数字解组为接口值</strong></a></li><li><a href=#41十六进制或其他非-utf8-转义序列无法使用-json-字符串值><strong>41.十六进制或其他非 UTF8 转义序列无法使用 JSON 字符串值</strong></a></li><li><a href=#42比较结构数组切片和映射><strong>42.比较结构、数组、切片和映射</strong></a></li><li><a href=#43从-panic-中恢复-recover-><strong>43.从 panic 中恢复（ recover ）</strong></a></li><li><a href=#44在切片数组和映射range子句中更新和引用item值><strong>44.在切片、数组和映射“range”子句中更新和引用item值</strong></a></li><li><a href=#45切片中的隐藏数据><strong>45.切片中的“隐藏”数据</strong></a></li><li><a href=#46切片数据覆盖><strong>46.切片数据覆盖</strong></a></li><li><a href=#47切片中的旧数据><strong>47.切片中的*<em>“旧数据”*</em></strong></a></li><li><a href=#48类型声明和方法><strong>48.类型声明和方法</strong></a></li><li><a href=#49-从for-switch和for-select代码块中-break><strong>49. 从“for switch”和“for select”代码块中 break</strong></a></li><li><a href=#50for语句中的迭代变量和闭包><strong>50.“for”语句中的迭代变量和闭包</strong></a></li><li><a href=#51延迟函数调用参数评估><strong>51.延迟函数调用参数评估</strong></a></li><li><a href=#52延迟函数调用执行><strong>52.延迟函数调用执行</strong></a></li><li><a href=#53失败的类型断言><strong>53.失败的类型断言</strong></a></li><li><a href=#54阻塞的-goroutines-和资源泄漏><strong>54.阻塞的 Goroutines 和资源泄漏</strong></a></li><li><a href=#55不同零大小变量的相同地址><strong>55.不同零大小变量的相同地址</strong></a></li><li><a href=#56iota-的首次使用并不总是从零开始><strong>56.iota 的首次使用并不总是从零开始</strong></a></li><li><a href=#57在值实例上使用指针接收器方法><strong>57.在值实例上使用</strong>指针接收器方法</a></li><li><a href=#58更新-map-值字段><strong>58.更新 map 值字段</strong></a></li><li><a href=#59nil接口和nil接口值><strong>59.“nil”接口和“nil”接口值</strong></a></li><li><a href=#60堆栈和堆变量><strong>60.堆栈和堆变量</strong></a></li><li><a href=#61gomaxprocs并发和并行><strong>61.GOMAXPROCS、并发和并行</strong></a></li><li><a href=#62读写操作重新排序><strong>62.读写操作重新排序</strong></a></li><li><a href=#63抢先调度><strong>63.抢先调度</strong></a></li><li><a href=#64导入-c-和多行导入块><strong>64.导入 C 和多行导入块</strong></a></li><li><a href=#65import-c-和-cgo-注释之间没有空行><strong>65.Import C 和 Cgo 注释之间没有空行</strong></a></li><li><a href=#66不能使用可变参数调用-c-函数><strong>66.不能使用可变参数调用 C 函数</strong></a></li><li><a href=#原文参考httpdevscloudimmunitycomgotchas-and-common-mistakes-in-go-golang><strong><a href=http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/>原文参考</a></strong></a></li></ul></nav></div></div><div class=content id=content><p>Go 是一种简单而有趣的语言，但是，与任何其他语言一样，它也有一些陷阱……其中许多陷阱并不完全是 Go 的错。其中一些错误是自然陷阱。其他是由于错误的假设和缺少细节。</p><h2 id=概述><strong>概述</strong></h2><p><em>初学者:</em></p><ul><li>不能将左大括号放在单独的行上</li><li>未使用的变量</li><li>未使用的进口</li><li>短变量声明只能在函数内部使用</li><li>使用短变量声明重新声明变量</li><li>不能使用短变量声明来设置字段值</li><li>意外变量阴影</li><li>不能使用“nil”来初始化没有显式类型的变量</li><li>使用“nil”切片和映射</li><li>地图容量</li><li>字符串不能为“nil”</li><li>数组函数参数</li><li>切片和数组“范围”子句中的意外值</li><li>切片和数组是一维的</li><li>访问不存在的映射键</li><li>字符串是不可变的</li><li>字符串和字节片之间的转换</li><li>字符串和索引运算符</li><li>字符串并不总是 UTF8 文本</li><li>字符串长度</li><li>多行切片/数组/映射文字中缺少逗号</li><li>log.Fatal 和 log.Panic 不仅仅是日志</li><li>内置数据结构操作不同步</li><li>“范围”子句中字符串的迭代值</li><li>使用“for range”子句遍历地图</li><li>“switch”语句中的失败行为</li><li>增量和减量</li><li>按位非运算符</li><li>运算符优先级差异</li><li>未导出的结构字段未编码</li><li>带有活动 Goroutines 的应用程序退出</li><li>目标接收器准备好后立即返回到无缓冲通道</li><li>发送到关闭的频道会导致恐慌</li><li>使用“零”通道</li><li>带有值接收器的方法不能更改原始值</li></ul><p><em>中级初学者：</em></p><ul><li>关闭 HTTP 响应正文</li><li>关闭 HTTP 连接</li><li>JSON 编码器添加换行符</li><li>JSON 包转义键和字符串值中的特殊 HTML 字符</li><li>将 JSON 数字解组为接口值</li><li>十六进制或其他非 UTF8 转义序列无法使用 JSON 字符串值</li><li>比较结构、数组、切片和映射</li><li>从恐慌中恢复</li><li>更新和引用切片、数组和映射“for range”子句中的项值</li><li>切片中的“隐藏”数据</li><li>切片数据损坏</li><li>“陈旧”切片</li><li>类型声明和方法</li><li>打破“for switch”和“for select”代码块</li><li>“for”语句中的迭代变量和闭包</li><li>延迟函数调用参数评估</li><li>延迟函数调用执行</li><li>失败的类型断言</li><li>阻塞的 Goroutines 和资源泄漏</li><li>不同零大小变量的相同地址</li><li>iota 的首次使用并不总是从零开始</li></ul><p><em>高级初学者：</em></p><ul><li>在值实例上使用指针接收器方法</li><li>更新 map 值字段</li><li>“nil”接口和“nil”接口值</li><li>堆栈和堆变量</li><li>GOMAXPROCS、并发和并行</li><li>读写操作重新排序</li><li>抢先调度</li></ul><p><em>Cgo（又名勇敢的初学者）：</em></p><ul><li>导入 C 和多行导入块</li><li>Import C 和 Cgo 注释之间没有空行</li><li>不能使用可变参数调用 C 函数</li></ul><h2 id=1不能将左大括号放在单独的行上><strong>1.不能将左大括号放在单独的行上</strong></h2><p>级别：初学者</p><p>在大多数使用大括号的其他语言中，您可以选择放置它们的位置。您可以感谢这种行为的自动分号注入（没有前瞻）。是的，Go 确实有分号 :-)</p><p>Fails:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span>  
<span class=p>{</span> <span class=c1>//error, can&#39;t have the opening brace on a separate line
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;hello there!&#34;</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Compile Error:</p><blockquote><p>/tmp/sandbox826898458/main.go:6: syntax error: unexpected semicolon or newline before {</p></blockquote><p>Works:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;works!&#34;</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=2未使用的变量><strong>2.未使用的变量</strong></h2><p>级别：初学者</p><p>如果您有一个未使用的变量，您的代码将无法编译。不过有一个例外。您必须使用在函数内部声明的变量，但如果您有未使用的全局变量，也可以。有未使用的函数参数也是可以的。</p><p>如果您为未使用的变量分配新值，您的代码仍将无法编译。您需要以某种方式使用变量值来使编译器满意。</p><p>Fails:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>var</span> <span class=nx>gvar</span> <span class=kt>int</span> <span class=c1>//not an error
</span><span class=c1></span>
<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>one</span> <span class=kt>int</span>   <span class=c1>//error, unused variable
</span><span class=c1></span>    <span class=nx>two</span> <span class=o>:=</span> <span class=mi>2</span>      <span class=c1>//error, unused variable
</span><span class=c1></span>    <span class=kd>var</span> <span class=nx>three</span> <span class=kt>int</span> <span class=c1>//error, even though it&#39;s assigned 3 on the next line
</span><span class=c1></span>    <span class=nx>three</span> <span class=p>=</span> <span class=mi>3</span>

    <span class=kd>func</span><span class=p>(</span><span class=nx>unused</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Unused arg. No compile error&#34;</span><span class=p>)</span>
    <span class=p>}(</span><span class=s>&#34;what?&#34;</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Compile Errors:</p><blockquote><p>/tmp/sandbox473116179/main.go:6: one declared and not used /tmp/sandbox473116179/main.go:7: two declared and not used /tmp/sandbox473116179/main.go:8: three declared and not used</p></blockquote><p>Works:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>one</span> <span class=kt>int</span>
    <span class=nx>_</span> <span class=p>=</span> <span class=nx>one</span>

    <span class=nx>two</span> <span class=o>:=</span> <span class=mi>2</span> 
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>two</span><span class=p>)</span>

    <span class=kd>var</span> <span class=nx>three</span> <span class=kt>int</span> 
    <span class=nx>three</span> <span class=p>=</span> <span class=mi>3</span>
    <span class=nx>one</span> <span class=p>=</span> <span class=nx>three</span>

    <span class=kd>var</span> <span class=nx>four</span> <span class=kt>int</span>
    <span class=nx>four</span> <span class=p>=</span> <span class=nx>four</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Another option is to comment out or remove the unused variables :-)</p><h2 id=3未使用的-import><strong>3.未使用的 import</strong></h2><p>级别：初学者</p><p>如果您在不使用任何导出函数、接口、结构或变量的情况下导入包，您的代码将无法编译。</p><p>如果您确实需要导入的包，可以使用空白标识符_, 作为其包名，以避免编译失败。空白标识符用于导入包的副作用。</p><p>Fails:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;log&#34;</span>
    <span class=s>&#34;time&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Compile Errors:</p><blockquote><p>/tmp/sandbox627475386/main.go:4: imported and not used:</p><p>&ldquo;fmt&rdquo; /tmp/sandbox627475386/main.go:5: imported and not used:</p><p>&ldquo;log&rdquo; /tmp/sandbox627475386/main.go:6: imported and not used: &ldquo;time&rdquo;</p></blockquote><p>Works:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=nx>_</span> <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;log&#34;</span>
    <span class=s>&#34;time&#34;</span>
<span class=p>)</span>

<span class=kd>var</span> <span class=nx>_</span> <span class=p>=</span> <span class=nx>log</span><span class=p>.</span><span class=nx>Println</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>_</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Now</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=4短变量声明只能在函数内部使用><strong>4.短变量声明只能在函数内部使用</strong></h2><p>级别：初学者</p><p>Fails:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=nx>myvar</span> <span class=o>:=</span> <span class=mi>1</span> <span class=c1>//error
</span><span class=c1></span>
<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Compile Error:</p><blockquote><p>/tmp/sandbox265716165/main.go:3: non-declaration statement outside function body</p></blockquote><p>Works:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>var</span> <span class=nx>myvar</span> <span class=p>=</span> <span class=mi>1</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=5使用短变量声明重新声明变量><strong>5.使用短变量声明重新声明变量</strong></h2><p>级别：初学者</p><p>您不能在独立语句中重新声明变量，但在至少声明一个新变量的多变量声明中是允许的。</p><p>重新声明的变量必须在同一个块中，否则您最终会得到一个阴影变量。</p><p>Fails:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>one</span> <span class=o>:=</span> <span class=mi>0</span>
    <span class=nx>one</span> <span class=o>:=</span> <span class=mi>1</span> <span class=c1>//error
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Compile Error:</p><blockquote><p>/tmp/sandbox706333626/main.go:5: no new variables on left side of :=</p></blockquote><p>Works:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>one</span> <span class=o>:=</span> <span class=mi>0</span>
    <span class=nx>one</span><span class=p>,</span> <span class=nx>two</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>,</span><span class=mi>2</span>

    <span class=nx>one</span><span class=p>,</span><span class=nx>two</span> <span class=p>=</span> <span class=nx>two</span><span class=p>,</span><span class=nx>one</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=6不能使用短变量声明来设置字段值><strong>6.不能使用短变量声明来设置字段值</strong></h2><p>级别：初学者</p><ul><li></li></ul><p>Fails:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
  <span class=s>&#34;fmt&#34;</span>
<span class=p>)</span>

<span class=kd>type</span> <span class=nx>info</span> <span class=kd>struct</span> <span class=p>{</span>  
  <span class=nx>result</span> <span class=kt>int</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>work</span><span class=p>()</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span><span class=kt>error</span><span class=p>)</span> <span class=p>{</span>  
    <span class=k>return</span> <span class=mi>13</span><span class=p>,</span><span class=kc>nil</span>  
  <span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
  <span class=kd>var</span> <span class=nx>data</span> <span class=nx>info</span>

  <span class=nx>data</span><span class=p>.</span><span class=nx>result</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>work</span><span class=p>()</span> <span class=c1>//error
</span><span class=c1></span>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;info: %+v\n&#34;</span><span class=p>,</span><span class=nx>data</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Compile Error:</p><blockquote><p>prog.go:18: non-name data.result on left side of :=</p></blockquote><p>使用临时变量或预先声明所有变量并使用标准赋值运算符。</p><p>Works:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
  <span class=s>&#34;fmt&#34;</span>
<span class=p>)</span>

<span class=kd>type</span> <span class=nx>info</span> <span class=kd>struct</span> <span class=p>{</span>  
  <span class=nx>result</span> <span class=kt>int</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>work</span><span class=p>()</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span><span class=kt>error</span><span class=p>)</span> <span class=p>{</span>  
    <span class=k>return</span> <span class=mi>13</span><span class=p>,</span><span class=kc>nil</span>  
  <span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
  <span class=kd>var</span> <span class=nx>data</span> <span class=nx>info</span>

  <span class=kd>var</span> <span class=nx>err</span> <span class=kt>error</span>
  <span class=nx>data</span><span class=p>.</span><span class=nx>result</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nf>work</span><span class=p>()</span> <span class=c1>//ok
</span><span class=c1></span>  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
    <span class=k>return</span>
  <span class=p>}</span>

  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;info: %+v\n&#34;</span><span class=p>,</span><span class=nx>data</span><span class=p>)</span> <span class=c1>//prints: info: {result:13}
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=7变量覆盖variable-shadowing><strong>7.变量覆盖（Variable Shadowing）</strong></h2><p>级别：初学者</p><p>简短的变量声明语法非常方便（特别是对于那些来自动态语言的语言），很容易将其视为常规赋值操作。如果您在新代码块中犯了这个错误，则不会出现编译器错误，但您的应用程序不会按照您的预期执行。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>x</span> <span class=o>:=</span> <span class=mi>1</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span>     <span class=c1>//prints 1
</span><span class=c1></span>    <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span> <span class=c1>//prints 1
</span><span class=c1></span>        <span class=nx>x</span> <span class=o>:=</span> <span class=mi>2</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span> <span class=c1>//prints 2
</span><span class=c1></span>    <span class=p>}</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span>     <span class=c1>//prints 1 (bad if you need 2)
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>即使对于经验丰富的 Go 开发人员来说，这也是一个非常常见的陷阱。它很容易制作，而且很难被发现。</p><p>您可以使用该vet命令来查找其中的一些问题。默认情况下，vet不会执行任何阴影变量检查。确保使用-shadow标志：<em>go tool vet -shadow your_file.go</em></p><p>请注意，该vet命令不会报告所有阴影变量。用于go-nyet更积极的阴影变量检测。</p><h2 id=8不能使用nil来初始化没有显式类型的变量><strong>8.不能使用“nil”来初始化没有显式类型的变量</strong></h2><p>级别：初学者</p><p>“nil”标识符可用作接口、函数、指针、映射、切片和通道的“零值”。如果您不指定变量类型，编译器将无法编译您的代码，因为它无法猜测类型。</p><p>Fails:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>x</span> <span class=p>=</span> <span class=kc>nil</span> <span class=c1>//error
</span><span class=c1></span>
    <span class=nx>_</span> <span class=p>=</span> <span class=nx>x</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Compile Error:</p><blockquote><p>/tmp/sandbox188239583/main.go:4: use of untyped nil</p></blockquote><p>Works:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>x</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>=</span> <span class=kc>nil</span>

    <span class=nx>_</span> <span class=p>=</span> <span class=nx>x</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=9使用nil切片和映射><strong>9.使用“nil”切片和映射</strong></h2><p>级别：初学者</p><p>可以将元素添加到“nil”切片，但对 map 执行相同操作会产生运行时panic 。</p><p>Works:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>gopackage</span> <span class=nx>main</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span>
    <span class=nx>s</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span><span class=mi>1</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Fails:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>m</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span>
    <span class=nx>m</span><span class=p>[</span><span class=s>&#34;one&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span> <span class=c1>//error
</span><span class=c1></span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=10map-容量><strong>10.map 容量</strong></h2><p>级别：初学者</p><p>您可以在创建 map 时指定容量，但不能使用cap(map)函数计算容量。这是跟slice的不同点。</p><p>Fails:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>m</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>,</span><span class=mi>99</span><span class=p>)</span>
    <span class=nb>cap</span><span class=p>(</span><span class=nx>m</span><span class=p>)</span> <span class=c1>//error
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Compile Error:</p><blockquote><p>/tmp/sandbox326543983/main.go:5: invalid argument m (type map[string]int) for cap</p></blockquote><h2 id=11字符串不能为nil><strong>11.字符串不能为“nil”</strong></h2><p>级别：初学者</p><p>对于习惯于将“nil”标识符分配给字符串变量的开发人员来说，这是一个陷阱。</p><p>Fails:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>x</span> <span class=kt>string</span> <span class=p>=</span> <span class=kc>nil</span> <span class=c1>//error
</span><span class=c1></span>
    <span class=k>if</span> <span class=nx>x</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span> <span class=c1>//error
</span><span class=c1></span>        <span class=nx>x</span> <span class=p>=</span> <span class=s>&#34;default&#34;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Compile Errors:</p><blockquote><p>/tmp/sandbox630560459/main.go:4: cannot use nil as type string in assignment</p><p>/tmp/sandbox630560459/main.go:6: invalid operation: x == nil (mismatched types string and nil)</p></blockquote><p>Works:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>x</span> <span class=kt>string</span> <span class=c1>//defaults to &#34;&#34; (zero value)
</span><span class=c1></span>
    <span class=k>if</span> <span class=nx>x</span> <span class=o>==</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
        <span class=nx>x</span> <span class=p>=</span> <span class=s>&#34;default&#34;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=12数组函数参数数组指针类型><strong>12.数组函数参数：数组指针类型</strong></h2><p>级别：初学者</p><p>如果您是 C 或 C++ 开发人员，那么您的数组就是指针。当您将数组传递给函数时，函数引用相同的内存位置，因此它们可以更新原始数据。Go 中的数组是值，因此当您将数组传递给函数时，函数会获取原始数组数据的副本。如果您尝试更新数组数据，这可能是个问题。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>x</span> <span class=o>:=</span> <span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>}</span>

    <span class=kd>func</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=mi>7</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span> <span class=c1>//prints [7 2 3]
</span><span class=c1></span>    <span class=p>}(</span><span class=nx>x</span><span class=p>)</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span> <span class=c1>//prints [1 2 3] (not ok if you need [7 2 3])
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p><em>如果您需要更新原始数组数据，请使用数组指针类型。</em></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>x</span> <span class=o>:=</span> <span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>}</span>

    <span class=kd>func</span><span class=p>(</span><span class=nx>arr</span> <span class=o>*</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
        <span class=p>(</span><span class=o>*</span><span class=nx>arr</span><span class=p>)[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=mi>7</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span> <span class=c1>//prints &amp;[7 2 3]
</span><span class=c1></span>    <span class=p>}(</span><span class=o>&amp;</span><span class=nx>x</span><span class=p>)</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span> <span class=c1>//prints [7 2 3]
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>另一种选择是使用切片。即使您的函数获得了切片变量的副本，它仍然引用原始数据。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>x</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>}</span>

    <span class=kd>func</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=mi>7</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span> <span class=c1>//prints [7 2 3]
</span><span class=c1></span>    <span class=p>}(</span><span class=nx>x</span><span class=p>)</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span> <span class=c1>//prints [7 2 3]
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=13切片和数组range子句中的意外值><strong>13.切片和数组“range”子句中的意外值</strong></h2><p>级别：初学者</p><p>如果您习惯了其他语言中的“for-in”或“foreach”语句，就会发生这种情况。Go 中的“范围”子句是不同的。它生成两个值：第一个值是项目索引，而第二个值是项目数据。</p><p>Bad:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>x</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;a&#34;</span><span class=p>,</span><span class=s>&#34;b&#34;</span><span class=p>,</span><span class=s>&#34;c&#34;</span><span class=p>}</span>

    <span class=k>for</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>x</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span> <span class=c1>//prints 0, 1, 2
</span><span class=c1></span>    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Good:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>x</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;a&#34;</span><span class=p>,</span><span class=s>&#34;b&#34;</span><span class=p>,</span><span class=s>&#34;c&#34;</span><span class=p>}</span>

    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>x</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span> <span class=c1>//prints a, b, c
</span><span class=c1></span>    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=14切片和数组是一维的><strong>14.切片和数组是一维的</strong></h2><p>级别：初学者</p><p>看起来 Go 似乎支持多维数组和切片，但事实并非如此。但是，可以创建数组数组或切片切片。对于依赖动态多维数组的数值计算应用程序，它在性能和复杂性方面远非理想。</p><p>您可以使用原始一维数组、“独立”切片的切片和“共享数据”切片的切片来构建动态多维数组。</p><p>如果您使用原始一维数组，您需要在数组需要增长时负责索引、边界检查和内存重新分配。</p><p>使用“独立”切片的切片创建动态多维数组是一个两步过程。首先，您必须创建外部切片。然后，您必须分配每个内部切片。内部切片彼此独立。您可以在不影响其他内部切片的情况下扩展和收缩它们。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>x</span> <span class=o>:=</span> <span class=mi>2</span>
    <span class=nx>y</span> <span class=o>:=</span> <span class=mi>4</span>

    <span class=nx>table</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([][]</span><span class=kt>int</span><span class=p>,</span><span class=nx>x</span><span class=p>)</span>
    <span class=k>for</span> <span class=nx>i</span><span class=o>:=</span> <span class=k>range</span> <span class=nx>table</span> <span class=p>{</span>
        <span class=nx>table</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span><span class=nx>y</span><span class=p>)</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>使用“共享数据”切片创建动态多维数组是一个三步过程。首先，您必须创建将保存原始数据的数据“容器”切片。然后，您创建外部切片。最后，通过重新切片原始数据切片来初始化每个内部切片。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>h</span><span class=p>,</span> <span class=nx>w</span> <span class=o>:=</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>4</span>

    <span class=nx>raw</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span><span class=nx>h</span><span class=o>*</span><span class=nx>w</span><span class=p>)</span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>raw</span> <span class=p>{</span>
        <span class=nx>raw</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>i</span>
    <span class=p>}</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>raw</span><span class=p>,</span><span class=o>&amp;</span><span class=nx>raw</span><span class=p>[</span><span class=mi>4</span><span class=p>])</span>
    <span class=c1>//prints: [0 1 2 3 4 5 6 7] &lt;ptr_addr_x&gt;
</span><span class=c1></span>
    <span class=nx>table</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([][]</span><span class=kt>int</span><span class=p>,</span><span class=nx>h</span><span class=p>)</span>
    <span class=k>for</span> <span class=nx>i</span><span class=o>:=</span> <span class=k>range</span> <span class=nx>table</span> <span class=p>{</span>
        <span class=nx>table</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>raw</span><span class=p>[</span><span class=nx>i</span><span class=o>*</span><span class=nx>w</span><span class=p>:</span><span class=nx>i</span><span class=o>*</span><span class=nx>w</span> <span class=o>+</span> <span class=nx>w</span><span class=p>]</span>
    <span class=p>}</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>table</span><span class=p>,</span><span class=o>&amp;</span><span class=nx>table</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>])</span>
    <span class=c1>//prints: [[0 1 2 3] [4 5 6 7]] &lt;ptr_addr_x&gt;
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>有一个针对多维数组和切片的规范/建议，但目前看来它是一个低优先级的功能。</p><h2 id=15访问不存在的map的key><strong>15.访问不存在的map的key</strong></h2><p>级别：初学者</p><p>对于希望获得“nil”标识符的开发人员来说，这是一个陷阱（就像在其他语言中所做的那样）。如果相应数据类型的“零值”为“nil”，则返回值为“nil”，但对于其他数据类型则不同。检查适当的“零值”可用于确定映射记录是否存在，但它并不总是可靠的（例如，如果您有一个布尔映射，其中“零值”为假，您会怎么做）。了解给定map记录是否存在的最可靠方法是检查map访问操作返回的第二个值。</p><p>Bad:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>x</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;one&#34;</span><span class=p>:</span><span class=s>&#34;a&#34;</span><span class=p>,</span><span class=s>&#34;two&#34;</span><span class=p>:</span><span class=s>&#34;&#34;</span><span class=p>,</span><span class=s>&#34;three&#34;</span><span class=p>:</span><span class=s>&#34;c&#34;</span><span class=p>}</span>

    <span class=k>if</span> <span class=nx>v</span> <span class=o>:=</span> <span class=nx>x</span><span class=p>[</span><span class=s>&#34;two&#34;</span><span class=p>];</span> <span class=nx>v</span> <span class=o>==</span> <span class=s>&#34;&#34;</span> <span class=p>{</span> <span class=c1>//incorrect
</span><span class=c1></span>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;no entry&#34;</span><span class=p>)</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Good:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>x</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;one&#34;</span><span class=p>:</span><span class=s>&#34;a&#34;</span><span class=p>,</span><span class=s>&#34;two&#34;</span><span class=p>:</span><span class=s>&#34;&#34;</span><span class=p>,</span><span class=s>&#34;three&#34;</span><span class=p>:</span><span class=s>&#34;c&#34;</span><span class=p>}</span>

    <span class=k>if</span> <span class=nx>_</span><span class=p>,</span><span class=nx>ok</span> <span class=o>:=</span> <span class=nx>x</span><span class=p>[</span><span class=s>&#34;two&#34;</span><span class=p>];</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;no entry&#34;</span><span class=p>)</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=16字符串是不可变的><strong>16.字符串是不可变的</strong></h2><p>级别：初学者</p><p>尝试使用索引运算符更新字符串变量中的单个字符将导致失败。字符串是只读字节切片（带有一些额外的属性）。如果确实需要更新字符串，则在必要时使用字节切片而不是将其转换为字符串类型。</p><p>Fails:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>x</span> <span class=o>:=</span> <span class=s>&#34;text&#34;</span>
    <span class=nx>x</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=sc>&#39;T&#39;</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Compile Error:</p><blockquote><p>/tmp/sandbox305565531/main.go:7: cannot assign to x[0]</p></blockquote><p>Works:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>x</span> <span class=o>:=</span> <span class=s>&#34;text&#34;</span>
    <span class=nx>xbytes</span> <span class=o>:=</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span>
    <span class=nx>xbytes</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=sc>&#39;T&#39;</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>xbytes</span><span class=p>))</span> <span class=c1>//prints Text
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>请注意，这实际上并不是更新文本字符串中字符的正确方法，因为给定的字符可以存储在多个字节中。如果您确实需要对文本字符串进行更新，请先将其转换为符文切片。即使使用符文切片，单个字符也可能跨越多个符文，例如，如果您有带有重音的字符，就会发生这种情况。“字符”的这种复杂和模棱两可的性质是 Go 字符串被表示为字节序列的原因。</p><h2 id=17字符串和字节片之间的转换><strong>17.字符串和字节片之间的转换</strong></h2><p>级别：初学者</p><p>当您将字符串转换为字节切片（反之亦然）时，您将获得原始数据的完整副本。它不像其他语言中的强制转换操作，也不像重新切片新切片变量指向原始字节切片使用的相同底层数组的位置。</p><p>Go 确实对 <code>[]byte</code> to <code>string</code> 和 <code>string</code> to <code>[]byte</code>转换进行了一些优化，以避免额外的分配（对 todo 列表进行了更多优化）。</p><p>当 <code>[]byte</code> 键用于查找 <code>map[string]</code> 集合中的条目时，第一个优化避免了额外的分配：<code>m[string(key)]</code></p><p>第二个优化避免了 <code>for range</code>字符串转换为<code>[]byte</code>:的子句中的额外分配for i,v := range []byte(str) {&mldr;}</p><h2 id=18字符串和索引运算符><strong>18.字符串和索引运算符</strong></h2><p>级别：初学者</p><p>字符串上的索引运算符返回一个字节值，而不是一个字符（就像在其他语言中所做的那样）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>x</span> <span class=o>:=</span> <span class=s>&#34;text&#34;</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>x</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=c1>//print 116
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%T&#34;</span><span class=p>,</span><span class=nx>x</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=c1>//prints uint8
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>如果您需要访问特定的字符串“字符”（unicode 代码点/符文），请使用该for range子句。官方的“unicode/utf8”包和实验性的utf8string包（golang.org/x/exp/utf8string）也很有用。utf8string 包包含一个方便的At()方法。将字符串转换为一片符文也是一种选择。</p><h2 id=19字符串并不总是-utf8-文本><strong>19.字符串并不总是 UTF8 文本</strong></h2><p>级别：初学者</p><p>字符串值不需要是 UTF8 文本。它们可以包含任意字节。字符串是 UTF8 的唯一时间是使用字符串文字时。即使这样，它们也可以使用转义序列包含其他数据。</p><p>要知道您是否有 UTF8 文本字符串，请使用ValidString()“unicode/utf8”包中的函数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;unicode/utf8&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>data1</span> <span class=o>:=</span> <span class=s>&#34;ABC&#34;</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>utf8</span><span class=p>.</span><span class=nf>ValidString</span><span class=p>(</span><span class=nx>data1</span><span class=p>))</span> <span class=c1>//prints: true
</span><span class=c1></span>
    <span class=nx>data2</span> <span class=o>:=</span> <span class=s>&#34;A\xfeC&#34;</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>utf8</span><span class=p>.</span><span class=nf>ValidString</span><span class=p>(</span><span class=nx>data2</span><span class=p>))</span> <span class=c1>//prints: false
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=20字符串长度><strong>20.字符串长度</strong></h2><p>级别：初学者</p><p>假设您是一名 python 开发人员，并且您有以下代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>data = u&#39;♥&#39;  
print(len(data)) #prints: 1  
</code></pre></td></tr></table></div></div><p>当您将其转换为类似的 Go 代码片段时，您可能会感到惊讶。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>data</span> <span class=o>:=</span> <span class=s>&#34;♥&#34;</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>data</span><span class=p>))</span> <span class=c1>//prints: 3
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>内置len()函数返回字节数，而不是像 Python 中的 unicode 字符串那样返回字符数。</p><p>要在 Go 中获得相同的结果，请使用 <em>RuneCountInString()</em> “unicode/utf8”包中的函数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;unicode/utf8&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>data</span> <span class=o>:=</span> <span class=s>&#34;♥&#34;</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>utf8</span><span class=p>.</span><span class=nf>RuneCountInString</span><span class=p>(</span><span class=nx>data</span><span class=p>))</span> <span class=c1>//prints: 1
</span></code></pre></td></tr></table></div></div><p>从技术上讲，该RuneCountInString()函数不返回字符数，因为单个字符可能跨越多个符文。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;unicode/utf8&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>data</span> <span class=o>:=</span> <span class=s>&#34;é&#34;</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>data</span><span class=p>))</span>                    <span class=c1>//prints: 3
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>utf8</span><span class=p>.</span><span class=nf>RuneCountInString</span><span class=p>(</span><span class=nx>data</span><span class=p>))</span> <span class=c1>//prints: 2
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=21多行切片数组和映射文字中缺少逗号><strong>21.多行切片、数组和映射文字中缺少逗号</strong></h2><p>级别：初学者</p><p>Fails:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>x</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span>
    <span class=mi>1</span><span class=p>,</span>
    <span class=mi>2</span> <span class=c1>//error
</span><span class=c1></span>    <span class=p>}</span>
    <span class=nx>_</span> <span class=p>=</span> <span class=nx>x</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Compile Errors:</p><blockquote><p>/tmp/sandbox367520156/main.go:6: syntax error: need trailing comma before newline in composite literal /tmp/sandbox367520156/main.go:8: non-declaration statement outside function body /tmp/sandbox367520156/main.go:9: syntax error: unexpected }</p></blockquote><p>Works:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>x</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span>
    <span class=mi>1</span><span class=p>,</span>
    <span class=mi>2</span><span class=p>,</span>
    <span class=p>}</span>
    <span class=nx>x</span> <span class=p>=</span> <span class=nx>x</span>

    <span class=nx>y</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>,}</span> <span class=c1>//no error
</span><span class=c1></span>    <span class=nx>y</span> <span class=p>=</span> <span class=nx>y</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>如果在将声明折叠为一行时留下尾随逗号，则不会出现编译器错误。</p><h2 id=22logfatal-和-logpanic-不仅仅是日志><strong>22.log.Fatal 和 log.Panic 不仅仅是日志</strong></h2><p>级别：初学者</p><p>日志库通常提供不同的日志级别。Fatal*()不像那些日志库，如果你调用Fatal*()和Panic*()函数，Go 中的日志包不仅仅做日志。当您的应用调用这些函数时，Go 也会终止您的应用 :-)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;log&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>log</span><span class=p>.</span><span class=nf>Fatalln</span><span class=p>(</span><span class=s>&#34;Fatal Level: log entry&#34;</span><span class=p>)</span> <span class=c1>//app exits here
</span><span class=c1></span>    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Normal Level: log entry&#34;</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=23内置数据结构操作不同步><strong>23.内置数据结构操作不同步</strong></h2><p>级别：初学者</p><p>尽管 Go 有许多原生支持并发的特性，但并发安全数据集合并不是其中之一 :-) 确保数据集合更新是原子的是您的责任。Goroutines 和 channels 是实现这些原子操作的推荐方式，但如果它对您的应用程序有意义，您也可以利用“sync”包。</p><h2 id=24range子句中字符串的迭代值>24.<strong>“range”子句中字符串的迭代值</strong></h2><p>级别：初学者</p><p>索引值（“range”操作返回的第一个值）是第二个值中返回的当前“字符”（unicode 码点/符文）的第一个字节的索引。它不是当前“字符”的索引，就像在其他语言中所做的那样。请注意，一个实际角色可能由多个符文表示。如果您需要使用字符，请务必查看“规范”包 (golang.org/x/text/unicode/norm)。</p><p>带有字符串变量的for range子句将尝试将数据解释为 UTF8 文本。对于它不理解的任何字节序列，它将返回 0xfffd 符文（又名 unicode 替换字符）而不是实际数据。如果您在字符串变量中存储了任意（非 UTF8 文本）数据，请确保将它们转换为字节切片以按原样获取所有存储的数据。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>data</span> <span class=o>:=</span> <span class=s>&#34;A\xfe\x02\xff\x04&#34;</span>
    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span><span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>data</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%#x &#34;</span><span class=p>,</span><span class=nx>v</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=c1>//prints: 0x41 0xfffd 0x2 0xfffd 0x4 (not ok)
</span><span class=c1></span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>()</span>
    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span><span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%#x &#34;</span><span class=p>,</span><span class=nx>v</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=c1>//prints: 0x41 0xfe 0x2 0xff 0x4 (good)
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=25使用for-range子句遍历map><strong>25.使用“for range”子句遍历map</strong></h2><p>级别：初学者</p><p>如果您希望项目按特定顺序排列（例如，按键值排序），这是一个问题。每次地图迭代都会产生不同的结果。Go 运行时尝试将<strong>迭代顺序随机化</strong>，但它并不总是成功，因此您可能会得到几个相同的map迭代。连续看到 5 次相同的迭代不要感到惊讶。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>m</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=s>&#34;one&#34;</span><span class=p>:</span><span class=mi>1</span><span class=p>,</span><span class=s>&#34;two&#34;</span><span class=p>:</span><span class=mi>2</span><span class=p>,</span><span class=s>&#34;three&#34;</span><span class=p>:</span><span class=mi>3</span><span class=p>,</span><span class=s>&#34;four&#34;</span><span class=p>:</span><span class=mi>4</span><span class=p>}</span>
    <span class=k>for</span> <span class=nx>k</span><span class=p>,</span><span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>m</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>k</span><span class=p>,</span><span class=nx>v</span><span class=p>)</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>如果您使用 Go Playground ( <a href=https://play.golang.org/>https://play.golang.org/</a> )，您将始终获得相同的结果，因为除非您进行更改，否则它不会重新编译代码。</p><h2 id=26switch语句中的失败行为><strong>26.“switch”语句中的失败行为</strong></h2><p>级别：初学者</p><p>默认情况下，<em>“switch”语句中的“case”块会中断</em>。这与其他语言不同，其他语言的默认行为是进入下一个“case”块。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>isSpace</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>ch</span> <span class=kt>byte</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
        <span class=k>switch</span><span class=p>(</span><span class=nx>ch</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>case</span> <span class=sc>&#39; &#39;</span><span class=p>:</span> <span class=c1>//error
</span><span class=c1></span>        <span class=k>case</span> <span class=sc>&#39;\t&#39;</span><span class=p>:</span>
            <span class=k>return</span> <span class=kc>true</span>
        <span class=p>}</span>
        <span class=k>return</span> <span class=kc>false</span>
    <span class=p>}</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>isSpace</span><span class=p>(</span><span class=sc>&#39;\t&#39;</span><span class=p>))</span> <span class=c1>//prints true (ok)
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>isSpace</span><span class=p>(</span><span class=sc>&#39; &#39;</span><span class=p>))</span>  <span class=c1>//prints false (not ok)
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>您可以通过在每个“case”块末尾使用“<em>fallthrough</em>”语句来强制“case”块通过。您还可以重写您的 switch 语句以在“case”块中使用表达式列表。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>isSpace</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>ch</span> <span class=kt>byte</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
        <span class=k>switch</span><span class=p>(</span><span class=nx>ch</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>case</span> <span class=sc>&#39; &#39;</span><span class=p>,</span> <span class=sc>&#39;\t&#39;</span><span class=p>:</span>
            <span class=k>return</span> <span class=kc>true</span>
        <span class=p>}</span>
        <span class=k>return</span> <span class=kc>false</span>
    <span class=p>}</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>isSpace</span><span class=p>(</span><span class=sc>&#39;\t&#39;</span><span class=p>))</span> <span class=c1>//prints true (ok)
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>isSpace</span><span class=p>(</span><span class=sc>&#39; &#39;</span><span class=p>))</span>  <span class=c1>//prints true (ok)
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=27增量和减量><strong>27.增量和减量</strong></h2><p>级别：初学者</p><p>许多语言都有递增和递减运算符。与其他语言不同，Go 不支持操作的前缀版本。您也不能在表达式中使用这两个运算符。</p><p>Fails:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>data</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>}</span>
    <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span>
    <span class=o>++</span><span class=nx>i</span> <span class=c1>//error
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>data</span><span class=p>[</span><span class=nx>i</span><span class=o>++</span><span class=p>])</span> <span class=c1>//error
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Compile Errors:</p><blockquote><p>/tmp/sandbox101231828/main.go:8: syntax error: unexpected ++</p><p>/tmp/sandbox101231828/main.go:9: syntax error: unexpected ++, expecting :</p></blockquote><p>Works:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>data</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>}</span>
    <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span>
    <span class=nx>i</span><span class=o>++</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>data</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=28按位非运算符><strong>28.按位非运算符</strong></h2><p>级别：初学者</p><p>许多语言使用~一元 NOT 运算符（也称为按位补码），但 Go 重用了 XOR 运算符 ( ^)。</p><p>Fails:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=err>~</span><span class=mi>2</span><span class=p>)</span> <span class=c1>//error
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Compile Error:</p><blockquote><p>/tmp/sandbox965529189/main.go:6: the bitwise complement operator is ^</p></blockquote><p>Works:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>d</span> <span class=kt>uint8</span> <span class=p>=</span> <span class=mi>2</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%08b\n&#34;</span><span class=p>,^</span><span class=nx>d</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Go 仍然使用^XOR 运算符，这可能会让一些人感到困惑。</p><p>如果您愿意，您可以NOT 0x02用二进制 XOR 运算（例如）来表示一元 NOT 运算（例如0x02 XOR 0xff）。这可以解释为什么^要重用来表示一元 NOT 操作。</p><p>Go 还有一个特殊的“AND NOT”位运算符 ( &^)，这增加了 NOT 运算符的混淆。它看起来像是一个A AND (NOT B)不需要括号就可以支持的特殊功能/hack。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>a</span> <span class=kt>uint8</span> <span class=p>=</span> <span class=mh>0x82</span>
    <span class=kd>var</span> <span class=nx>b</span> <span class=kt>uint8</span> <span class=p>=</span> <span class=mh>0x02</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%08b [A]\n&#34;</span><span class=p>,</span><span class=nx>a</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%08b [B]\n&#34;</span><span class=p>,</span><span class=nx>b</span><span class=p>)</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%08b (NOT B)\n&#34;</span><span class=p>,^</span><span class=nx>b</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%08b ^ %08b = %08b [B XOR 0xff]\n&#34;</span><span class=p>,</span><span class=nx>b</span><span class=p>,</span><span class=mh>0xff</span><span class=p>,</span><span class=nx>b</span> <span class=p>^</span> <span class=mh>0xff</span><span class=p>)</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%08b ^ %08b = %08b [A XOR B]\n&#34;</span><span class=p>,</span><span class=nx>a</span><span class=p>,</span><span class=nx>b</span><span class=p>,</span><span class=nx>a</span> <span class=p>^</span> <span class=nx>b</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%08b &amp; %08b = %08b [A AND B]\n&#34;</span><span class=p>,</span><span class=nx>a</span><span class=p>,</span><span class=nx>b</span><span class=p>,</span><span class=nx>a</span> <span class=o>&amp;</span> <span class=nx>b</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%08b &amp;^%08b = %08b [A &#39;AND NOT&#39; B]\n&#34;</span><span class=p>,</span><span class=nx>a</span><span class=p>,</span><span class=nx>b</span><span class=p>,</span><span class=nx>a</span> <span class=o>&amp;^</span> <span class=nx>b</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%08b&amp;(^%08b)= %08b [A AND (NOT B)]\n&#34;</span><span class=p>,</span><span class=nx>a</span><span class=p>,</span><span class=nx>b</span><span class=p>,</span><span class=nx>a</span> <span class=o>&amp;</span> <span class=p>(^</span><span class=nx>b</span><span class=p>))</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=29运算符优先级差异><strong>29.运算符优先级差异</strong></h2><p>级别：初学者</p><p>除了“bit clear”操作符（&^）之外，Go 有一组标准操作符，许多其他语言都共享这些操作符。但是，运算符的优先级并不总是相同的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;0x2 &amp; 0x2 + 0x4 -&gt; %#x\n&#34;</span><span class=p>,</span><span class=mh>0x2</span> <span class=o>&amp;</span> <span class=mh>0x2</span> <span class=o>+</span> <span class=mh>0x4</span><span class=p>)</span>
    <span class=c1>//prints: 0x2 &amp; 0x2 + 0x4 -&gt; 0x6
</span><span class=c1></span>    <span class=c1>//Go:    (0x2 &amp; 0x2) + 0x4
</span><span class=c1></span>    <span class=c1>//C++:    0x2 &amp; (0x2 + 0x4) -&gt; 0x2
</span><span class=c1></span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;0x2 + 0x2 &lt;&lt; 0x1 -&gt; %#x\n&#34;</span><span class=p>,</span><span class=mh>0x2</span> <span class=o>+</span> <span class=mh>0x2</span> <span class=o>&lt;&lt;</span> <span class=mh>0x1</span><span class=p>)</span>
    <span class=c1>//prints: 0x2 + 0x2 &lt;&lt; 0x1 -&gt; 0x6
</span><span class=c1></span>    <span class=c1>//Go:     0x2 + (0x2 &lt;&lt; 0x1)
</span><span class=c1></span>    <span class=c1>//C++:   (0x2 + 0x2) &lt;&lt; 0x1 -&gt; 0x8
</span><span class=c1></span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;0xf | 0x2 ^ 0x2 -&gt; %#x\n&#34;</span><span class=p>,</span><span class=mh>0xf</span> <span class=p>|</span> <span class=mh>0x2</span> <span class=p>^</span> <span class=mh>0x2</span><span class=p>)</span>
    <span class=c1>//prints: 0xf | 0x2 ^ 0x2 -&gt; 0xd
</span><span class=c1></span>    <span class=c1>//Go:    (0xf | 0x2) ^ 0x2
</span><span class=c1></span>    <span class=c1>//C++:    0xf | (0x2 ^ 0x2) -&gt; 0xf
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=30未导出的结构字段未编码><strong>30.未导出的结构字段未编码</strong></h2><p>级别：初学者</p><p>以小写字母开头的结构字段不会被（json、xml、gob 等）编码，因此当您解码结构时，您最终会在那些未导出的字段中得到零值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;encoding/json&#34;</span>
<span class=p>)</span>

<span class=kd>type</span> <span class=nx>MyData</span> <span class=kd>struct</span> <span class=p>{</span>  
    <span class=nx>One</span> <span class=kt>int</span>
    <span class=nx>two</span> <span class=kt>string</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>in</span> <span class=o>:=</span> <span class=nx>MyData</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=s>&#34;two&#34;</span><span class=p>}</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%#v\n&#34;</span><span class=p>,</span><span class=nx>in</span><span class=p>)</span> <span class=c1>//prints main.MyData{One:1, two:&#34;two&#34;}
</span><span class=c1></span>
    <span class=nx>encoded</span><span class=p>,</span><span class=nx>_</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Marshal</span><span class=p>(</span><span class=nx>in</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>encoded</span><span class=p>))</span> <span class=c1>//prints {&#34;One&#34;:1}
</span><span class=c1></span>
    <span class=kd>var</span> <span class=nx>out</span> <span class=nx>MyData</span>
    <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>encoded</span><span class=p>,</span><span class=o>&amp;</span><span class=nx>out</span><span class=p>)</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%#v\n&#34;</span><span class=p>,</span><span class=nx>out</span><span class=p>)</span> <span class=c1>//prints main.MyData{One:1, two:&#34;&#34;}
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=31带有活动-goroutines-的应用程序退出><strong>31.带有活动 Goroutines 的应用程序退出</strong></h2><p>级别：初学者</p><p>该应用程序不会等待您所有的 goroutine 完成。对于一般初学者来说，这是一个常见的错误。每个人都从某个地方开始，所以犯新手错误并不可耻:-)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;time&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>workerCount</span> <span class=o>:=</span> <span class=mi>2</span>

    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>workerCount</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
        <span class=k>go</span> <span class=nf>doit</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;all done!&#34;</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>doit</span><span class=p>(</span><span class=nx>workerId</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>  
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;[%v] is running\n&#34;</span><span class=p>,</span><span class=nx>workerId</span><span class=p>)</span>
    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>3</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;[%v] is done\n&#34;</span><span class=p>,</span><span class=nx>workerId</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>You&rsquo;ll see:</p><blockquote><p>[0] is running
[1] is running
all done!</p></blockquote><p>最常见的解决方案之一是使用“WaitGroup”变量。它将允许主 goroutine 等待，直到所有工作 goroutine 完成。如果您的应用程序有长时间运行的带有消息处理循环的工作人员，您还需要一种方法来通知这些 goroutine 是时候退出了。您可以向每个worker发送“kill”消息。另一种选择是关闭所有工人正在接收的通道。这是一次向所有 goroutine 发出信号的简单方法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;sync&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
    <span class=nx>done</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
    <span class=nx>workerCount</span> <span class=o>:=</span> <span class=mi>2</span>

    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>workerCount</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
        <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
        <span class=k>go</span> <span class=nf>doit</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span><span class=nx>done</span><span class=p>,</span><span class=nx>wg</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=nb>close</span><span class=p>(</span><span class=nx>done</span><span class=p>)</span>
    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;all done!&#34;</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>doit</span><span class=p>(</span><span class=nx>workerId</span> <span class=kt>int</span><span class=p>,</span><span class=nx>done</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{},</span><span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span><span class=p>)</span> <span class=p>{</span>  
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;[%v] is running\n&#34;</span><span class=p>,</span><span class=nx>workerId</span><span class=p>)</span>
    <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
    <span class=o>&lt;-</span> <span class=nx>done</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;[%v] is done\n&#34;</span><span class=p>,</span><span class=nx>workerId</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>如果你运行这个应用程序，你会看到：</p><blockquote><p>[0] is running
[0] is done
[1] is running
[1] is done</p></blockquote><p>看起来worker在主 goroutine 退出之前就完成了。但是! 您还会看到：</p><blockquote><p>fatal error: all goroutines are asleep - deadlock!</p></blockquote><p>那不是很好:-) 发生了什么事？为什么会出现死锁？工人们离开了，他们被处决了wg.Done()。该应用程序应该可以工作。</p><p>发生死锁是因为每个工作人员都获得了原始“WaitGroup”变量的副本。当worker执行wg.Done()时，它对主 goroutine 中的“WaitGroup”变量没有影响。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;sync&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
    <span class=nx>done</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
    <span class=nx>wq</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>interface</span><span class=p>{})</span>
    <span class=nx>workerCount</span> <span class=o>:=</span> <span class=mi>2</span>

    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>workerCount</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
        <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
        <span class=k>go</span> <span class=nf>doit</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span><span class=nx>wq</span><span class=p>,</span><span class=nx>done</span><span class=p>,</span><span class=o>&amp;</span><span class=nx>wg</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>workerCount</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
        <span class=nx>wq</span> <span class=o>&lt;-</span> <span class=nx>i</span>
    <span class=p>}</span>

    <span class=nb>close</span><span class=p>(</span><span class=nx>done</span><span class=p>)</span>
    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;all done!&#34;</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>doit</span><span class=p>(</span><span class=nx>workerId</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>wq</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>interface</span><span class=p>{},</span><span class=nx>done</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{},</span><span class=nx>wg</span> <span class=o>*</span><span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span><span class=p>)</span> <span class=p>{</span>  
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;[%v] is running\n&#34;</span><span class=p>,</span><span class=nx>workerId</span><span class=p>)</span>
    <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
    <span class=k>for</span> <span class=p>{</span>
        <span class=k>select</span> <span class=p>{</span>
        <span class=k>case</span> <span class=nx>m</span> <span class=o>:=</span> <span class=o>&lt;-</span> <span class=nx>wq</span><span class=p>:</span>
            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;[%v] m =&gt; %v\n&#34;</span><span class=p>,</span><span class=nx>workerId</span><span class=p>,</span><span class=nx>m</span><span class=p>)</span>
        <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>done</span><span class=p>:</span>
            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;[%v] is done\n&#34;</span><span class=p>,</span><span class=nx>workerId</span><span class=p>)</span>
            <span class=k>return</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>现在它按预期工作:-)</p><h2 id=32目标接收器准备好后立即返回到无缓冲通道><strong>32.目标接收器准备好后立即返回到无缓冲通道</strong></h2><p>级别：初学者</p><p>在收件人处理您的消息之前，不会阻止发件人。根据您运行代码的机器，接收者 goroutine 可能有也可能没有足够的时间在发送者继续执行之前处理消息。主进程过早结束，导致消息事件会丢失。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>string</span><span class=p>)</span>

    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
        <span class=k>for</span> <span class=nx>m</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>ch</span> <span class=p>{</span>
            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;processed:&#34;</span><span class=p>,</span><span class=nx>m</span><span class=p>)</span>
        <span class=p>}</span>
    <span class=p>}()</span>

    <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=s>&#34;cmd.1&#34;</span>
    <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=s>&#34;cmd.2&#34;</span> <span class=c1>//won&#39;t be processed
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=33发送到关闭的通道会导致panic><strong>33.发送到关闭的通道会导致panic</strong></h2><p>级别：初学者</p><p>从封闭的渠道接收是安全的。接收语句中的ok返回值将被设置为false表示没有接收到数据。如果您从缓冲通道接收，您将首先获取缓冲数据，一旦它为空，ok返回值将为false.</p><p>将数据发送到关闭的通道会导致panic。这是一个记录在案的行为，但对于可能期望发送行为类似于接收行为的新 Go 开发人员来说，这并不是很直观。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;time&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>idx</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
            <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=p>(</span><span class=nx>idx</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=mi>2</span>
        <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=c1>//get the first result
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=o>&lt;-</span><span class=nx>ch</span><span class=p>)</span>
    <span class=nb>close</span><span class=p>(</span><span class=nx>ch</span><span class=p>)</span> <span class=c1>//not ok (you still have other senders)
</span><span class=c1></span>    <span class=c1>//do other work
</span><span class=c1></span>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>根据您的应用程序，修复会有所不同。这可能是一个小的代码更改，或者可能需要更改您的应用程序设计。无论哪种方式，您都需要确保您的应用程序不会尝试将数据发送到关闭的通道。</p><p>错误示例可以通过使用特殊的取消通道来向剩余的工作人员发出不再需要他们的结果的信号来修复。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;time&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
    <span class=nx>done</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>idx</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>select</span> <span class=p>{</span>
            <span class=k>case</span> <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=p>(</span><span class=nx>idx</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=mi>2</span><span class=p>:</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>idx</span><span class=p>,</span><span class=s>&#34;sent result&#34;</span><span class=p>)</span>
            <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>done</span><span class=p>:</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>idx</span><span class=p>,</span><span class=s>&#34;exiting&#34;</span><span class=p>)</span>
            <span class=p>}</span>
        <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=c1>//get first result
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;result:&#34;</span><span class=p>,</span><span class=o>&lt;-</span><span class=nx>ch</span><span class=p>)</span>
    <span class=nb>close</span><span class=p>(</span><span class=nx>done</span><span class=p>)</span>
    <span class=c1>//do other work
</span><span class=c1></span>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>3</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=34使用零通道><strong>34.使用“零”通道</strong></h2><p>级别：初学者</p><p>nil永远在通道块上发送和接收操作。这是一个有据可查的行为，但对于新的 Go 开发人员来说可能是一个惊喜。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;time&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>ch</span> <span class=kd>chan</span> <span class=kt>int</span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>idx</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
            <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=p>(</span><span class=nx>idx</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=mi>2</span>
        <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=c1>//get first result
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;result:&#34;</span><span class=p>,</span><span class=o>&lt;-</span><span class=nx>ch</span><span class=p>)</span>
    <span class=c1>//do other work
</span><span class=c1></span>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>如果您运行代码，您将看到如下运行时错误：fatal error: all goroutines are asleep - deadlock!</p><p>此行为可用作在语句中动态启用和禁用case块的一种方式。select</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>  
<span class=kn>import</span> <span class=s>&#34;time&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>inch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
    <span class=nx>outch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>

    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
        <span class=kd>var</span> <span class=nx>in</span> <span class=o>&lt;-</span> <span class=kd>chan</span> <span class=kt>int</span> <span class=p>=</span> <span class=nx>inch</span>
        <span class=kd>var</span> <span class=nx>out</span> <span class=kd>chan</span> <span class=o>&lt;-</span> <span class=kt>int</span>
        <span class=kd>var</span> <span class=nx>val</span> <span class=kt>int</span>
        <span class=k>for</span> <span class=p>{</span>
            <span class=k>select</span> <span class=p>{</span>
            <span class=k>case</span> <span class=nx>out</span> <span class=o>&lt;-</span> <span class=nx>val</span><span class=p>:</span>
                <span class=nx>out</span> <span class=p>=</span> <span class=kc>nil</span>
                <span class=nx>in</span> <span class=p>=</span> <span class=nx>inch</span>
            <span class=k>case</span> <span class=nx>val</span> <span class=p>=</span> <span class=o>&lt;-</span> <span class=nx>in</span><span class=p>:</span>
                <span class=nx>out</span> <span class=p>=</span> <span class=nx>outch</span>
                <span class=nx>in</span> <span class=p>=</span> <span class=kc>nil</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}()</span>

    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
        <span class=k>for</span> <span class=nx>r</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>outch</span> <span class=p>{</span>
            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;result:&#34;</span><span class=p>,</span><span class=nx>r</span><span class=p>)</span>
        <span class=p>}</span>
    <span class=p>}()</span>

    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
    <span class=nx>inch</span> <span class=o>&lt;-</span> <span class=mi>1</span>
    <span class=nx>inch</span> <span class=o>&lt;-</span> <span class=mi>2</span>
    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>3</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=35带有值接收器的方法不能更改原始值><strong>35.带有值接收器的方法不能更改原始值</strong></h2><p>级别：初学者</p><p>方法接收器就像常规函数参数。如果它被声明为一个值，那么您的函数/方法将获得您的接收器参数的副本。这意味着对接收器进行更改不会影响原始值，除非您的接收器是映射或切片变量，并且您正在更新集合中的项目或者您在接收器中更新的字段是指针。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>type</span> <span class=nx>data</span> <span class=kd>struct</span> <span class=p>{</span>  
    <span class=nx>num</span> <span class=kt>int</span>
    <span class=nx>key</span> <span class=o>*</span><span class=kt>string</span>
    <span class=nx>items</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>bool</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>data</span><span class=p>)</span> <span class=nf>pmethod</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>this</span><span class=p>.</span><span class=nx>num</span> <span class=p>=</span> <span class=mi>7</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=nx>data</span><span class=p>)</span> <span class=nf>vmethod</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>this</span><span class=p>.</span><span class=nx>num</span> <span class=p>=</span> <span class=mi>8</span>
    <span class=o>*</span><span class=nx>this</span><span class=p>.</span><span class=nx>key</span> <span class=p>=</span> <span class=s>&#34;v.key&#34;</span>
    <span class=nx>this</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=s>&#34;vmethod&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>key</span> <span class=o>:=</span> <span class=s>&#34;key.1&#34;</span>
    <span class=nx>d</span> <span class=o>:=</span> <span class=nx>data</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=o>&amp;</span><span class=nx>key</span><span class=p>,</span><span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>bool</span><span class=p>)}</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;num=%v key=%v items=%v\n&#34;</span><span class=p>,</span><span class=nx>d</span><span class=p>.</span><span class=nx>num</span><span class=p>,</span><span class=o>*</span><span class=nx>d</span><span class=p>.</span><span class=nx>key</span><span class=p>,</span><span class=nx>d</span><span class=p>.</span><span class=nx>items</span><span class=p>)</span>
    <span class=c1>//prints num=1 key=key.1 items=map[]
</span><span class=c1></span>
    <span class=nx>d</span><span class=p>.</span><span class=nf>pmethod</span><span class=p>()</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;num=%v key=%v items=%v\n&#34;</span><span class=p>,</span><span class=nx>d</span><span class=p>.</span><span class=nx>num</span><span class=p>,</span><span class=o>*</span><span class=nx>d</span><span class=p>.</span><span class=nx>key</span><span class=p>,</span><span class=nx>d</span><span class=p>.</span><span class=nx>items</span><span class=p>)</span> 
    <span class=c1>//prints num=7 key=key.1 items=map[]
</span><span class=c1></span>
    <span class=nx>d</span><span class=p>.</span><span class=nf>vmethod</span><span class=p>()</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;num=%v key=%v items=%v\n&#34;</span><span class=p>,</span><span class=nx>d</span><span class=p>.</span><span class=nx>num</span><span class=p>,</span><span class=o>*</span><span class=nx>d</span><span class=p>.</span><span class=nx>key</span><span class=p>,</span><span class=nx>d</span><span class=p>.</span><span class=nx>items</span><span class=p>)</span>
    <span class=c1>//prints num=7 key=v.key items=map[vmethod:true]
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=36关闭-http-响应正文><strong>36.关闭 HTTP 响应正文</strong></h2><p>等级：中级</p><p>当您使用标准 http 库发出请求时，您会得到一个 http 响应变量。如果您不阅读响应正文，您仍然需要关闭它。请注意，您也必须为空响应执行此操作。这很容易忘记，尤其是对于新的 Go 开发人员。</p><p>一些新的 Go 开发人员确实尝试关闭响应体，但他们做错了地方。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;net/http&#34;</span>
    <span class=s>&#34;io/ioutil&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>resp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=s>&#34;https://api.ipify.org?format=json&#34;</span><span class=p>)</span>
    <span class=k>defer</span> <span class=nx>resp</span><span class=p>.</span><span class=nx>Body</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span><span class=c1>//not ok
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>

    <span class=nx>body</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>ioutil</span><span class=p>.</span><span class=nf>ReadAll</span><span class=p>(</span><span class=nx>resp</span><span class=p>.</span><span class=nx>Body</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>body</span><span class=p>))</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>此代码适用于成功的请求，但如果 http 请求失败，resp变量可能是nil，这将导致<em>运行时 panic</em>。</p><p>关闭响应正文的最常见原因是defer在 http 响应错误检查之后使用调用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;net/http&#34;</span>
    <span class=s>&#34;io/ioutil&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>resp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=s>&#34;https://api.ipify.org?format=json&#34;</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>

    <span class=k>defer</span> <span class=nx>resp</span><span class=p>.</span><span class=nx>Body</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span><span class=c1>//ok, most of the time :-)
</span><span class=c1></span>    <span class=nx>body</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>ioutil</span><span class=p>.</span><span class=nf>ReadAll</span><span class=p>(</span><span class=nx>resp</span><span class=p>.</span><span class=nx>Body</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>body</span><span class=p>))</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>大多数情况下，当您的 http 请求失败时，resp变量将为nil， err为non-nill. 但是，当您遇到重定向失败时，两个变量都将是non-nil. 这意味着您仍然可能会出现泄漏。</p><p>non-nil您可以通过在 http 响应错误处理块中添加关闭响应主体的调用来修复此泄漏。另一种选择是使用一次defer调用来关闭所有失败和成功请求的响应主体。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;net/http&#34;</span>
    <span class=s>&#34;io/ioutil&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>resp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=s>&#34;https://api.ipify.org?format=json&#34;</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>resp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>defer</span> <span class=nx>resp</span><span class=p>.</span><span class=nx>Body</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>

    <span class=nx>body</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>ioutil</span><span class=p>.</span><span class=nf>ReadAll</span><span class=p>(</span><span class=nx>resp</span><span class=p>.</span><span class=nx>Body</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>body</span><span class=p>))</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>原始 resp.Body.Close() 实现中，还读取并丢弃剩余的响应正文数据。这确保了如果启用了 keepalive http 连接行为，则可以将 http 连接重新用于另一个请求。最新的 http 客户端行为不同。现在，您有责任读取并丢弃剩余的响应数据。如果你不这样做，http 连接可能会被关闭而不是被重用。</p><p>如果重用 http 连接对您的应用程序很重要，您可能需要在响应处理逻辑的末尾添加类似这样的内容：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>io</span><span class=p>.</span><span class=nf>Copy</span><span class=p>(</span><span class=nx>ioutil</span><span class=p>.</span><span class=nx>Discard</span><span class=p>,</span> <span class=nx>resp</span><span class=p>.</span><span class=nx>Body</span><span class=p>)</span>  
</code></pre></td></tr></table></div></div><p>如果您不立即阅读整个响应正文，则有必要这样做，如果您使用如下代码处理 json API 响应，则可能会发生这种情况：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>json.NewDecoder(resp.Body).Decode(&amp;data)  
</code></pre></td></tr></table></div></div><h2 id=37关闭-http-连接><strong>37.关闭 HTTP 连接</strong></h2><p>等级：中级</p><p>一些 HTTP 服务器保持网络连接打开一段时间（基于 HTTP 1.1 规范和服务器“保持活动”配置）。默认情况下，标准 http 库仅在目标 HTTP 服务器请求时才会关闭网络连接。这意味着您的应用程序可能会在某些情况下用完套接字/文件描述符。</p><p>您可以通过将Close请求变量中的字段设置为 来要求 http 库在请求完成后关闭连接true。</p><p>另一种选择是添加Connection请求标头并将其设置为close. 目标 HTTP 服务器也应该使用Connection: close标头响应。当 http 库看到这个响应头时，它也会关闭连接。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;net/http&#34;</span>
    <span class=s>&#34;io/ioutil&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>req</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>NewRequest</span><span class=p>(</span><span class=s>&#34;GET&#34;</span><span class=p>,</span><span class=s>&#34;http://golang.org&#34;</span><span class=p>,</span><span class=kc>nil</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>

    <span class=nx>req</span><span class=p>.</span><span class=nx>Close</span> <span class=p>=</span> <span class=kc>true</span>
    <span class=c1>//or do this:
</span><span class=c1></span>    <span class=c1>//req.Header.Add(&#34;Connection&#34;, &#34;close&#34;)
</span><span class=c1></span>
    <span class=nx>resp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nx>DefaultClient</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=nx>req</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>resp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>defer</span> <span class=nx>resp</span><span class=p>.</span><span class=nx>Body</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>

    <span class=nx>body</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>ioutil</span><span class=p>.</span><span class=nf>ReadAll</span><span class=p>(</span><span class=nx>resp</span><span class=p>.</span><span class=nx>Body</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>body</span><span class=p>)))</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>您还可以全局禁用 http 连接重用。您需要为其创建自定义 http 传输配置。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;net/http&#34;</span>
    <span class=s>&#34;io/ioutil&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>tr</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>http</span><span class=p>.</span><span class=nx>Transport</span><span class=p>{</span><span class=nx>DisableKeepAlives</span><span class=p>:</span> <span class=kc>true</span><span class=p>}</span>
    <span class=nx>client</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>http</span><span class=p>.</span><span class=nx>Client</span><span class=p>{</span><span class=nx>Transport</span><span class=p>:</span> <span class=nx>tr</span><span class=p>}</span>

    <span class=nx>resp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=s>&#34;http://golang.org&#34;</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>resp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>defer</span> <span class=nx>resp</span><span class=p>.</span><span class=nx>Body</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>resp</span><span class=p>.</span><span class=nx>StatusCode</span><span class=p>)</span>

    <span class=nx>body</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>ioutil</span><span class=p>.</span><span class=nf>ReadAll</span><span class=p>(</span><span class=nx>resp</span><span class=p>.</span><span class=nx>Body</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>body</span><span class=p>)))</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>如果您向同一个 HTTP 服务器发送大量请求，则可以保持网络连接打开。但是，如果您的应用程序在短时间内向许多不同的 HTTP 服务器发送一个或两个请求，最好在您的应用程序收到响应后立即关闭网络连接。增加打开文件的限制也可能是个好主意。但是，正确的解决方案取决于您的应用程序。</p><h2 id=38json-编码器添加换行符><strong>38.JSON 编码器添加换行符</strong></h2><p>等级：中级</p><p>当您发现测试失败是因为您没有获得预期值时，您正在为 JSON 编码函数编写测试。发生了什么？如果您使用的是 JSON 编码器对象，那么您将在编码的 JSON 对象的末尾获得一个额外的换行符。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>
  <span class=s>&#34;fmt&#34;</span>
  <span class=s>&#34;encoding/json&#34;</span>
  <span class=s>&#34;bytes&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=nx>data</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=s>&#34;key&#34;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>
  
  <span class=kd>var</span> <span class=nx>b</span> <span class=nx>bytes</span><span class=p>.</span><span class=nx>Buffer</span>
  <span class=nx>json</span><span class=p>.</span><span class=nf>NewEncoder</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>b</span><span class=p>).</span><span class=nf>Encode</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span>

  <span class=nx>raw</span><span class=p>,</span><span class=nx>_</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Marshal</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span>
  
  <span class=k>if</span> <span class=nx>b</span><span class=p>.</span><span class=nf>String</span><span class=p>()</span> <span class=o>==</span> <span class=nb>string</span><span class=p>(</span><span class=nx>raw</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;same encoded data&#34;</span><span class=p>)</span>
  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;&#39;%s&#39; != &#39;%s&#39;\n&#34;</span><span class=p>,</span><span class=nx>raw</span><span class=p>,</span><span class=nx>b</span><span class=p>.</span><span class=nf>String</span><span class=p>())</span>
    <span class=c1>//prints:
</span><span class=c1></span>    <span class=c1>//&#39;{&#34;key&#34;:1}&#39; != &#39;{&#34;key&#34;:1}\n&#39;
</span><span class=c1></span>  <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>JSON Encoder 对象专为流式传输而设计。使用 JSON 进行流式传输通常意味着以换行符分隔的 JSON 对象，这就是 Encode 方法添加换行符的原因。这是记录在案的行为，但通常被忽视或遗忘。</p><h2 id=39json-包转义键和字符串值中的特殊-html-字符><strong>39.JSON 包转义键和字符串值中的特殊 HTML 字符</strong></h2><p>等级：中级</p><p>这是一个记录在案的行为，但您必须仔细阅读所有 JSON 包文档才能了解它。SetEscapeHTML方法描述讨论了 and、小于和大于字符的默认编码行为。</p><p>出于多种原因，这是 Go 团队的一个非常不幸的设计决定。首先，您不能为json.Marshal调用禁用此行为。其次，这是一个实施得很糟糕的安全功能，因为它假定进行 HTML 编码足以防止所有 Web 应用程序中的 XSS 漏洞。有很多不同的上下文可以使用数据，每个上下文都需要自己的编码方法。最后，它很糟糕，因为它假定 JSON 的主要用例是网页，默认情况下会破坏配置库和 REST/HTTP API。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>
  <span class=s>&#34;fmt&#34;</span>
  <span class=s>&#34;encoding/json&#34;</span>
  <span class=s>&#34;bytes&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=nx>data</span> <span class=o>:=</span> <span class=s>&#34;x &lt; y&#34;</span>
  
  <span class=nx>raw</span><span class=p>,</span><span class=nx>_</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Marshal</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span>
  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>raw</span><span class=p>))</span>
  <span class=c1>//prints: &#34;x \u003c y&#34; &lt;- probably not what you expected
</span><span class=c1></span>  
  <span class=kd>var</span> <span class=nx>b1</span> <span class=nx>bytes</span><span class=p>.</span><span class=nx>Buffer</span>
  <span class=nx>json</span><span class=p>.</span><span class=nf>NewEncoder</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>b1</span><span class=p>).</span><span class=nf>Encode</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span>
  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>b1</span><span class=p>.</span><span class=nf>String</span><span class=p>())</span>
  <span class=c1>//prints: &#34;x \u003c y&#34; &lt;- probably not what you expected
</span><span class=c1></span>  
  <span class=kd>var</span> <span class=nx>b2</span> <span class=nx>bytes</span><span class=p>.</span><span class=nx>Buffer</span>
  <span class=nx>enc</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>NewEncoder</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>b2</span><span class=p>)</span>
  <span class=nx>enc</span><span class=p>.</span><span class=nf>SetEscapeHTML</span><span class=p>(</span><span class=kc>false</span><span class=p>)</span>
  <span class=nx>enc</span><span class=p>.</span><span class=nf>Encode</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span>
  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>b2</span><span class=p>.</span><span class=nf>String</span><span class=p>())</span>
  <span class=c1>//prints: &#34;x &lt; y&#34; &lt;- looks better
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>给 Go 团队的建议……让它成为一个选择加入。</p><h2 id=40将-json-数字解组为接口值><strong>40.将 JSON 数字解组为接口值</strong></h2><p>等级：中级</p><p>默认情况下，float64当您将 JSON 数据解码/解组到接口中时，Go 将 JSON 中的数值视为数字。这意味着以下代码将因 panic 而失败：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
  <span class=s>&#34;encoding/json&#34;</span>
  <span class=s>&#34;fmt&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
  <span class=kd>var</span> <span class=nx>data</span> <span class=p>=</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=s>`{&#34;status&#34;: 200}`</span><span class=p>)</span>

  <span class=kd>var</span> <span class=nx>result</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>interface</span><span class=p>{}</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>data</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>result</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
    <span class=k>return</span>
  <span class=p>}</span>

  <span class=kd>var</span> <span class=nx>status</span> <span class=p>=</span> <span class=nx>result</span><span class=p>[</span><span class=s>&#34;status&#34;</span><span class=p>].(</span><span class=kt>int</span><span class=p>)</span> <span class=c1>//error
</span><span class=c1></span>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;status value:&#34;</span><span class=p>,</span><span class=nx>status</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>运行时panic：</p><blockquote><p>panic: interface conversion: interface is float64, not int</p></blockquote><p>如果您尝试解码的 JSON 值是一个整数，那么您有多个选项。</p><p>选项一：按原样使用浮点值:-)</p><p>选项二：将浮点值转换为您需要的整数类型。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
  <span class=s>&#34;encoding/json&#34;</span>
  <span class=s>&#34;fmt&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
  <span class=kd>var</span> <span class=nx>data</span> <span class=p>=</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=s>`{&#34;status&#34;: 200}`</span><span class=p>)</span>

  <span class=kd>var</span> <span class=nx>result</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>interface</span><span class=p>{}</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>data</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>result</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
    <span class=k>return</span>
  <span class=p>}</span>

  <span class=kd>var</span> <span class=nx>status</span> <span class=p>=</span> <span class=nb>uint64</span><span class=p>(</span><span class=nx>result</span><span class=p>[</span><span class=s>&#34;status&#34;</span><span class=p>].(</span><span class=kt>float64</span><span class=p>))</span> <span class=c1>//ok
</span><span class=c1></span>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;status value:&#34;</span><span class=p>,</span><span class=nx>status</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>选项三：使用一种类型来解组 JSON，并告诉它使用接口类型Decoder来表示 JSON 数字。Number</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
  <span class=s>&#34;encoding/json&#34;</span>
  <span class=s>&#34;bytes&#34;</span>
  <span class=s>&#34;fmt&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
  <span class=kd>var</span> <span class=nx>data</span> <span class=p>=</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=s>`{&#34;status&#34;: 200}`</span><span class=p>)</span>

  <span class=kd>var</span> <span class=nx>result</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>interface</span><span class=p>{}</span>
  <span class=kd>var</span> <span class=nx>decoder</span> <span class=p>=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>NewDecoder</span><span class=p>(</span><span class=nx>bytes</span><span class=p>.</span><span class=nf>NewReader</span><span class=p>(</span><span class=nx>data</span><span class=p>))</span>
  <span class=nx>decoder</span><span class=p>.</span><span class=nf>UseNumber</span><span class=p>()</span>

  <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>decoder</span><span class=p>.</span><span class=nf>Decode</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>result</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
    <span class=k>return</span>
  <span class=p>}</span>

  <span class=kd>var</span> <span class=nx>status</span><span class=p>,</span><span class=nx>_</span> <span class=p>=</span> <span class=nx>result</span><span class=p>[</span><span class=s>&#34;status&#34;</span><span class=p>].(</span><span class=nx>json</span><span class=p>.</span><span class=nx>Number</span><span class=p>).</span><span class=nf>Int64</span><span class=p>()</span> <span class=c1>//ok
</span><span class=c1></span>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;status value:&#34;</span><span class=p>,</span><span class=nx>status</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>您可以使用Number值的字符串表示形式将其解组为不同的数字类型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
  <span class=s>&#34;encoding/json&#34;</span>
  <span class=s>&#34;bytes&#34;</span>
  <span class=s>&#34;fmt&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
  <span class=kd>var</span> <span class=nx>data</span> <span class=p>=</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=s>`{&#34;status&#34;: 200}`</span><span class=p>)</span>

  <span class=kd>var</span> <span class=nx>result</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>interface</span><span class=p>{}</span>
  <span class=kd>var</span> <span class=nx>decoder</span> <span class=p>=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>NewDecoder</span><span class=p>(</span><span class=nx>bytes</span><span class=p>.</span><span class=nf>NewReader</span><span class=p>(</span><span class=nx>data</span><span class=p>))</span>
  <span class=nx>decoder</span><span class=p>.</span><span class=nf>UseNumber</span><span class=p>()</span>

  <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>decoder</span><span class=p>.</span><span class=nf>Decode</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>result</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
    <span class=k>return</span>
  <span class=p>}</span>

  <span class=kd>var</span> <span class=nx>status</span> <span class=kt>uint64</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>result</span><span class=p>[</span><span class=s>&#34;status&#34;</span><span class=p>].(</span><span class=nx>json</span><span class=p>.</span><span class=nx>Number</span><span class=p>).</span><span class=nf>String</span><span class=p>()),</span> <span class=o>&amp;</span><span class=nx>status</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
    <span class=k>return</span>
  <span class=p>}</span>

  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;status value:&#34;</span><span class=p>,</span><span class=nx>status</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>选项四：使用struct将您的数值映射到您需要的数值类型的类型。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
  <span class=s>&#34;encoding/json&#34;</span>
  <span class=s>&#34;bytes&#34;</span>
  <span class=s>&#34;fmt&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
  <span class=kd>var</span> <span class=nx>data</span> <span class=p>=</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=s>`{&#34;status&#34;: 200}`</span><span class=p>)</span>

  <span class=kd>var</span> <span class=nx>result</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>Status</span> <span class=kt>uint64</span> <span class=s>`json:&#34;status&#34;`</span>
  <span class=p>}</span>

  <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>NewDecoder</span><span class=p>(</span><span class=nx>bytes</span><span class=p>.</span><span class=nf>NewReader</span><span class=p>(</span><span class=nx>data</span><span class=p>)).</span><span class=nf>Decode</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>result</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
    <span class=k>return</span>
  <span class=p>}</span>

  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;result =&gt; %+v&#34;</span><span class=p>,</span><span class=nx>result</span><span class=p>)</span>
  <span class=c1>//prints: result =&gt; {Status:200}
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>选项五：如果您需要延迟值解码，请使用struct将您的数值映射到类型的 a。json.RawMessage</p><p>如果您必须在字段类型或结构可能发生变化的情况下执行条件 JSON 字段解码，则此选项很有用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
  <span class=s>&#34;encoding/json&#34;</span>
  <span class=s>&#34;bytes&#34;</span>
  <span class=s>&#34;fmt&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
  <span class=nx>records</span> <span class=o>:=</span> <span class=p>[][]</span><span class=kt>byte</span><span class=p>{</span>
    <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=s>`{&#34;status&#34;: 200, &#34;tag&#34;:&#34;one&#34;}`</span><span class=p>),</span>
    <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=s>`{&#34;status&#34;:&#34;ok&#34;, &#34;tag&#34;:&#34;two&#34;}`</span><span class=p>),</span>
  <span class=p>}</span>

  <span class=k>for</span> <span class=nx>idx</span><span class=p>,</span> <span class=nx>record</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>records</span> <span class=p>{</span>
    <span class=kd>var</span> <span class=nx>result</span> <span class=kd>struct</span> <span class=p>{</span>
      <span class=nx>StatusCode</span> <span class=kt>uint64</span>
      <span class=nx>StatusName</span> <span class=kt>string</span>
      <span class=nx>Status</span> <span class=nx>json</span><span class=p>.</span><span class=nx>RawMessage</span> <span class=s>`json:&#34;status&#34;`</span>
      <span class=nx>Tag</span> <span class=kt>string</span>             <span class=s>`json:&#34;tag&#34;`</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>NewDecoder</span><span class=p>(</span><span class=nx>bytes</span><span class=p>.</span><span class=nf>NewReader</span><span class=p>(</span><span class=nx>record</span><span class=p>)).</span><span class=nf>Decode</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>result</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
      <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
      <span class=k>return</span>
    <span class=p>}</span>

    <span class=kd>var</span> <span class=nx>sstatus</span> <span class=kt>string</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>result</span><span class=p>.</span><span class=nx>Status</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>sstatus</span><span class=p>);</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
      <span class=nx>result</span><span class=p>.</span><span class=nx>StatusName</span> <span class=p>=</span> <span class=nx>sstatus</span>
    <span class=p>}</span>

    <span class=kd>var</span> <span class=nx>nstatus</span> <span class=kt>uint64</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>result</span><span class=p>.</span><span class=nx>Status</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>nstatus</span><span class=p>);</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
      <span class=nx>result</span><span class=p>.</span><span class=nx>StatusCode</span> <span class=p>=</span> <span class=nx>nstatus</span>
    <span class=p>}</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;[%v] result =&gt; %+v\n&#34;</span><span class=p>,</span><span class=nx>idx</span><span class=p>,</span><span class=nx>result</span><span class=p>)</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=41十六进制或其他非-utf8-转义序列无法使用-json-字符串值><strong>41.十六进制或其他非 UTF8 转义序列无法使用 JSON 字符串值</strong></h2><p>等级：中级</p><p>Go 期望字符串值是 <em>UTF8 编码</em>的。这意味着您的 JSON 字符串中不能有任意十六进制转义的二进制数据（并且您还必须转义反斜杠字符）。这确实是 Go 继承的 JSON 陷阱，但它在 Go 应用程序中经常发生，因此无论如何都要提及它。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>
  <span class=s>&#34;fmt&#34;</span>
  <span class=s>&#34;encoding/json&#34;</span>
<span class=p>)</span>

<span class=kd>type</span> <span class=nx>config</span> <span class=kd>struct</span> <span class=p>{</span>
  <span class=nx>Data</span> <span class=kt>string</span> <span class=s>`json:&#34;data&#34;`</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=nx>raw</span> <span class=o>:=</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=s>`{&#34;data&#34;:&#34;\xc2&#34;}`</span><span class=p>)</span>
  <span class=kd>var</span> <span class=nx>decoded</span> <span class=nx>config</span>

  <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>raw</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>decoded</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
    <span class=c1>//prints: invalid character &#39;x&#39; in string escape code
</span><span class=c1></span>    <span class=p>}</span>
  
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>如果 Go 看到一个十六进制转义序列，Unmarshal/Decode 调用将失败。如果您确实需要在字符串中使用反斜杠，请确保使用另一个反斜杠对其进行转义。如果您想使用十六进制编码的二进制数据，您可以转义反斜杠，然后使用 JSON 字符串中的解码数据进行自己的十六进制转义。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>
  <span class=s>&#34;fmt&#34;</span>
  <span class=s>&#34;encoding/json&#34;</span>
<span class=p>)</span>

<span class=kd>type</span> <span class=nx>config</span> <span class=kd>struct</span> <span class=p>{</span>
  <span class=nx>Data</span> <span class=kt>string</span> <span class=s>`json:&#34;data&#34;`</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=nx>raw</span> <span class=o>:=</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=s>`{&#34;data&#34;:&#34;\\xc2&#34;}`</span><span class=p>)</span>
  
  <span class=kd>var</span> <span class=nx>decoded</span> <span class=nx>config</span>
  
  <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>raw</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>decoded</span><span class=p>)</span>
  
  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%#v&#34;</span><span class=p>,</span><span class=nx>decoded</span><span class=p>)</span> <span class=c1>//prints: main.config{Data:&#34;\\xc2&#34;}
</span><span class=c1></span>  <span class=c1>//todo: do your own hex escape decoding for decoded.Data  
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>另一种选择是在 JSON 对象中使用字节数组/切片数据类型，但二进制数据必须采用 base64 编码。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>
  <span class=s>&#34;fmt&#34;</span>
  <span class=s>&#34;encoding/json&#34;</span>
<span class=p>)</span>

<span class=kd>type</span> <span class=nx>config</span> <span class=kd>struct</span> <span class=p>{</span>
  <span class=nx>Data</span> <span class=p>[]</span><span class=kt>byte</span> <span class=s>`json:&#34;data&#34;`</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=nx>raw</span> <span class=o>:=</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=s>`{&#34;data&#34;:&#34;wg==&#34;}`</span><span class=p>)</span>
  <span class=kd>var</span> <span class=nx>decoded</span> <span class=nx>config</span>
  
  <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>raw</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>decoded</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
          <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
      <span class=p>}</span>
  
  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%#v&#34;</span><span class=p>,</span><span class=nx>decoded</span><span class=p>)</span> <span class=c1>//prints: main.config{Data:[]uint8{0xc2}}
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>其他需要注意的是 Unicode 替换字符 (U+FFFD)。Go 将使用替换字符而不是无效的 UTF8，因此 Unmarshal/Decode 调用不会失败，但你得到的字符串值可能不是你所期望的。</p><h2 id=42比较结构数组切片和映射><strong>42.比较结构、数组、切片和映射</strong></h2><p>等级：中级</p><p>==如果每个结构字段都可以与相等运算符进行比较，则可以使用相等运算符 ,来比较结构变量。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>type</span> <span class=nx>data</span> <span class=kd>struct</span> <span class=p>{</span>  
    <span class=nx>num</span> <span class=kt>int</span>
    <span class=nx>fp</span> <span class=kt>float32</span>
    <span class=nx>complex</span> <span class=kt>complex64</span>
    <span class=nx>str</span> <span class=kt>string</span>
    <span class=nx>char</span> <span class=kt>rune</span>
    <span class=nx>yes</span> <span class=kt>bool</span>
    <span class=nx>events</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>string</span>
    <span class=nx>handler</span> <span class=kd>interface</span><span class=p>{}</span>
    <span class=nx>ref</span> <span class=o>*</span><span class=kt>byte</span>
    <span class=nx>raw</span> <span class=p>[</span><span class=mi>10</span><span class=p>]</span><span class=kt>byte</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>v1</span> <span class=o>:=</span> <span class=nx>data</span><span class=p>{}</span>
    <span class=nx>v2</span> <span class=o>:=</span> <span class=nx>data</span><span class=p>{}</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;v1 == v2:&#34;</span><span class=p>,</span><span class=nx>v1</span> <span class=o>==</span> <span class=nx>v2</span><span class=p>)</span> <span class=c1>//prints: v1 == v2: true
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>如果任何结构字段不可比较，则使用相等运算符将导致编译时错误。请注意，只有当它们的数据项具有可比性时，数组才具有可比性。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>type</span> <span class=nx>data</span> <span class=kd>struct</span> <span class=p>{</span>  
    <span class=nx>num</span> <span class=kt>int</span>                <span class=c1>//ok
</span><span class=c1></span>    <span class=nx>checks</span> <span class=p>[</span><span class=mi>10</span><span class=p>]</span><span class=kd>func</span><span class=p>()</span> <span class=kt>bool</span> <span class=c1>//not comparable
</span><span class=c1></span>    <span class=nx>doit</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>bool</span>       <span class=c1>//not comparable
</span><span class=c1></span>    <span class=nx>m</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span> <span class=kt>string</span>   <span class=c1>//not comparable
</span><span class=c1></span>    <span class=nx>bytes</span> <span class=p>[]</span><span class=kt>byte</span>           <span class=c1>//not comparable
</span><span class=c1></span><span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>v1</span> <span class=o>:=</span> <span class=nx>data</span><span class=p>{}</span>
    <span class=nx>v2</span> <span class=o>:=</span> <span class=nx>data</span><span class=p>{}</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;v1 == v2:&#34;</span><span class=p>,</span><span class=nx>v1</span> <span class=o>==</span> <span class=nx>v2</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Go 确实提供了许多辅助函数来比较无法使用比较运算符进行比较的变量。</p><p>最通用的解决方案是使用DeepEqual()反射包中的函数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;reflect&#34;</span>
<span class=p>)</span>

<span class=kd>type</span> <span class=nx>data</span> <span class=kd>struct</span> <span class=p>{</span>  
    <span class=nx>num</span> <span class=kt>int</span>                <span class=c1>//ok
</span><span class=c1></span>    <span class=nx>checks</span> <span class=p>[</span><span class=mi>10</span><span class=p>]</span><span class=kd>func</span><span class=p>()</span> <span class=kt>bool</span> <span class=c1>//not comparable
</span><span class=c1></span>    <span class=nx>doit</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>bool</span>       <span class=c1>//not comparable
</span><span class=c1></span>    <span class=nx>m</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span> <span class=kt>string</span>   <span class=c1>//not comparable
</span><span class=c1></span>    <span class=nx>bytes</span> <span class=p>[]</span><span class=kt>byte</span>           <span class=c1>//not comparable
</span><span class=c1></span><span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>v1</span> <span class=o>:=</span> <span class=nx>data</span><span class=p>{}</span>
    <span class=nx>v2</span> <span class=o>:=</span> <span class=nx>data</span><span class=p>{}</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;v1 == v2:&#34;</span><span class=p>,</span><span class=nx>reflect</span><span class=p>.</span><span class=nf>DeepEqual</span><span class=p>(</span><span class=nx>v1</span><span class=p>,</span><span class=nx>v2</span><span class=p>))</span> <span class=c1>//prints: v1 == v2: true
</span><span class=c1></span>
    <span class=nx>m1</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;one&#34;</span><span class=p>:</span> <span class=s>&#34;a&#34;</span><span class=p>,</span><span class=s>&#34;two&#34;</span><span class=p>:</span> <span class=s>&#34;b&#34;</span><span class=p>}</span>
    <span class=nx>m2</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;two&#34;</span><span class=p>:</span> <span class=s>&#34;b&#34;</span><span class=p>,</span> <span class=s>&#34;one&#34;</span><span class=p>:</span> <span class=s>&#34;a&#34;</span><span class=p>}</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;m1 == m2:&#34;</span><span class=p>,</span><span class=nx>reflect</span><span class=p>.</span><span class=nf>DeepEqual</span><span class=p>(</span><span class=nx>m1</span><span class=p>,</span> <span class=nx>m2</span><span class=p>))</span> <span class=c1>//prints: m1 == m2: true
</span><span class=c1></span>
    <span class=nx>s1</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
    <span class=nx>s2</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;s1 == s2:&#34;</span><span class=p>,</span><span class=nx>reflect</span><span class=p>.</span><span class=nf>DeepEqual</span><span class=p>(</span><span class=nx>s1</span><span class=p>,</span> <span class=nx>s2</span><span class=p>))</span> <span class=c1>//prints: s1 == s2: true
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>除了速度很慢（这可能会或可能不会对您的应用程序造成破坏）之外，DeepEqual()它也有自己的问题。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;reflect&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>b1</span> <span class=p>[]</span><span class=kt>byte</span> <span class=p>=</span> <span class=kc>nil</span>
    <span class=nx>b2</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{}</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;b1 == b2:&#34;</span><span class=p>,</span><span class=nx>reflect</span><span class=p>.</span><span class=nf>DeepEqual</span><span class=p>(</span><span class=nx>b1</span><span class=p>,</span> <span class=nx>b2</span><span class=p>))</span> <span class=c1>//prints: b1 == b2: false
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>DeepEqual()不认为空切片等于“nil”切片。此行为与您使用该bytes.Equal()函数获得的行为不同。bytes.Equal()认为“nil”和空切片是相等的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;bytes&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>b1</span> <span class=p>[]</span><span class=kt>byte</span> <span class=p>=</span> <span class=kc>nil</span>
    <span class=nx>b2</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{}</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;b1 == b2:&#34;</span><span class=p>,</span><span class=nx>bytes</span><span class=p>.</span><span class=nf>Equal</span><span class=p>(</span><span class=nx>b1</span><span class=p>,</span> <span class=nx>b2</span><span class=p>))</span> <span class=c1>//prints: b1 == b2: true
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>DeepEqual()比较切片并不总是完美的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;reflect&#34;</span>
    <span class=s>&#34;encoding/json&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>str</span> <span class=kt>string</span> <span class=p>=</span> <span class=s>&#34;one&#34;</span>
    <span class=kd>var</span> <span class=nx>in</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>=</span> <span class=s>&#34;one&#34;</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;str == in:&#34;</span><span class=p>,</span><span class=nx>str</span> <span class=o>==</span> <span class=nx>in</span><span class=p>,</span><span class=nx>reflect</span><span class=p>.</span><span class=nf>DeepEqual</span><span class=p>(</span><span class=nx>str</span><span class=p>,</span> <span class=nx>in</span><span class=p>))</span> 
    <span class=c1>//prints: str == in: true true
</span><span class=c1></span>
    <span class=nx>v1</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;one&#34;</span><span class=p>,</span><span class=s>&#34;two&#34;</span><span class=p>}</span>
    <span class=nx>v2</span> <span class=o>:=</span> <span class=p>[]</span><span class=kd>interface</span><span class=p>{}{</span><span class=s>&#34;one&#34;</span><span class=p>,</span><span class=s>&#34;two&#34;</span><span class=p>}</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;v1 == v2:&#34;</span><span class=p>,</span><span class=nx>reflect</span><span class=p>.</span><span class=nf>DeepEqual</span><span class=p>(</span><span class=nx>v1</span><span class=p>,</span> <span class=nx>v2</span><span class=p>))</span> 
    <span class=c1>//prints: v1 == v2: false (not ok)
</span><span class=c1></span>
    <span class=nx>data</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>interface</span><span class=p>{}{</span>
        <span class=s>&#34;code&#34;</span><span class=p>:</span> <span class=mi>200</span><span class=p>,</span>
        <span class=s>&#34;value&#34;</span><span class=p>:</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;one&#34;</span><span class=p>,</span><span class=s>&#34;two&#34;</span><span class=p>},</span>
    <span class=p>}</span>
    <span class=nx>encoded</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Marshal</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span>
    <span class=kd>var</span> <span class=nx>decoded</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>interface</span><span class=p>{}</span>
    <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>encoded</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>decoded</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;data == decoded:&#34;</span><span class=p>,</span><span class=nx>reflect</span><span class=p>.</span><span class=nf>DeepEqual</span><span class=p>(</span><span class=nx>data</span><span class=p>,</span> <span class=nx>decoded</span><span class=p>))</span> 
    <span class=c1>//prints: data == decoded: false (not ok)
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>如果您的字节切片（或字符串）包含文本数据，当您需要以不区分大小写的方式（在使用 、 或 之前）比较值时，您可能想使用或来自“字节”和“字符串”ToUpper()包。它适用于英文文本，但不适用于许多其他语言的文本。并且应该被使用。ToLower()==bytes.Equal()bytes.Compare()strings.EqualFold()bytes.EqualFold()</p><p>如果您的字节切片包含需要针对用户提供的数据进行验证的机密（例如，加密哈希、令牌等），请不要使用reflect.DeepEqual(), bytes.Equal()，或者bytes.Compare()因为这些函数会使您的应用程序容易受到计时攻击。为避免泄漏计时信息，请使用“crypto/subtle”包中的函数（例如，subtle.ConstantTimeCompare()）。</p><h2 id=43从-panic-中恢复-recover-><strong>43.从 panic 中恢复（ recover ）</strong></h2><p>等级：中级</p><p>该recover()函数可用于捕获/拦截panic。调用 recover()只有在 defer 延迟函数中完成时才会起作用。</p><p>Incorrect:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nb>recover</span><span class=p>()</span> <span class=c1>//doesn&#39;t do anything
</span><span class=c1></span>    <span class=nb>panic</span><span class=p>(</span><span class=s>&#34;not good&#34;</span><span class=p>)</span>
    <span class=nb>recover</span><span class=p>()</span> <span class=c1>//won&#39;t be executed :)
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;ok&#34;</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Works:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;recovered:&#34;</span><span class=p>,</span><span class=nb>recover</span><span class=p>())</span>
    <span class=p>}()</span>

    <span class=nb>panic</span><span class=p>(</span><span class=s>&#34;not good&#34;</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>调用recover()仅在您的延迟函数中直接调用时才有效。</p><p>Fails:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>doRecover</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;recovered =&gt;&#34;</span><span class=p>,</span><span class=nb>recover</span><span class=p>())</span> <span class=c1>//prints: recovered =&gt; &lt;nil&gt;
</span><span class=c1></span><span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
        <span class=nf>doRecover</span><span class=p>()</span> <span class=c1>//panic is not recovered
</span><span class=c1></span>    <span class=p>}()</span>

    <span class=nb>panic</span><span class=p>(</span><span class=s>&#34;not good&#34;</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=44在切片数组和映射range子句中更新和引用item值><strong>44.在切片、数组和映射“range”子句中更新和引用item值</strong></h2><p>等级：中级</p><p>“range”子句中生成的数据值是实际集合元素的副本。它们不是对原始item的引用。这意味着更新值不会更改原始数据。这也意味着获取值的地址不会为您提供指向原始数据的指针。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>data</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>}</span>
    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span><span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>data</span> <span class=p>{</span>
        <span class=nx>v</span> <span class=o>*=</span> <span class=mi>10</span> <span class=c1>//original item is not changed
</span><span class=c1></span>    <span class=p>}</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;data:&#34;</span><span class=p>,</span><span class=nx>data</span><span class=p>)</span> <span class=c1>//prints data: [1 2 3]
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>如果您需要更新原始集合记录值，请使用索引运算符来访问数据。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>data</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>}</span>
    <span class=k>for</span> <span class=nx>i</span><span class=p>,</span><span class=nx>_</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>data</span> <span class=p>{</span>
        <span class=nx>data</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>*=</span> <span class=mi>10</span>
    <span class=p>}</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;data:&#34;</span><span class=p>,</span><span class=nx>data</span><span class=p>)</span> <span class=c1>//prints data: [10 20 30]
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>如果您的集合包含指针值，则规则略有不同。如果您希望原始记录指向另一个值，您仍然需要使用索引运算符，但您可以使用“for range”子句中的第二个值更新存储在目标位置的数据。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>data</span> <span class=o>:=</span> <span class=p>[]</span><span class=o>*</span><span class=kd>struct</span><span class=p>{</span><span class=nx>num</span> <span class=kt>int</span><span class=p>}</span> <span class=p>{{</span><span class=mi>1</span><span class=p>},{</span><span class=mi>2</span><span class=p>},{</span><span class=mi>3</span><span class=p>}}</span>

    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span><span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>data</span> <span class=p>{</span>
        <span class=nx>v</span><span class=p>.</span><span class=nx>num</span> <span class=o>*=</span> <span class=mi>10</span>
    <span class=p>}</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>data</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span><span class=nx>data</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span><span class=nx>data</span><span class=p>[</span><span class=mi>2</span><span class=p>])</span> <span class=c1>//prints &amp;{10} &amp;{20} &amp;{30}
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=45切片中的隐藏数据><strong>45.切片中的“隐藏”数据</strong></h2><p>等级：中级</p><p>重新切片切片时，新切片将<em>引用原始切片的数组</em>。如果您忘记了这种行为，如果您的应用程序分配大型临时切片从它们创建新切片以引用原始数据的小部分，则可能会导致意外的内存使用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>get</span><span class=p>()</span> <span class=p>[]</span><span class=kt>byte</span> <span class=p>{</span>  
    <span class=nx>raw</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span><span class=mi>10000</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>raw</span><span class=p>),</span><span class=nb>cap</span><span class=p>(</span><span class=nx>raw</span><span class=p>),</span><span class=o>&amp;</span><span class=nx>raw</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=c1>//prints: 10000 10000 &lt;byte_addr_x&gt;
</span><span class=c1></span>    <span class=k>return</span> <span class=nx>raw</span><span class=p>[:</span><span class=mi>3</span><span class=p>]</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>data</span> <span class=o>:=</span> <span class=nf>get</span><span class=p>()</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>data</span><span class=p>),</span><span class=nb>cap</span><span class=p>(</span><span class=nx>data</span><span class=p>),</span><span class=o>&amp;</span><span class=nx>data</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=c1>//prints: 3 10000 &lt;byte_addr_x&gt;
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>为避免此陷阱，请确保<em>从临时切片中复制所需的数据</em>（而不是重新切片）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>get</span><span class=p>()</span> <span class=p>[]</span><span class=kt>byte</span> <span class=p>{</span>  
    <span class=nx>raw</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span><span class=mi>10000</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>raw</span><span class=p>),</span><span class=nb>cap</span><span class=p>(</span><span class=nx>raw</span><span class=p>),</span><span class=o>&amp;</span><span class=nx>raw</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=c1>//prints: 10000 10000 &lt;byte_addr_x&gt;
</span><span class=c1></span>    <span class=nx>res</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span><span class=mi>3</span><span class=p>)</span>
    <span class=nb>copy</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span><span class=nx>raw</span><span class=p>[:</span><span class=mi>3</span><span class=p>])</span>
    <span class=k>return</span> <span class=nx>res</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>data</span> <span class=o>:=</span> <span class=nf>get</span><span class=p>()</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>data</span><span class=p>),</span><span class=nb>cap</span><span class=p>(</span><span class=nx>data</span><span class=p>),</span><span class=o>&amp;</span><span class=nx>data</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=c1>//prints: 3 3 &lt;byte_addr_y&gt;
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=46切片数据覆盖><strong>46.切片数据覆盖</strong></h2><p>等级：中级</p><p>假设您需要重写路径（存储在切片中）。您重新切片路径以引用修改第一个文件夹名称的每个目录，然后组合名称以创建新路径。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;bytes&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>path</span> <span class=o>:=</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=s>&#34;AAAA/BBBBBBBBB&#34;</span><span class=p>)</span>
    <span class=nx>sepIndex</span> <span class=o>:=</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>IndexByte</span><span class=p>(</span><span class=nx>path</span><span class=p>,</span><span class=sc>&#39;/&#39;</span><span class=p>)</span>
    <span class=nx>dir1</span> <span class=o>:=</span> <span class=nx>path</span><span class=p>[:</span><span class=nx>sepIndex</span><span class=p>]</span>
    <span class=nx>dir2</span> <span class=o>:=</span> <span class=nx>path</span><span class=p>[</span><span class=nx>sepIndex</span><span class=o>+</span><span class=mi>1</span><span class=p>:]</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;dir1 =&gt;&#34;</span><span class=p>,</span><span class=nb>string</span><span class=p>(</span><span class=nx>dir1</span><span class=p>))</span> <span class=c1>//prints: dir1 =&gt; AAAA
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;dir2 =&gt;&#34;</span><span class=p>,</span><span class=nb>string</span><span class=p>(</span><span class=nx>dir2</span><span class=p>))</span> <span class=c1>//prints: dir2 =&gt; BBBBBBBBB
</span><span class=c1></span>
    <span class=nx>dir1</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>dir1</span><span class=p>,</span><span class=s>&#34;suffix&#34;</span><span class=o>...</span><span class=p>)</span>
    <span class=nx>path</span> <span class=p>=</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>Join</span><span class=p>([][]</span><span class=kt>byte</span><span class=p>{</span><span class=nx>dir1</span><span class=p>,</span><span class=nx>dir2</span><span class=p>},[]</span><span class=kt>byte</span><span class=p>{</span><span class=sc>&#39;/&#39;</span><span class=p>})</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;dir1 =&gt;&#34;</span><span class=p>,</span><span class=nb>string</span><span class=p>(</span><span class=nx>dir1</span><span class=p>))</span> <span class=c1>//prints: dir1 =&gt; AAAAsuffix
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;dir2 =&gt;&#34;</span><span class=p>,</span><span class=nb>string</span><span class=p>(</span><span class=nx>dir2</span><span class=p>))</span> <span class=c1>//prints: dir2 =&gt; uffixBBBB (not ok)
</span><span class=c1></span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;new path =&gt;&#34;</span><span class=p>,</span><span class=nb>string</span><span class=p>(</span><span class=nx>path</span><span class=p>))</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>它没有像你预期的那样工作。而不是“AAAAsuffix/BBBBBBBBB”，你最终得到的是“AAAAsuffix/uffixBBBB”。发生这种情况是因为两个目录切片都引用了原始路径切片中相同的底层数组数据。这意味着原始路径也被修改了。根据您的应用程序，这也可能是一个问题。</p><p>这个问题可以通过分配新切片和复制你需要的数据来解决。另一种选择是使用完整的切片表达式。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;bytes&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>path</span> <span class=o>:=</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=s>&#34;AAAA/BBBBBBBBB&#34;</span><span class=p>)</span>
    <span class=nx>sepIndex</span> <span class=o>:=</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>IndexByte</span><span class=p>(</span><span class=nx>path</span><span class=p>,</span><span class=sc>&#39;/&#39;</span><span class=p>)</span>
    <span class=nx>dir1</span> <span class=o>:=</span> <span class=nx>path</span><span class=p>[:</span><span class=nx>sepIndex</span><span class=p>:</span><span class=nx>sepIndex</span><span class=p>]</span> <span class=c1>//full slice expression
</span><span class=c1></span>    <span class=nx>dir2</span> <span class=o>:=</span> <span class=nx>path</span><span class=p>[</span><span class=nx>sepIndex</span><span class=o>+</span><span class=mi>1</span><span class=p>:]</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;dir1 =&gt;&#34;</span><span class=p>,</span><span class=nb>string</span><span class=p>(</span><span class=nx>dir1</span><span class=p>))</span> <span class=c1>//prints: dir1 =&gt; AAAA
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;dir2 =&gt;&#34;</span><span class=p>,</span><span class=nb>string</span><span class=p>(</span><span class=nx>dir2</span><span class=p>))</span> <span class=c1>//prints: dir2 =&gt; BBBBBBBBB
</span><span class=c1></span>
    <span class=nx>dir1</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>dir1</span><span class=p>,</span><span class=s>&#34;suffix&#34;</span><span class=o>...</span><span class=p>)</span>
    <span class=nx>path</span> <span class=p>=</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>Join</span><span class=p>([][]</span><span class=kt>byte</span><span class=p>{</span><span class=nx>dir1</span><span class=p>,</span><span class=nx>dir2</span><span class=p>},[]</span><span class=kt>byte</span><span class=p>{</span><span class=sc>&#39;/&#39;</span><span class=p>})</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;dir1 =&gt;&#34;</span><span class=p>,</span><span class=nb>string</span><span class=p>(</span><span class=nx>dir1</span><span class=p>))</span> <span class=c1>//prints: dir1 =&gt; AAAAsuffix
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;dir2 =&gt;&#34;</span><span class=p>,</span><span class=nb>string</span><span class=p>(</span><span class=nx>dir2</span><span class=p>))</span> <span class=c1>//prints: dir2 =&gt; BBBBBBBBB (ok now)
</span><span class=c1></span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;new path =&gt;&#34;</span><span class=p>,</span><span class=nb>string</span><span class=p>(</span><span class=nx>path</span><span class=p>))</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>完整切片表达式中的额外参数控制新切片的容量。现在追加到该切片将触发新的缓冲区分配，而不是覆盖第二个切片中的数据。</p><h2 id=47切片中的旧数据><strong>47.切片中的*<em>“旧数据”*</em></strong></h2><p>等级：中级</p><p>多个切片可以引用相同的数据。例如，当您从现有切片创建新切片时，可能会发生这种情况。如果您的应用程序依赖此行为来正常运行，那么您需要担心“陈旧”切片。</p><p>在某些时候，当原始数组无法容纳更多新数据时，将数据添加到其中一个切片将导致新的数组分配。现在其他切片将指向旧数组（带有旧数据）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>s1</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>}</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>s1</span><span class=p>),</span><span class=nb>cap</span><span class=p>(</span><span class=nx>s1</span><span class=p>),</span><span class=nx>s1</span><span class=p>)</span> <span class=c1>//prints 3 3 [1 2 3]
</span><span class=c1></span>
    <span class=nx>s2</span> <span class=o>:=</span> <span class=nx>s1</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>s2</span><span class=p>),</span><span class=nb>cap</span><span class=p>(</span><span class=nx>s2</span><span class=p>),</span><span class=nx>s2</span><span class=p>)</span> <span class=c1>//prints 2 2 [2 3]
</span><span class=c1></span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s2</span> <span class=p>{</span> <span class=nx>s2</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>20</span> <span class=p>}</span>

    <span class=c1>//still referencing the same array
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>s1</span><span class=p>)</span> <span class=c1>//prints [1 22 23]
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>s2</span><span class=p>)</span> <span class=c1>//prints [22 23]
</span><span class=c1></span>
    <span class=nx>s2</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s2</span><span class=p>,</span><span class=mi>4</span><span class=p>)</span>

    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s2</span> <span class=p>{</span> <span class=nx>s2</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>10</span> <span class=p>}</span>

    <span class=c1>//s1 is now &#34;stale&#34;
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>s1</span><span class=p>)</span> <span class=c1>//prints [1 22 23]
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>s2</span><span class=p>)</span> <span class=c1>//prints [32 33 14]
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=48类型声明和方法><strong>48.类型声明和方法</strong></h2><p>等级：中级</p><p>当您通过从现有（非接口）类型定义新类型来创建类型声明时，您不会继承为该现有类型定义的方法。</p><p>Fails:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;sync&#34;</span>

<span class=kd>type</span> <span class=nx>myMutex</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>mtx</span> <span class=nx>myMutex</span>
    <span class=nx>mtx</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span> <span class=c1>//error
</span><span class=c1></span>    <span class=nx>mtx</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span> <span class=c1>//error  
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Compile Errors:</p><blockquote><p>/tmp/sandbox106401185/main.go:9: mtx.Lock undefined (type myMutex has no field or method Lock) /tmp/sandbox106401185/main.go:10: mtx.Unlock undefined (type myMutex has no field or method Unlock)</p></blockquote><p>如果您确实需要原始类型的方法，您可以<em>定义一个新的结构类型，将原始类型嵌入为匿名字段。</em></p><p>Works:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;sync&#34;</span>

<span class=kd>type</span> <span class=nx>myLocker</span> <span class=kd>struct</span> <span class=p>{</span>  
    <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>lock</span> <span class=nx>myLocker</span>
    <span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span> <span class=c1>//ok
</span><span class=c1></span>    <span class=nx>lock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span> <span class=c1>//ok
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>接口类型声明也保留了它们的方法集。</p><p>Works:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;sync&#34;</span>

<span class=kd>type</span> <span class=nx>myLocker</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Locker</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>lock</span> <span class=nx>myLocker</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span><span class=p>)</span>
    <span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span> <span class=c1>//ok
</span><span class=c1></span>    <span class=nx>lock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span> <span class=c1>//ok
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=49-从for-switch和for-select代码块中-break><strong>49. 从“for switch”和“for select”代码块中 break</strong></h2><p>等级：中级</p><p>没有标签的“break”语句只会让你脱离内部 switch/select 块。如果使用“return”语句不是一个选项，那么为外部循环定义一个标签是下一个最好的事情。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>loop</span><span class=p>:</span>
        <span class=k>for</span> <span class=p>{</span>
            <span class=k>switch</span> <span class=p>{</span>
            <span class=k>case</span> <span class=kc>true</span><span class=p>:</span>
                <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;breaking out...&#34;</span><span class=p>)</span>
                <span class=k>break</span> <span class=nx>loop</span>
            <span class=p>}</span>
        <span class=p>}</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;out!&#34;</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>“goto”语句也可以解决问题&mldr;&mldr;</p><h2 id=50for语句中的迭代变量和闭包><strong>50.“for”语句中的迭代变量和闭包</strong></h2><p>等级：中级</p><p>这是 Go 中最常见的问题。<em>for语句中的迭代变量在每次迭代中被重用</em>。这意味着在for循环中创建的每个闭包（又名<em>函数字面量</em>）都将引用相同的变量（并且它们将在这些 goroutine 开始执行时获取该变量的值）。</p><p>Incorrect:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;time&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>data</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;one&#34;</span><span class=p>,</span><span class=s>&#34;two&#34;</span><span class=p>,</span><span class=s>&#34;three&#34;</span><span class=p>}</span>

    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span><span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>data</span> <span class=p>{</span>
        <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span>
        <span class=p>}()</span>
    <span class=p>}</span>

    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>3</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
    <span class=c1>//goroutines print: three, three, three
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>最简单的解决方案（不需要对goroutine进行任何修改），是将当前迭代变量值保存到for循环内的局部变量中</p><p>Works:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;time&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>data</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;one&#34;</span><span class=p>,</span><span class=s>&#34;two&#34;</span><span class=p>,</span><span class=s>&#34;three&#34;</span><span class=p>}</span>

    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span><span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>data</span> <span class=p>{</span>
        <span class=nx>vcopy</span> <span class=o>:=</span> <span class=nx>v</span> <span class=c1>// 循环体内局部变量
</span><span class=c1></span>        <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>vcopy</span><span class=p>)</span>
        <span class=p>}()</span>
    <span class=p>}</span>

    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>3</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
    <span class=c1>//goroutines print: one, two, three
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>另一种解决方案是将当前迭代变量作为参数传递给匿名 goroutine。</p><p>Works:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;time&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>data</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;one&#34;</span><span class=p>,</span><span class=s>&#34;two&#34;</span><span class=p>,</span><span class=s>&#34;three&#34;</span><span class=p>}</span>

    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span><span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>data</span> <span class=p>{</span>
        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>in</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>in</span><span class=p>)</span>
        <span class=p>}(</span><span class=nx>v</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>3</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
    <span class=c1>//goroutines print: one, two, three
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>这是一个稍微复杂一点的陷阱版本。</p><p>Incorrect:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;time&#34;</span>
<span class=p>)</span>

<span class=kd>type</span> <span class=nx>field</span> <span class=kd>struct</span> <span class=p>{</span>  
    <span class=nx>name</span> <span class=kt>string</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>field</span><span class=p>)</span> <span class=nb>print</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>name</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>data</span> <span class=o>:=</span> <span class=p>[]</span><span class=nx>field</span><span class=p>{{</span><span class=s>&#34;one&#34;</span><span class=p>},{</span><span class=s>&#34;two&#34;</span><span class=p>},{</span><span class=s>&#34;three&#34;</span><span class=p>}}</span>

    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span><span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>data</span> <span class=p>{</span>
        <span class=k>go</span> <span class=nx>v</span><span class=p>.</span><span class=nb>print</span><span class=p>()</span>
    <span class=p>}</span>

    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>3</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
    <span class=c1>//goroutines print: three, three, three
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Works:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;time&#34;</span>
<span class=p>)</span>

<span class=kd>type</span> <span class=nx>field</span> <span class=kd>struct</span> <span class=p>{</span>  
    <span class=nx>name</span> <span class=kt>string</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>field</span><span class=p>)</span> <span class=nb>print</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>name</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>data</span> <span class=o>:=</span> <span class=p>[]</span><span class=nx>field</span><span class=p>{{</span><span class=s>&#34;one&#34;</span><span class=p>},{</span><span class=s>&#34;two&#34;</span><span class=p>},{</span><span class=s>&#34;three&#34;</span><span class=p>}}</span>

    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span><span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>data</span> <span class=p>{</span>
        <span class=nx>v</span> <span class=o>:=</span> <span class=nx>v</span>
        <span class=k>go</span> <span class=nx>v</span><span class=p>.</span><span class=nb>print</span><span class=p>()</span>
    <span class=p>}</span>

    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>3</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
    <span class=c1>//goroutines print: one, two, three
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>你认为当你运行这段代码时你会看到什么（为什么）？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;time&#34;</span>
<span class=p>)</span>

<span class=kd>type</span> <span class=nx>field</span> <span class=kd>struct</span> <span class=p>{</span>  
    <span class=nx>name</span> <span class=kt>string</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>field</span><span class=p>)</span> <span class=nb>print</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>name</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>data</span> <span class=o>:=</span> <span class=p>[]</span><span class=o>*</span><span class=nx>field</span><span class=p>{{</span><span class=s>&#34;one&#34;</span><span class=p>},{</span><span class=s>&#34;two&#34;</span><span class=p>},{</span><span class=s>&#34;three&#34;</span><span class=p>}}</span>

    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span><span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>data</span> <span class=p>{</span>
        <span class=k>go</span> <span class=nx>v</span><span class=p>.</span><span class=nb>print</span><span class=p>()</span>
    <span class=p>}</span>

    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>3</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=51延迟函数调用参数评估><strong>51.延迟函数调用参数评估</strong></h2><p>等级：中级</p><p>延迟函数调用的参数是在评估defer语句时评估的（而不是在函数实际执行时）。当您推迟方法调用时，同样的规则也适用。结构值也与显式方法参数和封闭变量一起保存。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>i</span> <span class=kt>int</span> <span class=p>=</span> <span class=mi>1</span>

    <span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;result =&gt;&#34;</span><span class=p>,</span><span class=kd>func</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span> <span class=k>return</span> <span class=nx>i</span> <span class=o>*</span> <span class=mi>2</span> <span class=p>}())</span>
    <span class=nx>i</span><span class=o>++</span>
    <span class=c1>//prints: result =&gt; 2 (not ok if you expected 4)
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>如果您有指针参数，则可以更改它们指向的值，因为在defer评估语句时只保存<strong>指针</strong>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>
  <span class=s>&#34;fmt&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span>
  <span class=k>defer</span> <span class=kd>func</span> <span class=p>(</span><span class=nx>in</span> <span class=o>*</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;result =&gt;&#34;</span><span class=p>,</span> <span class=o>*</span><span class=nx>in</span><span class=p>)</span> <span class=p>}(</span><span class=o>&amp;</span><span class=nx>i</span><span class=p>)</span>
  
  <span class=nx>i</span> <span class=p>=</span> <span class=mi>2</span>
  <span class=c1>//prints: result =&gt; 2
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=52延迟函数调用执行><strong>52.延迟函数调用执行</strong></h2><p>等级：中级</p><p>延迟调用在包含函数的末尾执行（并且以相反的顺序），而不是在包含代码块的末尾。对于新的 Go 开发人员来说，将延迟代码执行规则与变量作用域规则混淆是一个容易犯的错误。如果你有一个长时间运行的函数，它有一个for循环尝试defer在每次迭代中清理资源调用，这可能会成为一个问题。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;os&#34;</span>
    <span class=s>&#34;path/filepath&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>2</span> <span class=p>{</span>
        <span class=nx>os</span><span class=p>.</span><span class=nf>Exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=nx>start</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Stat</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>||</span> <span class=p>!</span><span class=nx>start</span><span class=p>.</span><span class=nf>IsDir</span><span class=p>(){</span>
        <span class=nx>os</span><span class=p>.</span><span class=nf>Exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=kd>var</span> <span class=nx>targets</span> <span class=p>[]</span><span class=kt>string</span>
    <span class=nx>filepath</span><span class=p>.</span><span class=nf>Walk</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=kd>func</span><span class=p>(</span><span class=nx>fpath</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>fi</span> <span class=nx>os</span><span class=p>.</span><span class=nx>FileInfo</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=k>return</span> <span class=nx>err</span>
        <span class=p>}</span>

        <span class=k>if</span> <span class=p>!</span><span class=nx>fi</span><span class=p>.</span><span class=nf>Mode</span><span class=p>().</span><span class=nf>IsRegular</span><span class=p>()</span> <span class=p>{</span>
            <span class=k>return</span> <span class=kc>nil</span>
        <span class=p>}</span>

        <span class=nx>targets</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>targets</span><span class=p>,</span><span class=nx>fpath</span><span class=p>)</span>
        <span class=k>return</span> <span class=kc>nil</span>
    <span class=p>})</span>

    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span><span class=nx>target</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>targets</span> <span class=p>{</span>
        <span class=nx>f</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Open</span><span class=p>(</span><span class=nx>target</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;bad target:&#34;</span><span class=p>,</span><span class=nx>target</span><span class=p>,</span><span class=s>&#34;error:&#34;</span><span class=p>,</span><span class=nx>err</span><span class=p>)</span> <span class=c1>//prints error: too many open files
</span><span class=c1></span>            <span class=k>break</span>
        <span class=p>}</span>
        <span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span> <span class=c1>//will not be closed at the end of this code block
</span><span class=c1></span>        <span class=c1>//do something with the file...
</span><span class=c1></span>    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>解决问题的一种方法是将代码块包装在函数中。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;os&#34;</span>
    <span class=s>&#34;path/filepath&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>2</span> <span class=p>{</span>
        <span class=nx>os</span><span class=p>.</span><span class=nf>Exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=nx>start</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Stat</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>||</span> <span class=p>!</span><span class=nx>start</span><span class=p>.</span><span class=nf>IsDir</span><span class=p>(){</span>
        <span class=nx>os</span><span class=p>.</span><span class=nf>Exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=kd>var</span> <span class=nx>targets</span> <span class=p>[]</span><span class=kt>string</span>
    <span class=nx>filepath</span><span class=p>.</span><span class=nf>Walk</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=kd>func</span><span class=p>(</span><span class=nx>fpath</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>fi</span> <span class=nx>os</span><span class=p>.</span><span class=nx>FileInfo</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=k>return</span> <span class=nx>err</span>
        <span class=p>}</span>

        <span class=k>if</span> <span class=p>!</span><span class=nx>fi</span><span class=p>.</span><span class=nf>Mode</span><span class=p>().</span><span class=nf>IsRegular</span><span class=p>()</span> <span class=p>{</span>
            <span class=k>return</span> <span class=kc>nil</span>
        <span class=p>}</span>

        <span class=nx>targets</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>targets</span><span class=p>,</span><span class=nx>fpath</span><span class=p>)</span>
        <span class=k>return</span> <span class=kc>nil</span>
    <span class=p>})</span>

    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span><span class=nx>target</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>targets</span> <span class=p>{</span>
        <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
            <span class=nx>f</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Open</span><span class=p>(</span><span class=nx>target</span><span class=p>)</span>
            <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
                <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;bad target:&#34;</span><span class=p>,</span><span class=nx>target</span><span class=p>,</span><span class=s>&#34;error:&#34;</span><span class=p>,</span><span class=nx>err</span><span class=p>)</span>
                <span class=k>return</span>
            <span class=p>}</span>
            <span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span> <span class=c1>//ok
</span><span class=c1></span>            <span class=c1>//do something with the file...
</span><span class=c1></span>        <span class=p>}()</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>另一种选择是摆脱defer声明:-)</p><h2 id=53失败的类型断言><strong>53.失败的类型断言</strong></h2><p>等级：中级</p><p>失败的类型断言返回断言语句中使用的目标类型的“零值”。当它与可变阴影混合时，这可能会导致意外行为。</p><p>Incorrect:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>data</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>=</span> <span class=s>&#34;great&#34;</span>

    <span class=k>if</span> <span class=nx>data</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>data</span><span class=p>.(</span><span class=kt>int</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;[is an int] value =&gt;&#34;</span><span class=p>,</span><span class=nx>data</span><span class=p>)</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;[not an int] value =&gt;&#34;</span><span class=p>,</span><span class=nx>data</span><span class=p>)</span> 
        <span class=c1>//prints: [not an int] value =&gt; 0 (not &#34;great&#34;)
</span><span class=c1></span>    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Works:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>data</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>=</span> <span class=s>&#34;great&#34;</span>

    <span class=k>if</span> <span class=nx>res</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>data</span><span class=p>.(</span><span class=kt>int</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;[is an int] value =&gt;&#34;</span><span class=p>,</span><span class=nx>res</span><span class=p>)</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;[not an int] value =&gt;&#34;</span><span class=p>,</span><span class=nx>data</span><span class=p>)</span> 
        <span class=c1>//prints: [not an int] value =&gt; great (as expected)
</span><span class=c1></span>    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=54阻塞的-goroutines-和资源泄漏><strong>54.阻塞的 Goroutines 和资源泄漏</strong></h2><p>等级：中级</p><p>Rob Pike 在 2012 年 Google I/O 上的“Go Concurrency Patterns”演讲中谈到了一些基本的并发模式。从多个目标中获取第一个结果就是其中之一。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>First</span><span class=p>(</span><span class=nx>query</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>replicas</span> <span class=o>...</span><span class=nx>Search</span><span class=p>)</span> <span class=nx>Result</span> <span class=p>{</span>  
    <span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=nx>Result</span><span class=p>)</span>
    <span class=nx>searchReplica</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span> <span class=nx>c</span> <span class=o>&lt;-</span> <span class=nx>replicas</span><span class=p>[</span><span class=nx>i</span><span class=p>](</span><span class=nx>query</span><span class=p>)</span> <span class=p>}</span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>replicas</span> <span class=p>{</span>
        <span class=k>go</span> <span class=nf>searchReplica</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=o>&lt;-</span><span class=nx>c</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>该函数为每个搜索副本启动一个 goroutine。每个 goroutine 将其搜索结果发送到结果通道。返回结果通道的第一个值。</p><p>其他 goroutine 的结果如何？goroutines 本身呢？</p><p>函数中的结果通道First()是无缓冲的。这意味着只有第一个 goroutine 返回。所有其他 goroutine 都被困在试图发送它们的结果。这意味着如果您有多个副本，则每次调用都会泄漏资源。</p><p>为避免泄漏，您需要确保所有 goroutine 都退出。一种可能的解决方案是使用足够大的缓冲结果通道来保存所有结果。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>First</span><span class=p>(</span><span class=nx>query</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>replicas</span> <span class=o>...</span><span class=nx>Search</span><span class=p>)</span> <span class=nx>Result</span> <span class=p>{</span>  
    <span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=nx>Result</span><span class=p>,</span><span class=nb>len</span><span class=p>(</span><span class=nx>replicas</span><span class=p>))</span>
    <span class=nx>searchReplica</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span> <span class=nx>c</span> <span class=o>&lt;-</span> <span class=nx>replicas</span><span class=p>[</span><span class=nx>i</span><span class=p>](</span><span class=nx>query</span><span class=p>)</span> <span class=p>}</span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>replicas</span> <span class=p>{</span>
        <span class=k>go</span> <span class=nf>searchReplica</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=o>&lt;-</span><span class=nx>c</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>另一种可能的解决方案是使用select带有案例的语句default和可以保存一个值的缓冲结果通道。该default案例确保即使结果通道无法接收消息，goroutines 也不会卡住。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>First</span><span class=p>(</span><span class=nx>query</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>replicas</span> <span class=o>...</span><span class=nx>Search</span><span class=p>)</span> <span class=nx>Result</span> <span class=p>{</span>  
    <span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=nx>Result</span><span class=p>,</span><span class=mi>1</span><span class=p>)</span>
    <span class=nx>searchReplica</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span> 
        <span class=k>select</span> <span class=p>{</span>
        <span class=k>case</span> <span class=nx>c</span> <span class=o>&lt;-</span> <span class=nx>replicas</span><span class=p>[</span><span class=nx>i</span><span class=p>](</span><span class=nx>query</span><span class=p>):</span>
        <span class=k>default</span><span class=p>:</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>replicas</span> <span class=p>{</span>
        <span class=k>go</span> <span class=nf>searchReplica</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=o>&lt;-</span><span class=nx>c</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>您还可以使用特殊的取消通道来中断worker。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>First</span><span class=p>(</span><span class=nx>query</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>replicas</span> <span class=o>...</span><span class=nx>Search</span><span class=p>)</span> <span class=nx>Result</span> <span class=p>{</span>  
    <span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=nx>Result</span><span class=p>)</span>
    <span class=nx>done</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
    <span class=k>defer</span> <span class=nb>close</span><span class=p>(</span><span class=nx>done</span><span class=p>)</span>
    <span class=nx>searchReplica</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span> 
        <span class=k>select</span> <span class=p>{</span>
        <span class=k>case</span> <span class=nx>c</span> <span class=o>&lt;-</span> <span class=nx>replicas</span><span class=p>[</span><span class=nx>i</span><span class=p>](</span><span class=nx>query</span><span class=p>):</span>
        <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>done</span><span class=p>:</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>replicas</span> <span class=p>{</span>
        <span class=k>go</span> <span class=nf>searchReplica</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=o>&lt;-</span><span class=nx>c</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>为什么演示文稿包含这些错误？Rob Pike 只是不想让幻灯片复杂化。这是有道理的，但对于新的 Go 开发人员来说，这可能是一个问题，他们会按原样使用代码而不考虑它可能有问题。</p><h2 id=55不同零大小变量的相同地址><strong>55.不同零大小变量的相同地址</strong></h2><p>等级：中级</p><p>如果您有两个不同的变量，它们不应该有不同的地址吗？好吧，Go 不是这种情况 :-) 如果你有零大小的变量，它们可能在内存中共享完全相同的地址。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>
  <span class=s>&#34;fmt&#34;</span>
<span class=p>)</span>

<span class=kd>type</span> <span class=nx>data</span> <span class=kd>struct</span> <span class=p>{</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=nx>a</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>data</span><span class=p>{}</span>
  <span class=nx>b</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>data</span><span class=p>{}</span>
  
  <span class=k>if</span> <span class=nx>a</span> <span class=o>==</span> <span class=nx>b</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;same address - a=%p b=%p\n&#34;</span><span class=p>,</span><span class=nx>a</span><span class=p>,</span><span class=nx>b</span><span class=p>)</span>
    <span class=c1>//prints: same address - a=0x1953e4 b=0x1953e4
</span><span class=c1></span>  <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=56iota-的首次使用并不总是从零开始><strong>56.iota 的首次使用并不总是从零开始</strong></h2><p>等级：中级</p><p>看起来标识符iota就像一个增量运算符。你开始一个新的常量声明，第一次使用iota你得到零，第二次使用它你得到一个，依此类推。但情况并非总是如此。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>
  <span class=s>&#34;fmt&#34;</span>
<span class=p>)</span>

<span class=kd>const</span> <span class=p>(</span>
  <span class=nx>azero</span> <span class=p>=</span> <span class=kc>iota</span>
  <span class=nx>aone</span>  <span class=p>=</span> <span class=kc>iota</span>
<span class=p>)</span>

<span class=kd>const</span> <span class=p>(</span>
  <span class=nx>info</span>  <span class=p>=</span> <span class=s>&#34;processing&#34;</span>
  <span class=nx>bzero</span> <span class=p>=</span> <span class=kc>iota</span>
  <span class=nx>bone</span>  <span class=p>=</span> <span class=kc>iota</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>azero</span><span class=p>,</span><span class=nx>aone</span><span class=p>)</span> <span class=c1>//prints: 0 1
</span><span class=c1></span>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>bzero</span><span class=p>,</span><span class=nx>bone</span><span class=p>)</span> <span class=c1>//prints: 1 2
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>iota确实是常量声明块中当前行的索引运算符，因此如果第一次使用的不是iota常量声明块中的第一行，则初始值不会为零。</p><h2 id=57在值实例上使用指针接收器方法><strong>57.在值实例上使用</strong>指针接收器方法</h2><p>等级：高级</p><p>只要值是可寻址的，就可以对值调用<strong>指针接收器</strong>方法。换句话说，在某些情况下，您不需要该方法的值接收器版本。</p><p>不过，并非每个变量都是可寻址的。map元素不可寻址。通过接口引用的变量也是不可寻址的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>type</span> <span class=nx>data</span> <span class=kd>struct</span> <span class=p>{</span>  
    <span class=nx>name</span> <span class=kt>string</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>data</span><span class=p>)</span> <span class=nb>print</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;name:&#34;</span><span class=p>,</span><span class=nx>p</span><span class=p>.</span><span class=nx>name</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>type</span> <span class=nx>printer</span> <span class=kd>interface</span> <span class=p>{</span>  
    <span class=nb>print</span><span class=p>()</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>d1</span> <span class=o>:=</span> <span class=nx>data</span><span class=p>{</span><span class=s>&#34;one&#34;</span><span class=p>}</span>
    <span class=nx>d1</span><span class=p>.</span><span class=nb>print</span><span class=p>()</span> <span class=c1>//ok
</span><span class=c1></span>
    <span class=c1>// var in printer = data{&#34;two&#34;} //error
</span><span class=c1></span>    <span class=kd>var</span> <span class=nx>in</span> <span class=nx>printer</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>data</span><span class=p>{</span><span class=s>&#34;two&#34;</span><span class=p>}</span> <span class=c1>//good
</span><span class=c1></span>    <span class=nx>in</span><span class=p>.</span><span class=nb>print</span><span class=p>()</span>

    <span class=nx>m</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>data</span> <span class=p>{</span><span class=s>&#34;x&#34;</span><span class=p>:</span><span class=nx>data</span><span class=p>{</span><span class=s>&#34;three&#34;</span><span class=p>}}</span>
    <span class=nx>m</span><span class=p>[</span><span class=s>&#34;x&#34;</span><span class=p>].</span><span class=nb>print</span><span class=p>()</span> <span class=c1>//error
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Compile Errors:</p><blockquote><p>/tmp/sandbox017696142/main.go:21: cannot use data literal (type data) as type printer in assignment: data does not implement printer (print method has pointer receiver)
/tmp/sandbox017696142/main.go:25: cannot call pointer method on m[&ldquo;x&rdquo;] /tmp/sandbox017696142/main.go:25: cannot take the address of m[&ldquo;x&rdquo;]</p></blockquote><h2 id=58更新-map-值字段><strong>58.更新 map 值字段</strong></h2><p>等级：高级</p><p>如果您有结构值映射，则无法更新单个结构字段。</p><p>Fails:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>type</span> <span class=nx>data</span> <span class=kd>struct</span> <span class=p>{</span>  
    <span class=nx>name</span> <span class=kt>string</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>m</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>data</span> <span class=p>{</span><span class=s>&#34;x&#34;</span><span class=p>:{</span><span class=s>&#34;one&#34;</span><span class=p>}}</span>
    <span class=nx>m</span><span class=p>[</span><span class=s>&#34;x&#34;</span><span class=p>].</span><span class=nx>name</span> <span class=p>=</span> <span class=s>&#34;two&#34;</span> <span class=c1>//error
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Compile Error:</p><blockquote><p>/tmp/sandbox380452744/main.go:9: cannot assign to m[&ldquo;x&rdquo;].name</p></blockquote><p>它不起作用，因为map元素不可寻址。</p><p>说明：map 在内存中的存储结构与数组和指针不同，它是由哈希表实现的，每个键值对都有一个哈希值作为索引，用于快速查找数据。如果 map 可以寻址，那么它的哈希值就会发生变化，导致无法快速查找数据，从而破坏了 map 的内部结构。</p><p>而且，map 的大小是动态变化的，它可以根据添加或删除键值对来动态扩容或缩小。如果 map 可以寻址，那么它的内部结构就会发生变化，因此 Golang 的设计者禁止了 map 的寻址。</p><p>在 Golang 中，如果我们需要修改 map 或 slice 中的值，可以使用索引或者指针来进行操作。</p><p>对于新的 Go 开发者来说，更令人困惑的是 slice 元素是可寻址的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>type</span> <span class=nx>data</span> <span class=kd>struct</span> <span class=p>{</span>  
    <span class=nx>name</span> <span class=kt>string</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>s</span> <span class=o>:=</span> <span class=p>[]</span><span class=nx>data</span> <span class=p>{{</span><span class=s>&#34;one&#34;</span><span class=p>}}</span>
    <span class=nx>s</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=nx>name</span> <span class=p>=</span> <span class=s>&#34;two&#34;</span> <span class=c1>//ok
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>    <span class=c1>//prints: [{two}]
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>请注意，不久前可以在其中一个 Go 编译器 (gccgo) 中更新map元素字段，但该行为很快得到修复 :-) 它也被认为是 Go 1.3 的潜在功能。在那个时候支持它还不够重要，所以它仍然在待办事项列表上。</p><p>第一个解决方法是使用临时变量。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>type</span> <span class=nx>data</span> <span class=kd>struct</span> <span class=p>{</span>  
    <span class=nx>name</span> <span class=kt>string</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>m</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>data</span> <span class=p>{</span><span class=s>&#34;x&#34;</span><span class=p>:{</span><span class=s>&#34;one&#34;</span><span class=p>}}</span>
    <span class=nx>r</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>[</span><span class=s>&#34;x&#34;</span><span class=p>]</span>
    <span class=nx>r</span><span class=p>.</span><span class=nx>name</span> <span class=p>=</span> <span class=s>&#34;two&#34;</span>
    <span class=nx>m</span><span class=p>[</span><span class=s>&#34;x&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=nx>r</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%v&#34;</span><span class=p>,</span><span class=nx>m</span><span class=p>)</span> <span class=c1>//prints: map[x:{two}]
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>另一种解决方法是使用<strong>指针映射</strong>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>type</span> <span class=nx>data</span> <span class=kd>struct</span> <span class=p>{</span>  
    <span class=nx>name</span> <span class=kt>string</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>m</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=o>*</span><span class=nx>data</span> <span class=p>{</span><span class=s>&#34;x&#34;</span><span class=p>:{</span><span class=s>&#34;one&#34;</span><span class=p>}}</span>
    <span class=nx>m</span><span class=p>[</span><span class=s>&#34;x&#34;</span><span class=p>].</span><span class=nx>name</span> <span class=p>=</span> <span class=s>&#34;two&#34;</span> <span class=c1>//ok
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>m</span><span class=p>[</span><span class=s>&#34;x&#34;</span><span class=p>])</span> <span class=c1>//prints: &amp;{two}
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>顺便说一句，当你运行这段代码时会发生什么？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>type</span> <span class=nx>data</span> <span class=kd>struct</span> <span class=p>{</span>  
    <span class=nx>name</span> <span class=kt>string</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>m</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=o>*</span><span class=nx>data</span> <span class=p>{</span><span class=s>&#34;x&#34;</span><span class=p>:{</span><span class=s>&#34;one&#34;</span><span class=p>}}</span>
    <span class=nx>m</span><span class=p>[</span><span class=s>&#34;z&#34;</span><span class=p>].</span><span class=nx>name</span> <span class=p>=</span> <span class=s>&#34;what?&#34;</span> <span class=c1>//???
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=59nil接口和nil接口值><strong>59.“nil”接口和“nil”接口值</strong></h2><p>等级：高级</p><p>这是 Go 中第二个最常见的问题，因为<strong>接口不是指针</strong>，即使它们看起来像指针。只有当它们的*类型和值字段为“nil”*时，<em>接口变量才会为“nil”</em>。</p><p>接口类型和值字段是根据用于创建相应接口变量的变量的类型和值填充的。<em>当您尝试检查接口变量是否等于“nil”时，这可能会导致意外行为。</em></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=kd>var</span> <span class=nx>data</span> <span class=o>*</span><span class=kt>byte</span>
    <span class=kd>var</span> <span class=nx>in</span> <span class=kd>interface</span><span class=p>{}</span>

    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>data</span><span class=p>,</span><span class=nx>data</span> <span class=o>==</span> <span class=kc>nil</span><span class=p>)</span> <span class=c1>//prints: &lt;nil&gt; true
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>in</span><span class=p>,</span><span class=nx>in</span> <span class=o>==</span> <span class=kc>nil</span><span class=p>)</span>     <span class=c1>//prints: &lt;nil&gt; true
</span><span class=c1></span>
    <span class=nx>in</span> <span class=p>=</span> <span class=nx>data</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>in</span><span class=p>,</span><span class=nx>in</span> <span class=o>==</span> <span class=kc>nil</span><span class=p>)</span>     <span class=c1>//prints: &lt;nil&gt; false
</span><span class=c1></span>    <span class=c1>//&#39;data&#39; is &#39;nil&#39;, but &#39;in&#39; is not &#39;nil&#39;
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>当您有一个返回接口的函数时，请注意这个陷阱。</p><p>Incorrect:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>doit</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>arg</span> <span class=kt>int</span><span class=p>)</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
        <span class=kd>var</span> <span class=nx>result</span> <span class=o>*</span><span class=kd>struct</span><span class=p>{}</span> <span class=p>=</span> <span class=kc>nil</span>

        <span class=k>if</span><span class=p>(</span><span class=nx>arg</span> <span class=p>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=nx>result</span> <span class=p>=</span> <span class=o>&amp;</span><span class=kd>struct</span><span class=p>{}{}</span>
        <span class=p>}</span>

        <span class=k>return</span> <span class=nx>result</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=nx>res</span> <span class=o>:=</span> <span class=nf>doit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span> <span class=nx>res</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;good result:&#34;</span><span class=p>,</span><span class=nx>res</span><span class=p>)</span> <span class=c1>//prints: good result: &lt;nil&gt;
</span><span class=c1></span>        <span class=c1>//&#39;res&#39; is not &#39;nil&#39;, but its value is &#39;nil&#39;
</span><span class=c1></span>    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Works:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>doit</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>arg</span> <span class=kt>int</span><span class=p>)</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
        <span class=kd>var</span> <span class=nx>result</span> <span class=o>*</span><span class=kd>struct</span><span class=p>{}</span> <span class=p>=</span> <span class=kc>nil</span>

        <span class=k>if</span><span class=p>(</span><span class=nx>arg</span> <span class=p>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=nx>result</span> <span class=p>=</span> <span class=o>&amp;</span><span class=kd>struct</span><span class=p>{}{}</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=k>return</span> <span class=kc>nil</span> <span class=c1>//return an explicit &#39;nil&#39;
</span><span class=c1></span>        <span class=p>}</span>

        <span class=k>return</span> <span class=nx>result</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=nx>res</span> <span class=o>:=</span> <span class=nf>doit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span> <span class=nx>res</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;good result:&#34;</span><span class=p>,</span><span class=nx>res</span><span class=p>)</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;bad result (res is nil)&#34;</span><span class=p>)</span> <span class=c1>//here as expected
</span><span class=c1></span>    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=60堆栈和堆变量><strong>60.堆栈和堆变量</strong></h2><p>等级：高级</p><p>您并不总是知道您的变量是分配在堆栈还是堆上。在 C++ 中，使用new运算符创建变量始终意味着您有一个<em>堆</em>变量。在 Go 中，即使使用new() or make()函数，编译器也会决定分配变量的位置。<em>编译器</em>根据变量的大小和“转义分析”的结果<em>选择存储变量的位置</em>。这也意味着可以返回对局部变量的引用，这在 C 或 C++ 等其他语言中是不行的。</p><p>如果您需要知道变量的分配位置，请将“-m”gc 标志传递给“go build”或“go run”（例如，go run -gcflags -m app.go）。</p><h2 id=61gomaxprocs并发和并行><strong>61.GOMAXPROCS、并发和并行</strong></h2><p>等级：高级</p><p>Go 1.4 及以下版本仅使用一个执行上下文/操作系统线程。这意味着在任何给定时间只能执行一个 goroutine。从 1.5 开始，Go 将执行上下文的数量设置为由runtime.NumCPU(). 该数字可能与系统上的逻辑 CPU 内核总数匹配，也可能不匹配，具体取决于进程的 CPU 亲和性设置。您可以通过更改GOMAXPROCS环境变量或调用runtime.GOMAXPROCS()函数来调整此数字。</p><p>有一个常见的误解是GOMAXPROCS表示 Go 将用于运行 goroutine 的 CPU 数量。runtime.GOMAXPROCS()功能文档更加混乱。GOMAXPROCS变量描述（https://golang.org/pkg/runtime/ ）在谈论操作系统线程方面做得更好。</p><p>您可以设置GOMAXPROCS为超过 CPU 的数量。从 1.10 开始，GOMAXPROCS 不再有限制。曾经的最大值GOMAXPROCS是 256，后来在 1.9 中增加到 1024。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;runtime&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>runtime</span><span class=p>.</span><span class=nf>GOMAXPROCS</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span> <span class=c1>//prints: X (1 on play.golang.org)
</span><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>runtime</span><span class=p>.</span><span class=nf>NumCPU</span><span class=p>())</span>       <span class=c1>//prints: X (1 on play.golang.org)
</span><span class=c1></span>    <span class=nx>runtime</span><span class=p>.</span><span class=nf>GOMAXPROCS</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>runtime</span><span class=p>.</span><span class=nf>GOMAXPROCS</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span> <span class=c1>//prints: 20
</span><span class=c1></span>    <span class=nx>runtime</span><span class=p>.</span><span class=nf>GOMAXPROCS</span><span class=p>(</span><span class=mi>300</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>runtime</span><span class=p>.</span><span class=nf>GOMAXPROCS</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span> <span class=c1>//prints: 256
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=62读写操作重新排序><strong>62.读写操作重新排序</strong></h2><p>等级：高级</p><p>Go 可能会重新排序某些操作，但它可以确保发生它的 <strong>goroutine</strong> 中的整体行为不会改变。但是，它不能保证跨多个 goroutine 的执行顺序。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;runtime&#34;</span>
    <span class=s>&#34;time&#34;</span>
<span class=p>)</span>

<span class=kd>var</span> <span class=nx>_</span> <span class=p>=</span> <span class=nx>runtime</span><span class=p>.</span><span class=nf>GOMAXPROCS</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>

<span class=kd>var</span> <span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>int</span>

<span class=kd>func</span> <span class=nf>u1</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>a</span> <span class=p>=</span> <span class=mi>1</span>
    <span class=nx>b</span> <span class=p>=</span> <span class=mi>2</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>u2</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>a</span> <span class=p>=</span> <span class=mi>3</span>
    <span class=nx>b</span> <span class=p>=</span> <span class=mi>4</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>p</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nb>println</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span>
    <span class=nb>println</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=k>go</span> <span class=nf>u1</span><span class=p>()</span>
    <span class=k>go</span> <span class=nf>u2</span><span class=p>()</span>
    <span class=k>go</span> <span class=nf>p</span><span class=p>()</span>
    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>If you run this code a few times you might see these <code>a</code> and <code>b</code> variable combinations:</p><blockquote><p>1
2</p><p>3
4</p><p>0
2</p><p>0
0</p><p>1
4</p></blockquote><p>The most interesting combination for <code>a</code> and <code>b</code> is &ldquo;02&rdquo;. It shows that <code>b</code> was updated before <code>a</code>.</p><p>如果您需要跨多个 goroutine 保持读写操作的顺序，则需要使用通道或“同步”包中的适当构造。</p><h2 id=63抢先调度><strong>63.抢先调度</strong></h2><p>等级：高级</p><p>可能有一个流氓 goroutine 会阻止其他 goroutine 运行。如果您有一个for不允许调度程序运行的循环，则可能会发生这种情况。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>done</span> <span class=o>:=</span> <span class=kc>false</span>

    <span class=k>go</span> <span class=kd>func</span><span class=p>(){</span>
        <span class=nx>done</span> <span class=p>=</span> <span class=kc>true</span>
    <span class=p>}()</span>

    <span class=k>for</span> <span class=p>!</span><span class=nx>done</span> <span class=p>{</span>
    <span class=p>}</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;done!&#34;</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>for循环不必为空。只要它包含不触发调度程序执行的代码，它就会成为一个问题。</p><p>调度程序将在 GC、“go”语句、阻塞通道操作、阻塞系统调用和锁定操作之后运行。它也可以在调用非内联函数时运行。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>done</span> <span class=o>:=</span> <span class=kc>false</span>

    <span class=k>go</span> <span class=kd>func</span><span class=p>(){</span>
        <span class=nx>done</span> <span class=p>=</span> <span class=kc>true</span>
    <span class=p>}()</span>

    <span class=k>for</span> <span class=p>!</span><span class=nx>done</span> <span class=p>{</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;not done!&#34;</span><span class=p>)</span> <span class=c1>//not inlined
</span><span class=c1></span>    <span class=p>}</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;done!&#34;</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>要确定您在for循环中调用的函数是否内联，请将“-m”gc 标志传递给“go build”或“go run”（例如，go build -gcflags -m）。</p><p>另一种选择是显式调用调度程序。您可以使用Gosched()“运行时”包中的功能来完成。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;runtime&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>done</span> <span class=o>:=</span> <span class=kc>false</span>

    <span class=k>go</span> <span class=kd>func</span><span class=p>(){</span>
        <span class=nx>done</span> <span class=p>=</span> <span class=kc>true</span>
    <span class=p>}()</span>

    <span class=k>for</span> <span class=p>!</span><span class=nx>done</span> <span class=p>{</span>
        <span class=nx>runtime</span><span class=p>.</span><span class=nf>Gosched</span><span class=p>()</span>
    <span class=p>}</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;done!&#34;</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>请注意，上面的代码包含竞争条件。故意这样做是为了显示出问题的陷阱。</p><h2 id=64导入-c-和多行导入块><strong>64.导入 C 和多行导入块</strong></h2><p>等级：CGO</p><p>您需要导入“C”包才能使用 Cgo。你可以用一行import来做，也可以用一个import块来做。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=cm>/*
</span><span class=cm>#include &lt;stdlib.h&gt;
</span><span class=cm>*/</span>
<span class=kn>import</span> <span class=p>(</span>
  <span class=s>&#34;C&#34;</span>
<span class=p>)</span>

<span class=kn>import</span> <span class=p>(</span>
  <span class=s>&#34;unsafe&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=nx>cs</span> <span class=o>:=</span> <span class=nx>C</span><span class=p>.</span><span class=nf>CString</span><span class=p>(</span><span class=s>&#34;my go string&#34;</span><span class=p>)</span>
  <span class=nx>C</span><span class=p>.</span><span class=nf>free</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>cs</span><span class=p>))</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>如果您使用import块格式，则不能在同一块中导入其他包。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=cm>/*
</span><span class=cm>#include &lt;stdlib.h&gt;
</span><span class=cm>*/</span>
<span class=kn>import</span> <span class=p>(</span>
  <span class=s>&#34;C&#34;</span>
  <span class=s>&#34;unsafe&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=nx>cs</span> <span class=o>:=</span> <span class=nx>C</span><span class=p>.</span><span class=nf>CString</span><span class=p>(</span><span class=s>&#34;my go string&#34;</span><span class=p>)</span>
  <span class=nx>C</span><span class=p>.</span><span class=nf>free</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>cs</span><span class=p>))</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Compile Error:</p><blockquote><p>./main.go:13:2: could not determine kind of name for C.free</p></blockquote><h2 id=65import-c-和-cgo-注释之间没有空行><strong>65.Import C 和 Cgo 注释之间没有空行</strong></h2><p>等级：CGO</p><p>Cgo 的第一个陷阱之一是import &ldquo;C"语句上方的 cgo 注释的位置。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=cm>/*
</span><span class=cm>#include &lt;stdlib.h&gt;
</span><span class=cm>*/</span>

<span class=kn>import</span> <span class=s>&#34;C&#34;</span>

<span class=kn>import</span> <span class=p>(</span>
  <span class=s>&#34;unsafe&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=nx>cs</span> <span class=o>:=</span> <span class=nx>C</span><span class=p>.</span><span class=nf>CString</span><span class=p>(</span><span class=s>&#34;my go string&#34;</span><span class=p>)</span>
  <span class=nx>C</span><span class=p>.</span><span class=nf>free</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>cs</span><span class=p>))</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Compile Error:</p><blockquote><p>./main.go:15:2: could not determine kind of name for C.free</p></blockquote><p><em>确保声明上方没有任何空行import &ldquo;C&rdquo;。</em></p><h2 id=66不能使用可变参数调用-c-函数><strong>66.不能使用可变参数调用 C 函数</strong></h2><p>等级：CGO</p><p>您不能直接调用带有可变参数的 C 函数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=cm>/*
</span><span class=cm>#include &lt;stdio.h&gt;
</span><span class=cm>#include &lt;stdlib.h&gt;
</span><span class=cm>*/</span>
<span class=kn>import</span> <span class=s>&#34;C&#34;</span>

<span class=kn>import</span> <span class=p>(</span>
  <span class=s>&#34;unsafe&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=nx>cstr</span> <span class=o>:=</span> <span class=nx>C</span><span class=p>.</span><span class=nf>CString</span><span class=p>(</span><span class=s>&#34;go&#34;</span><span class=p>)</span>
  <span class=nx>C</span><span class=p>.</span><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s\n&#34;</span><span class=p>,</span><span class=nx>cstr</span><span class=p>)</span> <span class=c1>//not ok
</span><span class=c1></span>  <span class=nx>C</span><span class=p>.</span><span class=nf>free</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>cstr</span><span class=p>))</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Compile Error:</p><blockquote><p>./main.go:15:2: unexpected type: &mldr;</p></blockquote><p>您必须将可变参数 C 函数包装在具有已知数量参数的函数中。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=cm>/*
</span><span class=cm>#include &lt;stdio.h&gt;
</span><span class=cm>#include &lt;stdlib.h&gt;
</span><span class=cm>
</span><span class=cm>void out(char* in) {
</span><span class=cm>  printf(&#34;%s\n&#34;, in);
</span><span class=cm>}
</span><span class=cm>*/</span>
<span class=kn>import</span> <span class=s>&#34;C&#34;</span>

<span class=kn>import</span> <span class=p>(</span>
  <span class=s>&#34;unsafe&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=nx>cstr</span> <span class=o>:=</span> <span class=nx>C</span><span class=p>.</span><span class=nf>CString</span><span class=p>(</span><span class=s>&#34;go&#34;</span><span class=p>)</span>
  <span class=nx>C</span><span class=p>.</span><span class=nf>out</span><span class=p>(</span><span class=nx>cstr</span><span class=p>)</span> <span class=c1>//ok
</span><span class=c1></span>  <span class=nx>C</span><span class=p>.</span><span class=nf>free</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>cstr</span><span class=p>))</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=原文参考httpdevscloudimmunitycomgotchas-and-common-mistakes-in-go-golang><strong><a href=http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/ target=_blank rel="noopener noreffer">原文参考</a></strong></h2></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2023-05-29</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/go/>Go</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/2023/03/%E5%AE%B9%E5%99%A8%E5%92%8Ckubernetes%E4%B8%AD%E7%9A%84%E9%80%80%E5%87%BA%E4%BB%A3%E7%A0%81%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/ class=prev rel=prev title=容器和Kubernetes中的退出代码–完整指南><i class="fas fa-angle-left fa-fw"></i>容器和Kubernetes中的退出代码–完整指南</a>
<a href=/posts/2023/06/k8s%E6%9F%A5%E8%AF%A2%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95/ class=next rel=next title=k8s查询队列方法>k8s查询队列方法<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=utterances></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>Utterances</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2016 - 2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=bingerambo.com target=_blank>Binge</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=http://bingerambo.com/ target=_blank>bingerambo.com</a></span></div><div class=footer-line><i class="fa fa-eye"></i>本站总访问量<span id=busuanzi_value_site_pv></span>次
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/css/lightgallery.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/js/lightgallery.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lg-thumbnail.js@1.2.0/dist/lg-thumbnail.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lg-zoom.js@1.2.0/dist/lg-zoom.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{"utterances":{"darkTheme":"github-dark","issueTerm":"pathname","label":"","lightTheme":"github-light","repo":"bingerambo/myblog-comments"}},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true}};</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','UA-81425808-1',{'anonymize_ip':true});</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=UA-81425808-1" async></script><script src=https://libs.baidu.com/jquery/2.1.4/jquery.min.js></script><script src=https://cdn.bootcdn.net/ajax/libs/jquery-backstretch/2.1.18/jquery.backstretch.min.js></script><script type=text/javascript src=/js/custom.js></script><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?c0176279eee823ce422da4e8d06708f9";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script></body></html>