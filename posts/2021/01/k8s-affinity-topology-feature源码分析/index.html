<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>K8S affinity topology feature源码分析 - 斌哥的小站|Binge Blog</title><meta name=Description content="基于K8S1.20的affinity topology feature源码分析"><meta property="og:title" content="K8S affinity topology feature源码分析"><meta property="og:description" content="基于K8S1.20的affinity topology feature源码分析"><meta property="og:type" content="article"><meta property="og:url" content="http://bingerambo.com/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><meta property="og:image" content="http://bingerambo.com/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/featured-image.jpg"><meta property="article:published_time" content="2021-01-05T08:43:17+08:00"><meta property="article:modified_time" content="2021-01-05T08:43:17+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://bingerambo.com/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/featured-image.jpg"><meta name=twitter:title content="K8S affinity topology feature源码分析"><meta name=twitter:description content="基于K8S1.20的affinity topology feature源码分析"><meta name=application-name content="Binge Blog"><meta name=apple-mobile-web-app-title content="Binge Blog"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=http://bingerambo.com/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/><link rel=prev href=http://bingerambo.com/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/><link rel=next href=http://bingerambo.com/posts/2021/01/python%E7%94%9F%E6%88%90requirements.txt%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/custom.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"K8S affinity topology feature源码分析","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/bingerambo.com\/posts\/2021\/01\/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\/"},"image":[{"@type":"ImageObject","url":"http:\/\/bingerambo.com\/posts\/2021\/01\/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\/featured-image.jpg","width":1170,"height":401}],"genre":"posts","keywords":"K8S","wordcount":11240,"url":"http:\/\/bingerambo.com\/posts\/2021\/01\/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\/","datePublished":"2021-01-05T08:43:17+08:00","dateModified":"2021-01-05T08:43:17+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xxxx","logo":"http:\/\/bingerambo.com\/images\/avatar.png"},"author":{"@type":"Person","name":"Binge"},"description":"基于K8S1.20的affinity topology feature源码分析"}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="斌哥的小站|Binge Blog"><span class=header-title-pre><i class="fas fa-biking fa-fw"></i></span>Binge Blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/><i class="fas fa-fw fa-archive"></i>文章 </a><a class=menu-item href=/tags/><i class="fas fa-fw fa-tag"></i>标签 </a><a class=menu-item href=/categories/><i class="fas fa-fw fa-th"></i>分类 </a><a class=menu-item href=/timeline/><i class="fas fa-cog fa-spin"></i>随记 </a><a class=menu-item href=/about/><i class="fas fa-fw fa-at"></i>关于 </a><a class=menu-item href=/search/><i class="fas fa-fw fa-search"></i>搜索 </a><a class=menu-item href=/friend/ title=Friend><i class="fas fa fa-user"></i>友链 </a><a class=menu-item href=https://github.com/bingerambo title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><a class=menu-item href=/><i class="fas fa fa-eye"></i><span id=busuanzi_value_site_uv></span></a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="斌哥的小站|Binge Blog"><span class=header-title-pre><i class="fas fa-biking fa-fw"></i></span>Binge Blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/><i class="fas fa-fw fa-archive"></i>文章</a><a class=menu-item href=/tags/><i class="fas fa-fw fa-tag"></i>标签</a><a class=menu-item href=/categories/><i class="fas fa-fw fa-th"></i>分类</a><a class=menu-item href=/timeline/><i class="fas fa-cog fa-spin"></i>随记</a><a class=menu-item href=/about/><i class="fas fa-fw fa-at"></i>关于</a><a class=menu-item href=/search/><i class="fas fa-fw fa-search"></i>搜索</a><a class=menu-item href=/friend/ title=Friend><i class="fas fa fa-user"></i>友链</a><a class=menu-item href=https://github.com/bingerambo title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><a class=menu-item href=/><i class="fas fa fa-eye"></i><span id=busuanzi_value_site_uv></span></a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">K8S affinity topology feature源码分析</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=http://bingerambo.com title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>Binge</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/k8s/><i class="far fa-folder fa-fw"></i>K8S</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-01-05>2021-01-05</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 11240 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 23 分钟&nbsp;
<i class="fa fa-eye fa-fw"></i>&nbsp;本文总阅读量 <span id=busuanzi_value_page_pv></span>次&nbsp;</div></div><div class=featured-image><img class=lazyload src=/svg/loading.min.svg data-src=/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/featured-image.jpg data-srcset="/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/featured-image.jpg, /posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/featured-image.jpg 1.5x, /posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/featured-image.jpg 2x" data-sizes=auto alt=/posts/2021/01/k8s-affinity-topology-feature%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/featured-image.jpg title="基于K8S1.20的affinity topology feature源码分析"></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#topology-manager设计方案>topology-manager设计方案</a></li><li><a href=#流程>流程</a><ul><li><a href=#资源管理组件创建和device-plugin注册流程>资源管理组件创建和device plugin注册流程</a></li><li><a href=#kubelet分配资源流程>kubelet分配资源流程</a></li><li><a href=#主流程代码>主流程代码</a></li></ul></li><li><a href=#topology-affinity>topology affinity</a></li><li><a href=#cpumanager>cpumanager</a></li><li><a href=#devicemanager>devicemanager</a></li><li><a href=#merge-hints>merge hints</a><ul><li><a href=#merge算法思想>merge算法思想</a></li><li><a href=#mergefilteredhints处理>mergeFilteredHints处理</a></li><li><a href=#mergepermutation处理>mergePermutation处理</a></li></ul></li><li><a href=#besthint>bestHint</a></li><li><a href=#算法函数>算法函数</a><ul><li><a href=#计算bitmasks-组合>计算BitMasks 组合</a></li><li><a href=#计算allprovidertopologyhints-排列>计算AllProviderTopologyHints 排列</a></li></ul></li><li><a href=#资源分配>资源分配</a><ul><li><a href=#allocatealignedresources>allocateAlignedResources</a></li><li><a href=#cpumanger>cpumanger</a></li><li><a href=#devicemanger>devicemanger</a></li></ul></li><li><a href=#接口>接口</a><ul><li><a href=#接口位置>接口位置</a></li></ul></li><li><a href=#nvidia-k8s-device-plugin>NVIDIA k8s-device-plugin</a><ul><li><a href=#gpu-device>gpu device</a></li><li><a href=#处理流程>处理流程</a></li><li><a href=#处理策略>处理策略</a><ul><li><a href=#simplepolicy>simplePolicy</a></li><li><a href=#besteffortpolicy>bestEffortPolicy</a></li><li><a href=#其它策略暂时未用>其它策略（暂时未用）</a></li></ul></li><li><a href=#gpu-拓扑>gpu 拓扑</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></div></div><div class=content id=content><p>topology manager是k8s1.16版本以后kubelet中新增的子模块，并在1.18版本更新为beta版特性，按节点资源NUMA亲和性和插件资源自身拓扑亲和性策略，对作业和任务进行资源分配。本文k8s源码分析为1.20版本。</p><h2 id=topology-manager设计方案>topology-manager设计方案</h2><p>kubelet numa拓扑亲和性资源分配方案：</p><p><a href=https://kubernetes.io/blog/2020/04/01/kubernetes-1-18-feature-topoloy-manager-beta/ target=_blank rel="noopener noreffer">Kubernetes Topology Manager Moves to Beta - Align Up!</a></p><p>设计方案中的资源拓扑分配例子如下：</p><img src=example-numa-system.png style=width:100%><blockquote><p>An example system with 2 NUMA nodes, 2 Sockets with 4 CPUs each, 2 GPUs, and 2 NICs. CPUs on Socket 0, GPU 0, and NIC 0 are all part of NUMA node 0. CPUs on Socket 1, GPU 1, and NIC 1 are all part of NUMA node 1.</p></blockquote><p>For example, consider the system in above, with the following two containers requesting resources from it:</p><table><thead><tr><th>Container Name</th><th>CPU</th><th>GPU</th><th>NIC</th></tr></thead><tbody><tr><td>Container0</td><td>2</td><td>1</td><td>1</td></tr><tr><td>Container1</td><td>2</td><td>1</td><td>1</td></tr></tbody></table><p>If Container0 is the first container considered for allocation on the system, the following set of hints will be generated for the three topology-aware resource types in the spec.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-markdown data-lang=markdown>               cpu: {{01: True}, {10: True}, {11: False}}
gpu-vendor.com/gpu: {{01: True}, {10: True}}
nic-vendor.com/nic: {{01: True}, {10: True}}
</code></pre></td></tr></table></div></div><p>With a resulting aligned allocation of:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-markdown data-lang=markdown>{cpu: {0, 1}, gpu: 0, nic: 0}
</code></pre></td></tr></table></div></div><img src=numa-hint-provider1.png style=width:100%><p>When considering Container1 these resources are then presumed to be unavailable, and thus only the following set of hints will be generated:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-markdown data-lang=markdown>               cpu: {{01: True}, {10: True}, {11: False}}
gpu-vendor.com/gpu: {{10: True}}
nic-vendor.com/nic: {{10: True}}
</code></pre></td></tr></table></div></div><p>With a resulting aligned allocation of:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-markdown data-lang=markdown>{cpu: {4, 5}, gpu: 1, nic: 1}
</code></pre></td></tr></table></div></div><img src=numa-hint-provider2.png style=width:100%><div class="details admonition note open"><div class="details-summary admonition-title"><i class="icon fas fa-pencil-alt fa-fw"></i>Supporting device-specific constraints<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content><p>Currently, <strong>NUMA affinity is the only constraint</strong> considered by the TopologyManager for <strong>resource alignment</strong>. Moreover, the <strong>only scalable extensions</strong> that can be made to a <strong>TopologyHint involve node-level constraints</strong>, such as PCIe bus alignment across device types. <strong>It would be intractable to try and add any device-specific constraints to this struct (e.g. the internal NVLINK topology among a set of GPU devices)</strong>.</p><p>As such, we propose an <strong>extension to the device plugin interface that will allow a plugin to state its topology-aware allocation preferences, without having to expose any device-specific topology information to the kubelet</strong>. In this way, the <strong>TopologyManager can be restricted to only deal with common node-level topology constraints</strong>, while still having a way of <strong>incorporating device-specific topology constraints</strong> into its allocation decisions.</p><p>Details of this proposal can be found <a href=https://github.com/kubernetes/enhancements/pull/1121 target=_blank rel="noopener noreffer">here</a>, and should be available as soon as Kubernetes 1.19.</p></div></div></div><p>说明：目前，NUMA affinity是kubelet的TopologyManager唯一的资源对齐的约束条件（对齐标准），而设备可扩展拓扑约束条件只有非节点级别的。</p><div class="details admonition tips open"><div class="details-summary admonition-title"><i class="icon fas fa-pencil-alt fa-fw"></i>Add proposal for GetPreferredAllocation() to TopologyManager KEP<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content><p>This proposal adds an API to allow a device plugin to forward a &ldquo;preferred allocation&rdquo; to the devicemanager so it can incorporate this information into its allocation decisions. It leaves the devicemanager in charge of making the final allocation, but gives the plugin the chance to help influence it more directly.</p><p>Using this new API call, the devicemanager will call out to a plugin <strong>at pod admission time, asking it for a preferred device allocation of a given size from a list of available devices. One call will be made per-container for each pod.</strong></p><p>The list of available devices passed to the GetPreferredAllocation() call do not necessarily match the full list of available devices on the system. Instead, <strong>the devicemanager treats the GetPreferredAllocation() call as a &ldquo;last-level&rdquo; filter on the set of devices it has to choose from after taking all TopologyHint information into consideration.</strong> As such, the list of available devices passed to this call will already be pre-filtered by the topology constraints encoded in the TopologyHint.</p><p>As such, the preferred allocation is not guaranteed to be the allocation ultimately performed by the devicemanager. It is only designed to help the devicemanager make a more informed allocation decision when possible.</p><p><strong>When deciding on a preferred allocation, a device plugin will likely take internal topology-constraints into consideration, that the devicemanager is unaware of. A good example of this is the case of allocating pairs of NVIDIA GPUs that always include an NVLINK.</strong></p><p>On an 8 GPU machine, with a request for 2 GPUs, the best connected pairs by NVLINK might be:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-markdown data-lang=markdown>{{0,3}, {1,2}, {4,7}, {5,6}}
</code></pre></td></tr></table></div></div><p><strong>Using GetPreferredAllocation() the NVIDIA device plugin is able to forward one of these preferred allocations to the device manager if the appropriate set of decvices are still available. Without this extra bit of information, the devicemanager would end up picking GPUs at random from the list of GPUs available after filerting by TopologyHint. This API, therefore allows it to ultimately perform a much better allocationt , with very minimal cost.</strong></p><p>If a plugin does not implement this new GetPreferredAllocation() method, then we should simply follow the strategy that exists today with no change (i.e. allocate devices directly from the available devices list).</p><p>However, if GetPreferredAllocation() is implemented, then the preferred allocation should be chosen over simply pulling devices at random from the available devices list.</p><p>There are 4 cases to consider:</p><ol><li>TopologyManager disabled, GetPreferredAllocation() not implemented</li><li>TopologyManager enabled, GetPreferredAllocation() not implemented</li><li>TopologyManager disabled, GetPreferredAllocation() implemented</li><li>TopologyManager enabled, GetPreferredAllocation() implemented</li></ol><p>With the TopologyManager disabled and GetPreferredAllocation() unimplemented, the existing strategy is to simply pull devices from the front of the available devices list &ndash; this should go unchanged.</p><p>With the TopologyManager enabled and GetPreferredAllocation() unimplemented, the existing strategy is to pull devices from the available devices list, such that they have the desired NUMA affinity &ndash; this should also go unchanged.</p><p>With the TopologyManager disabled and GetPreferredAllocation() implemented, the new strategy should be to prefer allocations from the list returned by GetPreferredAllocation() if possible, and fall back to pulling devices from the front of the available devices list if not.</p><p><strong>With the TopologyManager enabled and GetPreferredAllocation() implemented, the new strategy should be to prefer allocations from the list returned by GetPreferredAllocation() such that they have the desired NUMA affinity presented by the TopologyManager.</strong></p><p><strong>If that is not possible, fall back to pulling devices at random from the available devices list, such that they have the desired NUMA affinity. In this way, we will always follow a best-effort policy for honoring preferred allocations specified by this interface. We will NOT fail pod admission due to it.</strong></p></div></div></div><h2 id=流程>流程</h2><p>在分析源码前，先整理画出相关流程时序图。便于总体理解业务流程。如下</p><h3 id=资源管理组件创建和device-plugin注册流程>资源管理组件创建和device plugin注册流程</h3><p>这里以nvidia-k8s-deviceplugin为例，说明GPU设备注册流程</p><img src=dp-register.png><h3 id=kubelet分配资源流程>kubelet分配资源流程</h3><p>kubelet根据topology manager计算资源拓扑亲和性，并由cpu manager分配cpu资源；device manager分配插件资源</p><img src=dp-topo-allocate.png><h3 id=主流程代码>主流程代码</h3><p>kubelet/cm/topologymanager/scope_container.go</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>containerScope</span><span class=p>)</span> <span class=nf>Admit</span><span class=p>(</span><span class=nx>pod</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Pod</span><span class=p>)</span> <span class=nx>lifecycle</span><span class=p>.</span><span class=nx>PodAdmitResult</span> <span class=p>{</span>
    <span class=k>if</span> <span class=nx>s</span><span class=p>.</span><span class=nx>policy</span><span class=p>.</span><span class=nf>Name</span><span class=p>()</span> <span class=o>==</span> <span class=nx>PolicyNone</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>s</span><span class=p>.</span><span class=nf>admitPolicyNone</span><span class=p>(</span><span class=nx>pod</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>container</span> <span class=o>:=</span> <span class=k>range</span> <span class=nb>append</span><span class=p>(</span><span class=nx>pod</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>InitContainers</span><span class=p>,</span> <span class=nx>pod</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Containers</span><span class=o>...</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// bestHint, admit := s.calculateAffinity(pod, &amp;container)
</span><span class=c1></span>        <span class=nx>providersHints</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nf>accumulateProvidersHints</span><span class=p>(</span><span class=nx>pod</span><span class=p>,</span> <span class=nx>container</span><span class=p>)</span>
        <span class=nx>bestHint</span><span class=p>,</span> <span class=nx>admit</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>policy</span><span class=p>.</span><span class=nf>Merge</span><span class=p>(</span><span class=nx>providersHints</span><span class=p>)</span>

        <span class=k>if</span> <span class=p>!</span><span class=nx>admit</span> <span class=p>{</span>
            <span class=k>return</span> <span class=nf>topologyAffinityError</span><span class=p>()</span>
        <span class=p>}</span>

        <span class=k>if</span> <span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>podTopologyHints</span><span class=p>)[</span><span class=nb>string</span><span class=p>(</span><span class=nx>pod</span><span class=p>.</span><span class=nx>UID</span><span class=p>)]</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>podTopologyHints</span><span class=p>)[</span><span class=nb>string</span><span class=p>(</span><span class=nx>pod</span><span class=p>.</span><span class=nx>UID</span><span class=p>)]</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>TopologyHint</span><span class=p>)</span>
        <span class=p>}</span>

        <span class=nx>klog</span><span class=p>.</span><span class=nf>Infof</span><span class=p>(</span><span class=s>&#34;[topologymanager] Topology Affinity for (pod: %v container: %v): %v&#34;</span><span class=p>,</span> <span class=nx>format</span><span class=p>.</span><span class=nf>Pod</span><span class=p>(</span><span class=nx>pod</span><span class=p>),</span> <span class=nx>container</span><span class=p>.</span><span class=nx>Name</span><span class=p>,</span> <span class=nx>bestHint</span><span class=p>)</span>
        <span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>podTopologyHints</span><span class=p>)[</span><span class=nb>string</span><span class=p>(</span><span class=nx>pod</span><span class=p>.</span><span class=nx>UID</span><span class=p>)][</span><span class=nx>container</span><span class=p>.</span><span class=nx>Name</span><span class=p>]</span> <span class=p>=</span> <span class=nx>bestHint</span>
        <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nf>allocateAlignedResources</span><span class=p>(</span><span class=nx>pod</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>container</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=k>return</span> <span class=nf>unexpectedAdmissionError</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nf>admitPod</span><span class=p>()</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><ol><li>遍历pod中的所有容器</li><li>计算ProvidersHints，获取分配方案建议bestHint, 结果admit</li><li>按上面的对齐分配方案，为pod分配资源</li></ol><p>参考数据结构</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Scope interface for Topology Manager
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Scope</span> <span class=kd>interface</span> <span class=p>{</span>
    <span class=nf>Name</span><span class=p>()</span> <span class=kt>string</span>
    <span class=nf>Admit</span><span class=p>(</span><span class=nx>pod</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Pod</span><span class=p>)</span> <span class=nx>lifecycle</span><span class=p>.</span><span class=nx>PodAdmitResult</span>
    <span class=c1>// AddHintProvider adds a hint provider to manager to indicate the hint provider
</span><span class=c1></span>    <span class=c1>// wants to be consoluted with when making topology hints
</span><span class=c1></span>    <span class=nf>AddHintProvider</span><span class=p>(</span><span class=nx>h</span> <span class=nx>HintProvider</span><span class=p>)</span>
    <span class=c1>// AddContainer adds pod to Manager for tracking
</span><span class=c1></span>    <span class=nf>AddContainer</span><span class=p>(</span><span class=nx>pod</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Pod</span><span class=p>,</span> <span class=nx>containerID</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span>
    <span class=c1>// RemoveContainer removes pod from Manager tracking
</span><span class=c1></span>    <span class=nf>RemoveContainer</span><span class=p>(</span><span class=nx>containerID</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span>
    <span class=c1>// Store is the interface for storing pod topology hints
</span><span class=c1></span>    <span class=nx>Store</span>
<span class=p>}</span>

<span class=kd>type</span> <span class=nx>scope</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>mutex</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
    <span class=nx>name</span>  <span class=kt>string</span>
    <span class=c1>// Mapping of a Pods mapping of Containers and their TopologyHints
</span><span class=c1></span>    <span class=c1>// Indexed by PodUID to ContainerName
</span><span class=c1></span>    <span class=nx>podTopologyHints</span> <span class=nx>podTopologyHints</span>
    <span class=c1>// The list of components registered with the Manager
</span><span class=c1></span>    <span class=nx>hintProviders</span> <span class=p>[]</span><span class=nx>HintProvider</span>
    <span class=c1>// Topology Manager Policy
</span><span class=c1></span>    <span class=nx>policy</span> <span class=nx>Policy</span>
    <span class=c1>// Mapping of PodUID to ContainerID for Adding/Removing Pods from PodTopologyHints mapping
</span><span class=c1></span>    <span class=nx>podMap</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span>
<span class=p>}</span>
<span class=c1>// 格式: map[string(pod.UID)][container.Name]TopologyHint
</span><span class=c1></span><span class=kd>type</span> <span class=nx>podTopologyHints</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>TopologyHint</span>

<span class=c1>// TopologyHint is a struct containing the NUMANodeAffinity for a Container
</span><span class=c1></span><span class=kd>type</span> <span class=nx>TopologyHint</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>NUMANodeAffinity</span> <span class=nx>bitmask</span><span class=p>.</span><span class=nx>BitMask</span>
    <span class=c1>// Preferred is set to true when the NUMANodeAffinity encodes a preferred
</span><span class=c1></span>    <span class=c1>// allocation for the Container. It is set to false otherwise.
</span><span class=c1></span>    <span class=nx>Preferred</span> <span class=kt>bool</span>
<span class=p>}</span>

<span class=c1>// HintProvider is an interface for components that want to collaborate to
</span><span class=c1>// achieve globally optimal concrete resource alignment with respect to
</span><span class=c1>// NUMA locality.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>HintProvider</span> <span class=kd>interface</span> <span class=p>{</span>
    <span class=c1>// GetTopologyHints returns a map of resource names to a list of possible
</span><span class=c1></span>    <span class=c1>// concrete resource allocations in terms of NUMA locality hints. Each hint
</span><span class=c1></span>    <span class=c1>// is optionally marked &#34;preferred&#34; and indicates the set of NUMA nodes
</span><span class=c1></span>    <span class=c1>// involved in the hypothetical allocation. The topology manager calls
</span><span class=c1></span>    <span class=c1>// this function for each hint provider, and merges the hints to produce
</span><span class=c1></span>    <span class=c1>// a consensus &#34;best&#34; hint. The hint providers may subsequently query the
</span><span class=c1></span>    <span class=c1>// topology manager to influence actual resource assignment.
</span><span class=c1></span>    <span class=nf>GetTopologyHints</span><span class=p>(</span><span class=nx>pod</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Pod</span><span class=p>,</span> <span class=nx>container</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Container</span><span class=p>)</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][]</span><span class=nx>TopologyHint</span>
    <span class=c1>// GetPodTopologyHints returns a map of resource names to a list of possible
</span><span class=c1></span>    <span class=c1>// concrete resource allocations per Pod in terms of NUMA locality hints.
</span><span class=c1></span>    <span class=nf>GetPodTopologyHints</span><span class=p>(</span><span class=nx>pod</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Pod</span><span class=p>)</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][]</span><span class=nx>TopologyHint</span>
    <span class=c1>// Allocate triggers resource allocation to occur on the HintProvider after
</span><span class=c1></span>    <span class=c1>// all hints have been gathered and the aggregated Hint is available via a
</span><span class=c1></span>    <span class=c1>// call to Store.GetAffinity().
</span><span class=c1></span>    <span class=nf>Allocate</span><span class=p>(</span><span class=nx>pod</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Pod</span><span class=p>,</span> <span class=nx>container</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Container</span><span class=p>)</span> <span class=kt>error</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><h2 id=topology-affinity>topology affinity</h2><p>hintProviders实际上为参与进行资源分配的资源管理器，其扩展topo计算接口，目前使用的是cpumanger和devicemanager</p><ul><li>cpumanger用于管理分配cpu资源，比如按static策略分配cpuset</li><li>devicemanager用于管理分配k8s可扩展资源，比如k8s-nvidia-gpu插件管理的gpu资源</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>containerScope</span><span class=p>)</span> <span class=nf>accumulateProvidersHints</span><span class=p>(</span><span class=nx>pod</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Pod</span><span class=p>,</span> <span class=nx>container</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Container</span><span class=p>)</span> <span class=p>[]</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][]</span><span class=nx>TopologyHint</span> <span class=p>{</span>
    <span class=kd>var</span> <span class=nx>providersHints</span> <span class=p>[]</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][]</span><span class=nx>TopologyHint</span>

    <span class=c1>// hintProviders实际上为参与进行资源分配的资源管理器，其扩展topo计算接口，目前使用的是cpumanger和devicemanager
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>provider</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span><span class=p>.</span><span class=nx>hintProviders</span> <span class=p>{</span>
        <span class=c1>// Get the TopologyHints for a Container from a provider.
</span><span class=c1></span>        <span class=nx>hints</span> <span class=o>:=</span> <span class=nx>provider</span><span class=p>.</span><span class=nf>GetTopologyHints</span><span class=p>(</span><span class=nx>pod</span><span class=p>,</span> <span class=nx>container</span><span class=p>)</span>
        <span class=nx>providersHints</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>providersHints</span><span class=p>,</span> <span class=nx>hints</span><span class=p>)</span>
        <span class=nx>klog</span><span class=p>.</span><span class=nf>Infof</span><span class=p>(</span><span class=s>&#34;[topologymanager] TopologyHints for pod &#39;%v&#39;, container &#39;%v&#39;: %v&#34;</span><span class=p>,</span> <span class=nx>format</span><span class=p>.</span><span class=nf>Pod</span><span class=p>(</span><span class=nx>pod</span><span class=p>),</span> <span class=nx>container</span><span class=p>.</span><span class=nx>Name</span><span class=p>,</span> <span class=nx>hints</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>providersHints</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=cpumanager>cpumanager</h2><p>cpumanager ：GetTopologyHints -> m.policy.GetTopologyHints(m.state, pod, container)[staticPolicy.GetTopologyHints] -> generateCPUTopologyHints(available, reusable, requested)</p><ol><li>计算并返回cpu资源的TopologyHint列表信息</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>
<span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>staticPolicy</span><span class=p>)</span> <span class=nf>GetTopologyHints</span><span class=p>(){</span>

    <span class=c1>// Get a list of available CPUs.
</span><span class=c1></span>    <span class=nx>available</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nf>assignableCPUs</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>

    <span class=c1>// Get a list of reusable CPUs (e.g. CPUs reused from initContainers).
</span><span class=c1></span>    <span class=c1>// It should be an empty CPUSet for a newly created pod.
</span><span class=c1></span>    <span class=nx>reusable</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>cpusToReuse</span><span class=p>[</span><span class=nb>string</span><span class=p>(</span><span class=nx>pod</span><span class=p>.</span><span class=nx>UID</span><span class=p>)]</span>

    <span class=c1>// Generate hints.
</span><span class=c1></span>    <span class=nx>cpuHints</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nf>generateCPUTopologyHints</span><span class=p>(</span><span class=nx>available</span><span class=p>,</span> <span class=nx>reusable</span><span class=p>,</span> <span class=nx>requested</span><span class=p>)</span>
    <span class=c1>// 返回cpu资源的TopologyHint列表信息
</span><span class=c1></span>    <span class=k>return</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][]</span><span class=nx>topologymanager</span><span class=p>.</span><span class=nx>TopologyHint</span><span class=p>{</span>
        <span class=c1>// &#34;cpu&#34; : [{01 true} {10 true} {11 false}]
</span><span class=c1></span>        <span class=nb>string</span><span class=p>(</span><span class=nx>v1</span><span class=p>.</span><span class=nx>ResourceCPU</span><span class=p>):</span> <span class=nx>cpuHints</span><span class=p>,</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><ol start=2><li>计算cpu Hints generateCPUTopologyHints</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>staticPolicy</span><span class=p>)</span> <span class=nf>generateCPUTopologyHints</span><span class=p>(</span><span class=nx>availableCPUs</span> <span class=nx>cpuset</span><span class=p>.</span><span class=nx>CPUSet</span><span class=p>,</span> <span class=nx>reusableCPUs</span> <span class=nx>cpuset</span><span class=p>.</span><span class=nx>CPUSet</span><span class=p>,</span> <span class=nx>request</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=nx>topologymanager</span><span class=p>.</span><span class=nx>TopologyHint</span> <span class=p>{</span>

    <span class=c1>// Initialize minAffinitySize to include all NUMA Nodes.
</span><span class=c1></span>    <span class=nx>minAffinitySize</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>topology</span><span class=p>.</span><span class=nx>CPUDetails</span><span class=p>.</span><span class=nf>NUMANodes</span><span class=p>().</span><span class=nf>Size</span><span class=p>()</span>
    <span class=c1>// 执行了具体计算topo hint的算法
</span><span class=c1></span>    <span class=nx>bitmask</span><span class=p>.</span><span class=nf>IterateBitMasks</span><span class=p>(</span><span class=nx>topology</span><span class=p>.</span><span class=nx>CPUDetails</span><span class=p>.</span><span class=nf>NUMANodes</span><span class=p>().</span><span class=nf>ToSlice</span><span class=p>(),</span> <span class=nx>call_back_func</span><span class=p>{})</span>

<span class=c1>// If they don&#39;t, then move onto the next combination.
</span><span class=c1></span>        <span class=k>if</span> <span class=nx>numMatching</span> <span class=p>&lt;</span> <span class=nx>request</span> <span class=p>{</span>
            <span class=k>return</span>
        <span class=p>}</span>

    <span class=c1>// Loop back through all hints and update the &#39;Preferred&#39; field based on
</span><span class=c1></span>    <span class=c1>// counting the number of bits sets in the affinity mask and comparing it
</span><span class=c1></span>    <span class=c1>// to the minAffinitySize. Only those with an equal number of bits set (and
</span><span class=c1></span>    <span class=c1>// with a minimal set of numa nodes) will be considered preferred.
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>hints</span> <span class=p>{</span>
        <span class=c1>// 选择bitmap最窄的NUMANode，Preferred = true
</span><span class=c1></span>        <span class=k>if</span> <span class=nx>hints</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>NUMANodeAffinity</span><span class=p>.</span><span class=nf>Count</span><span class=p>()</span> <span class=o>==</span> <span class=nx>minAffinitySize</span> <span class=p>{</span>
            <span class=nx>hints</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>Preferred</span> <span class=p>=</span> <span class=kc>true</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=c1>// 返回hints结果集，形式如：[{01 true} {10 true} {11 false}]
</span><span class=c1></span>    <span class=c1>// Preferred 优选字段标识 该hint是否为优先考虑方案
</span><span class=c1></span>    <span class=k>return</span> <span class=nx>hints</span>

<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=devicemanager>devicemanager</h2><ol><li>GetTopologyHints</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// GetTopologyHints implements the TopologyManager HintProvider Interface which
</span><span class=c1>// ensures the Device Manager is consulted when Topology Aware Hints for each
</span><span class=c1>// container are created.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>ManagerImpl</span><span class=p>)</span> <span class=nf>GetTopologyHints</span><span class=p>(</span><span class=nx>pod</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Pod</span><span class=p>,</span> <span class=nx>container</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Container</span><span class=p>)</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][]</span><span class=nx>topologymanager</span><span class=p>.</span><span class=nx>TopologyHint</span> <span class=p>{</span>
    <span class=c1>// Garbage collect any stranded device resources before providing TopologyHints
</span><span class=c1></span>    <span class=nx>m</span><span class=p>.</span><span class=nf>UpdateAllocatedDevices</span><span class=p>()</span>

    <span class=c1>// Loop through all device resources and generate TopologyHints for them..
</span><span class=c1></span>    <span class=nx>deviceHints</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][]</span><span class=nx>topologymanager</span><span class=p>.</span><span class=nx>TopologyHint</span><span class=p>)</span>
    <span class=k>for</span> <span class=nx>resourceObj</span><span class=p>,</span> <span class=nx>requestedObj</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>container</span><span class=p>.</span><span class=nx>Resources</span><span class=p>.</span><span class=nx>Limits</span> <span class=p>{</span>
        <span class=nx>resource</span> <span class=o>:=</span> <span class=nb>string</span><span class=p>(</span><span class=nx>resourceObj</span><span class=p>)</span>
        <span class=nx>requested</span> <span class=o>:=</span> <span class=nb>int</span><span class=p>(</span><span class=nx>requestedObj</span><span class=p>.</span><span class=nf>Value</span><span class=p>())</span>

        <span class=c1>// Only consider resources associated with a device plugin.
</span><span class=c1></span>        <span class=c1>// 只考虑device plugin的扩展资源
</span><span class=c1></span>        <span class=k>if</span> <span class=nx>m</span><span class=p>.</span><span class=nf>isDevicePluginResource</span><span class=p>(</span><span class=nx>resource</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// Only consider devices that actually container topology information.
</span><span class=c1></span>            <span class=c1>// 只考虑有拓扑信息的资源，比如按numa对齐的gpus
</span><span class=c1></span>            <span class=k>if</span> <span class=nx>aligned</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nf>deviceHasTopologyAlignment</span><span class=p>(</span><span class=nx>resource</span><span class=p>)!</span><span class=nx>aligned</span> <span class=p>{</span>
                <span class=nx>klog</span><span class=p>.</span><span class=nf>Infof</span><span class=p>(</span><span class=s>&#34;[devicemanager] Resource &#39;%v&#39; does not have a topology preference&#34;</span><span class=p>,</span> <span class=nx>resource</span><span class=p>)</span>
                <span class=nx>deviceHints</span><span class=p>[</span><span class=nx>resource</span><span class=p>]</span> <span class=p>=</span> <span class=kc>nil</span>
                <span class=k>continue</span>
            <span class=p>}</span>

            <span class=c1>// Get the list of available devices, for which TopologyHints should be generated.
</span><span class=c1></span>            <span class=nx>available</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nf>getAvailableDevices</span><span class=p>(</span><span class=nx>resource</span><span class=p>)</span>
            <span class=nx>reusable</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>devicesToReuse</span><span class=p>[</span><span class=nb>string</span><span class=p>(</span><span class=nx>pod</span><span class=p>.</span><span class=nx>UID</span><span class=p>)][</span><span class=nx>resource</span><span class=p>]</span>

            <span class=c1>// Generate TopologyHints for this resource given the current
</span><span class=c1></span>            <span class=c1>// request size and the list of available devices.
</span><span class=c1></span>            <span class=nx>deviceHints</span><span class=p>[</span><span class=nx>resource</span><span class=p>]</span> <span class=p>=</span> <span class=nx>m</span><span class=p>.</span><span class=nf>generateDeviceTopologyHints</span><span class=p>(</span><span class=nx>resource</span><span class=p>,</span> <span class=nx>available</span><span class=p>,</span> <span class=nx>reusable</span><span class=p>,</span> <span class=nx>requested</span><span class=p>)</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=nx>deviceHints</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><ol start=2><li>计算device Hints generateDeviceTopologyHints</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>
<span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>ManagerImpl</span><span class=p>)</span> <span class=nf>generateDeviceTopologyHints</span><span class=p>(</span><span class=nx>resource</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>available</span> <span class=nx>sets</span><span class=p>.</span><span class=nx>String</span><span class=p>,</span> <span class=nx>reusable</span> <span class=nx>sets</span><span class=p>.</span><span class=nx>String</span><span class=p>,</span> <span class=nx>request</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=nx>topologymanager</span><span class=p>.</span><span class=nx>TopologyHint</span> <span class=p>{</span>
    <span class=c1>// Initialize minAffinitySize to include all NUMA Nodes
</span><span class=c1></span>    <span class=nx>minAffinitySize</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>numaNodes</span><span class=p>)</span>

    <span class=c1>// Iterate through all combinations of NUMA Nodes and build hints from them.
</span><span class=c1></span>    <span class=nx>hints</span> <span class=o>:=</span> <span class=p>[]</span><span class=nx>topologymanager</span><span class=p>.</span><span class=nx>TopologyHint</span><span class=p>{}</span>
    <span class=nx>bitmask</span><span class=p>.</span><span class=nf>IterateBitMasks</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>numaNodes</span><span class=p>,</span> <span class=nx>call_back_func</span><span class=p>{})</span>

    <span class=c1>// Loop back through all hints and update the &#39;Preferred&#39; field based on
</span><span class=c1></span>    <span class=c1>// counting the number of bits sets in the affinity mask and comparing it
</span><span class=c1></span>    <span class=c1>// to the minAffinity. Only those with an equal number of bits set will be
</span><span class=c1></span>    <span class=c1>// considered preferred.
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>hints</span> <span class=p>{</span>
        <span class=k>if</span> <span class=nx>hints</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>NUMANodeAffinity</span><span class=p>.</span><span class=nf>Count</span><span class=p>()</span> <span class=o>==</span> <span class=nx>minAffinitySize</span> <span class=p>{</span>
            <span class=nx>hints</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>Preferred</span> <span class=p>=</span> <span class=kc>true</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=nx>hints</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><h2 id=merge-hints>merge hints</h2><h3 id=merge算法思想>merge算法思想</h3><p><strong>merge思想，是把多种类型资源的topo hints（即下面中的每一行），合并为一个hint，合并算法为位与运算。</strong></p><img src=merged-hints.png><p>不同的topo policy实现，区别就在merge处理中，如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>
<span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>nonePolicy</span><span class=p>)</span> <span class=nf>Merge</span><span class=p>(</span><span class=nx>providersHints</span> <span class=p>[]</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][]</span><span class=nx>TopologyHint</span><span class=p>)</span> <span class=p>(</span><span class=nx>TopologyHint</span><span class=p>,</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>TopologyHint</span><span class=p>{},</span> <span class=nx>p</span><span class=p>.</span><span class=nf>canAdmitPodResult</span><span class=p>(</span><span class=kc>nil</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>bestEffortPolicy</span><span class=p>)</span> <span class=nf>Merge</span><span class=p>(</span><span class=nx>providersHints</span> <span class=p>[]</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][]</span><span class=nx>TopologyHint</span><span class=p>)</span> <span class=p>(</span><span class=nx>TopologyHint</span><span class=p>,</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 1. 遍历全部hint providers，收集全部的hint，到filteredProvidersHints列表中。
</span><span class=c1></span>    <span class=c1>// 本质上，是把map数据，转换成二维列表[][]TopologyHint，目的便于后面的mergeFilteredHints处理
</span><span class=c1></span>    <span class=nx>filteredProvidersHints</span> <span class=o>:=</span> <span class=nf>filterProvidersHints</span><span class=p>(</span><span class=nx>providersHints</span><span class=p>)</span>
    <span class=nx>bestHint</span> <span class=o>:=</span> <span class=nf>mergeFilteredHints</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>numaNodes</span><span class=p>,</span> <span class=nx>filteredProvidersHints</span><span class=p>)</span>
    <span class=nx>admit</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nf>canAdmitPodResult</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>bestHint</span><span class=p>)</span>
    <span class=k>return</span> <span class=nx>bestHint</span><span class=p>,</span> <span class=nx>admit</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>restrictedPolicy</span><span class=p>)</span> <span class=nf>Merge</span><span class=p>(</span><span class=nx>providersHints</span> <span class=p>[]</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][]</span><span class=nx>TopologyHint</span><span class=p>)</span> <span class=p>(</span><span class=nx>TopologyHint</span><span class=p>,</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>filteredHints</span> <span class=o>:=</span> <span class=nf>filterProvidersHints</span><span class=p>(</span><span class=nx>providersHints</span><span class=p>)</span>
    <span class=nx>hint</span> <span class=o>:=</span> <span class=nf>mergeFilteredHints</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>numaNodes</span><span class=p>,</span> <span class=nx>filteredHints</span><span class=p>)</span>
    <span class=nx>admit</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nf>canAdmitPodResult</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>hint</span><span class=p>)</span>
    <span class=k>return</span> <span class=nx>hint</span><span class=p>,</span> <span class=nx>admit</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>singleNumaNodePolicy</span><span class=p>)</span> <span class=nf>Merge</span><span class=p>(</span><span class=nx>providersHints</span> <span class=p>[]</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][]</span><span class=nx>TopologyHint</span><span class=p>)</span> <span class=p>(</span><span class=nx>TopologyHint</span><span class=p>,</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>filteredHints</span> <span class=o>:=</span> <span class=nf>filterProvidersHints</span><span class=p>(</span><span class=nx>providersHints</span><span class=p>)</span>
    <span class=c1>// Filter to only include don&#39;t cares and hints with a single NUMA node.
</span><span class=c1></span>    <span class=nx>singleNumaHints</span> <span class=o>:=</span> <span class=nf>filterSingleNumaHints</span><span class=p>(</span><span class=nx>filteredHints</span><span class=p>)</span>
    <span class=nx>bestHint</span> <span class=o>:=</span> <span class=nf>mergeFilteredHints</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>numaNodes</span><span class=p>,</span> <span class=nx>singleNumaHints</span><span class=p>)</span>

    <span class=nx>defaultAffinity</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>bitmask</span><span class=p>.</span><span class=nf>NewBitMask</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>numaNodes</span><span class=o>...</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>bestHint</span><span class=p>.</span><span class=nx>NUMANodeAffinity</span><span class=p>.</span><span class=nf>IsEqual</span><span class=p>(</span><span class=nx>defaultAffinity</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>bestHint</span> <span class=p>=</span> <span class=nx>TopologyHint</span><span class=p>{</span><span class=kc>nil</span><span class=p>,</span> <span class=nx>bestHint</span><span class=p>.</span><span class=nx>Preferred</span><span class=p>}</span>
    <span class=p>}</span>

    <span class=nx>admit</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nf>canAdmitPodResult</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>bestHint</span><span class=p>)</span>
    <span class=k>return</span> <span class=nx>bestHint</span><span class=p>,</span> <span class=nx>admit</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><h3 id=mergefilteredhints处理>mergeFilteredHints处理</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>mergeFilteredHints</span><span class=p>(</span><span class=nx>numaNodes</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>filteredHints</span> <span class=p>[][]</span><span class=nx>TopologyHint</span><span class=p>)</span> <span class=nx>TopologyHint</span> <span class=p>{</span>
    <span class=c1>// Set the default affinity as an any-numa affinity containing the list
</span><span class=c1></span>    <span class=c1>// of NUMA Nodes available on this machine.
</span><span class=c1></span>    <span class=nx>defaultAffinity</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>bitmask</span><span class=p>.</span><span class=nf>NewBitMask</span><span class=p>(</span><span class=nx>numaNodes</span><span class=o>...</span><span class=p>)</span>

    <span class=c1>// Set the bestHint to return from this function as {nil false}.
</span><span class=c1></span>    <span class=c1>// This will only be returned if no better hint can be found when
</span><span class=c1></span>    <span class=c1>// merging hints from each hint provider.
</span><span class=c1></span>    <span class=nx>bestHint</span> <span class=o>:=</span> <span class=nx>TopologyHint</span><span class=p>{</span><span class=nx>defaultAffinity</span><span class=p>,</span> <span class=kc>false</span><span class=p>}</span>
    <span class=c1>// 计算merge结果
</span><span class=c1></span>    <span class=nf>iterateAllProviderTopologyHints</span><span class=p>(</span><span class=nx>filteredHints</span><span class=p>,</span> <span class=nx>call_back_func</span><span class=p>{})</span>

    <span class=k>return</span> <span class=nx>bestHint</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><h3 id=mergepermutation处理>mergePermutation处理</h3><ul><li>应用了向量叉积(Cross Product)，但只是组合排列，并未求和</li><li>permutation为iterateAllProviderTopologyHints中罗列出的各种资源类型的hints的全部排列</li><li>位与运算bitmask.And，计算besthint值mergedAffinity</li><li>hint.Preferred 逻辑与关系，全部为true，则为true。否则为false</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>
<span class=c1>// Merge a TopologyHints permutation to a single hint by performing a bitwise-AND
</span><span class=c1>// of their affinity masks. The hint shall be preferred if all hits in the permutation
</span><span class=c1>// are preferred.
</span><span class=c1></span><span class=kd>func</span> <span class=nf>mergePermutation</span><span class=p>(</span><span class=nx>numaNodes</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>permutation</span> <span class=p>[]</span><span class=nx>TopologyHint</span><span class=p>)</span> <span class=nx>TopologyHint</span> <span class=p>{</span>
    <span class=c1>// Get the NUMANodeAffinity from each hint in the permutation and see if any
</span><span class=c1></span>    <span class=c1>// of them encode unpreferred allocations.
</span><span class=c1></span>    <span class=nx>preferred</span> <span class=o>:=</span> <span class=kc>true</span>
    <span class=nx>defaultAffinity</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>bitmask</span><span class=p>.</span><span class=nf>NewBitMask</span><span class=p>(</span><span class=nx>numaNodes</span><span class=o>...</span><span class=p>)</span>
    <span class=kd>var</span> <span class=nx>numaAffinities</span> <span class=p>[]</span><span class=nx>bitmask</span><span class=p>.</span><span class=nx>BitMask</span>
    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>hint</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>permutation</span> <span class=p>{</span>
        <span class=c1>// Only consider hints that have an actual NUMANodeAffinity set.
</span><span class=c1></span>        <span class=k>if</span> <span class=nx>hint</span><span class=p>.</span><span class=nx>NUMANodeAffinity</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nx>numaAffinities</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>numaAffinities</span><span class=p>,</span> <span class=nx>defaultAffinity</span><span class=p>)</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=nx>numaAffinities</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>numaAffinities</span><span class=p>,</span> <span class=nx>hint</span><span class=p>.</span><span class=nx>NUMANodeAffinity</span><span class=p>)</span>
        <span class=p>}</span>

        <span class=k>if</span> <span class=p>!</span><span class=nx>hint</span><span class=p>.</span><span class=nx>Preferred</span> <span class=p>{</span>
            <span class=nx>preferred</span> <span class=p>=</span> <span class=kc>false</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=c1>// Merge the affinities using a bitwise-and operation.
</span><span class=c1></span>    <span class=nx>mergedAffinity</span> <span class=o>:=</span> <span class=nx>bitmask</span><span class=p>.</span><span class=nf>And</span><span class=p>(</span><span class=nx>defaultAffinity</span><span class=p>,</span> <span class=nx>numaAffinities</span><span class=o>...</span><span class=p>)</span>
    <span class=c1>// Build a mergedHint from the merged affinity mask, indicating if an
</span><span class=c1></span>    <span class=c1>// preferred allocation was used to generate the affinity mask or not.
</span><span class=c1></span>    <span class=k>return</span> <span class=nx>TopologyHint</span><span class=p>{</span><span class=nx>mergedAffinity</span><span class=p>,</span> <span class=nx>preferred</span><span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=besthint>bestHint</h2><p>kubelet会再次遍历merged hint，得出bestHint，最终按bestHint进行资源分配。</p><p>bestHint算法思想：</p><ul><li>优选preference为true的merge hint，即mergedHint.Preferred: true</li><li>在相同preference条件下，优选长度最窄的NUMANodeAffinity（bitmap类型）</li></ul><p>计算好bestHint后，并保存，为后面流程使用</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>podTopologyHints</span><span class=p>)[</span><span class=nb>string</span><span class=p>(</span><span class=nx>pod</span><span class=p>.</span><span class=nx>UID</span><span class=p>)][</span><span class=nx>container</span><span class=p>.</span><span class=nx>Name</span><span class=p>]</span> <span class=p>=</span> <span class=nx>bestHint</span>
</code></pre></td></tr></table></div></div><p>小结：</p><p><strong>hints的合并流程：resource topo hints -> merged hints -> bestHint</strong></p><h2 id=算法函数>算法函数</h2><h3 id=计算bitmasks-组合>计算BitMasks 组合</h3><p>资源单元的分配是一种寻找组合的算法</p><p>bits列表即为NUMANodes返回与资源(如cpu)相关联的所有NUMANode id列表</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>
<span class=c1>// IterateBitMasks iterates all possible masks from a list of bits,
</span><span class=c1>// issuing a callback on each mask.
</span><span class=c1></span><span class=kd>func</span> <span class=nf>IterateBitMasks</span><span class=p>(</span><span class=nx>bits</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>callback</span> <span class=kd>func</span><span class=p>(</span><span class=nx>BitMask</span><span class=p>))</span> <span class=p>{</span>
    <span class=kd>var</span> <span class=nx>iterate</span> <span class=kd>func</span><span class=p>(</span><span class=nx>bits</span><span class=p>,</span> <span class=nx>accum</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>size</span> <span class=kt>int</span><span class=p>)</span>
    <span class=nx>iterate</span> <span class=p>=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>bits</span><span class=p>,</span> <span class=nx>accum</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>size</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>accum</span><span class=p>)</span> <span class=o>==</span> <span class=nx>size</span> <span class=p>{</span>
            <span class=c1>// 构建size个numa组的bits按位或得到的mask，比如size=2时，输出numa组id组合：{01,10,11}
</span><span class=c1></span>            <span class=nx>mask</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nf>NewBitMask</span><span class=p>(</span><span class=nx>accum</span><span class=o>...</span><span class=p>)</span>
            <span class=c1>// callback 会对获得的各种长度的numa node mask进程处理
</span><span class=c1></span>            <span class=nf>callback</span><span class=p>(</span><span class=nx>mask</span><span class=p>)</span>
            <span class=k>return</span>
        <span class=p>}</span>
        <span class=c1>// 组合，遍历可选numa的bits列表
</span><span class=c1></span>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>bits</span> <span class=p>{</span>
            <span class=nf>iterate</span><span class=p>(</span><span class=nx>bits</span><span class=p>[</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>:],</span> <span class=nb>append</span><span class=p>(</span><span class=nx>accum</span><span class=p>,</span> <span class=nx>bits</span><span class=p>[</span><span class=nx>i</span><span class=p>]),</span> <span class=nx>size</span><span class=p>)</span>
        <span class=p>}</span>
    <span class=p>}</span>
   
    <span class=c1>// bits列表即为NUMANodes返回与资源(如cpu)相关联的所有NUMANode id列表，如：[0,1]或者[0,1,2...7]或者 [0,1,2,3....63]
</span><span class=c1></span>    <span class=c1>// 并枚举1到全部numa node长度的numa node id 组合
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>bits</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
        <span class=nf>iterate</span><span class=p>(</span><span class=nx>bits</span><span class=p>,</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{},</span> <span class=nx>i</span><span class=p>)</span>
    <span class=p>}</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><ul><li><p>IterateBitMasks是计算topo hint的关键函数，在cpumangager和devicemanager中都有使用</p></li><li><p>IterateBitMasks本质上是计算出了资源列表（bits选择列表）的全部组合（size大小），如：cpuset的各种组合；devices中gpus的各种组合</p></li><li><p>DFS算法</p></li></ul><h3 id=计算allprovidertopologyhints-排列>计算AllProviderTopologyHints 排列</h3><p>不同资源类型的hits合并，是全排列算法</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Iterate over all permutations of hints in &#39;allProviderHints [][]TopologyHint&#39;.
</span><span class=c1>//
</span><span class=c1>// This procedure is implemented as a recursive function over the set of hints
</span><span class=c1>// in &#39;allproviderHints[i]&#39;. It applies the function &#39;callback&#39; to each
</span><span class=c1>// permutation as it is found. It is the equivalent of:
</span><span class=c1>//
</span><span class=c1>// for i := 0; i &lt; len(providerHints[0]); i++
</span><span class=c1>//     for j := 0; j &lt; len(providerHints[1]); j++
</span><span class=c1>//         for k := 0; k &lt; len(providerHints[2]); k++
</span><span class=c1>//             ...
</span><span class=c1>//             for z := 0; z &lt; len(providerHints[-1]); z++
</span><span class=c1>//                 permutation := []TopologyHint{
</span><span class=c1>//                     providerHints[0][i],
</span><span class=c1>//                     providerHints[1][j],
</span><span class=c1>//                     providerHints[2][k],
</span><span class=c1>//                     ...
</span><span class=c1>//                     providerHints[-1][z]
</span><span class=c1>//                 }
</span><span class=c1>//                 callback(permutation)
</span><span class=c1></span><span class=kd>func</span> <span class=nf>iterateAllProviderTopologyHints</span><span class=p>(</span><span class=nx>allProviderHints</span> <span class=p>[][]</span><span class=nx>TopologyHint</span><span class=p>,</span> <span class=nx>callback</span> <span class=kd>func</span><span class=p>([]</span><span class=nx>TopologyHint</span><span class=p>))</span> <span class=p>{</span>
    <span class=c1>// Internal helper function to accumulate the permutation before calling the callback.
</span><span class=c1></span>    <span class=kd>var</span> <span class=nx>iterate</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>accum</span> <span class=p>[]</span><span class=nx>TopologyHint</span><span class=p>)</span>
    <span class=nx>iterate</span> <span class=p>=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>accum</span> <span class=p>[]</span><span class=nx>TopologyHint</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// Base case: we have looped through all providers and have a full permutation.
</span><span class=c1></span>        <span class=k>if</span> <span class=nx>i</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=nx>allProviderHints</span><span class=p>)</span> <span class=p>{</span>
            <span class=nf>callback</span><span class=p>(</span><span class=nx>accum</span><span class=p>)</span>
            <span class=k>return</span>
        <span class=p>}</span>

        <span class=c1>// Loop through all hints for provider &#39;i&#39;, and recurse to build the
</span><span class=c1></span>        <span class=c1>// the permutation of this hint with all hints from providers &#39;i++&#39;.
</span><span class=c1></span>        <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>allProviderHints</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>{</span>
            <span class=nf>iterate</span><span class=p>(</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nb>append</span><span class=p>(</span><span class=nx>accum</span><span class=p>,</span> <span class=nx>allProviderHints</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]))</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=nf>iterate</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=p>[]</span><span class=nx>TopologyHint</span><span class=p>{})</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=资源分配>资源分配</h2><h3 id=allocatealignedresources>allocateAlignedResources</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// It would be better to implement this function in topologymanager instead of scope
</span><span class=c1>// but topologymanager do not track providers anymore
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>scope</span><span class=p>)</span> <span class=nf>allocateAlignedResources</span><span class=p>(</span><span class=nx>pod</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Pod</span><span class=p>,</span> <span class=nx>container</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Container</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>provider</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span><span class=p>.</span><span class=nx>hintProviders</span> <span class=p>{</span>
        <span class=nx>err</span> <span class=o>:=</span> <span class=nx>provider</span><span class=p>.</span><span class=nf>Allocate</span><span class=p>(</span><span class=nx>pod</span><span class=p>,</span> <span class=nx>container</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=k>return</span> <span class=nx>err</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h3 id=cpumanger>cpumanger</h3><p>根据前面计算出的topo hint 进行cpu分配</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>
<span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>staticPolicy</span><span class=p>)</span> <span class=nf>Allocate</span><span class=p>(</span><span class=nx>s</span> <span class=nx>state</span><span class=p>.</span><span class=nx>State</span><span class=p>,</span> <span class=nx>pod</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Pod</span><span class=p>,</span> <span class=nx>container</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Container</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=k>if</span> <span class=nx>numCPUs</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nf>guaranteedCPUs</span><span class=p>(</span><span class=nx>pod</span><span class=p>,</span> <span class=nx>container</span><span class=p>);</span> <span class=nx>numCPUs</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
        

        <span class=c1>// Call Topology Manager to get the aligned socket affinity across all hint providers.
</span><span class=c1></span>        <span class=nx>hint</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>affinity</span><span class=p>.</span><span class=nf>GetAffinity</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>pod</span><span class=p>.</span><span class=nx>UID</span><span class=p>),</span> <span class=nx>container</span><span class=p>.</span><span class=nx>Name</span><span class=p>)</span>
        
        <span class=c1>// Allocate CPUs according to the NUMA affinity contained in the hint.
</span><span class=c1></span>        <span class=nx>cpuset</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>p</span><span class=p>.</span><span class=nf>allocateCPUs</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=nx>numCPUs</span><span class=p>,</span> <span class=nx>hint</span><span class=p>.</span><span class=nx>NUMANodeAffinity</span><span class=p>,</span> <span class=nx>p</span><span class=p>.</span><span class=nx>cpusToReuse</span><span class=p>[</span><span class=nb>string</span><span class=p>(</span><span class=nx>pod</span><span class=p>.</span><span class=nx>UID</span><span class=p>)])</span>

        <span class=nx>s</span><span class=p>.</span><span class=nf>SetCPUSet</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>pod</span><span class=p>.</span><span class=nx>UID</span><span class=p>),</span> <span class=nx>container</span><span class=p>.</span><span class=nx>Name</span><span class=p>,</span> <span class=nx>cpuset</span><span class=p>)</span>
        <span class=nx>p</span><span class=p>.</span><span class=nf>updateCPUsToReuse</span><span class=p>(</span><span class=nx>pod</span><span class=p>,</span> <span class=nx>container</span><span class=p>,</span> <span class=nx>cpuset</span><span class=p>)</span>

    <span class=p>}</span>
    <span class=c1>// container belongs in the shared pool (nothing to do; use default cpuset)
</span><span class=c1></span>    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><h3 id=devicemanger>devicemanger</h3><p>devicemanger的资源分配逻辑处理逻辑较多。首先看下调用链，如下：</p><p>Allocate -> allocateContainerResources -> devicesToAllocate</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span><span class=lnt>87
</span><span class=lnt>88
</span><span class=lnt>89
</span><span class=lnt>90
</span><span class=lnt>91
</span><span class=lnt>92
</span><span class=lnt>93
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Returns list of device Ids we need to allocate with Allocate rpc call.
</span><span class=c1>// Returns empty list in case we don&#39;t need to issue the Allocate rpc call.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>ManagerImpl</span><span class=p>)</span> <span class=nf>devicesToAllocate</span><span class=p>(</span><span class=nx>podUID</span><span class=p>,</span> <span class=nx>contName</span><span class=p>,</span> <span class=nx>resource</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>required</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>reusableDevices</span> <span class=nx>sets</span><span class=p>.</span><span class=nx>String</span><span class=p>)</span> <span class=p>(</span><span class=nx>sets</span><span class=p>.</span><span class=nx>String</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
    

    <span class=c1>// Declare the list of allocated devices.
</span><span class=c1></span>    <span class=c1>// This will be populated and returned below.
</span><span class=c1></span>    <span class=nx>allocated</span> <span class=o>:=</span> <span class=nx>sets</span><span class=p>.</span><span class=nf>NewString</span><span class=p>()</span>

    <span class=c1>// Create a closure to help with device allocation
</span><span class=c1></span>    <span class=c1>// Returns &#39;true&#39; once no more devices need to be allocated.
</span><span class=c1></span>    <span class=nx>allocateRemainingFrom</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>devices</span> <span class=nx>sets</span><span class=p>.</span><span class=nx>String</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
        <span class=k>for</span> <span class=nx>device</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>devices</span><span class=p>.</span><span class=nf>Difference</span><span class=p>(</span><span class=nx>allocated</span><span class=p>)</span> <span class=p>{</span>
            <span class=nx>m</span><span class=p>.</span><span class=nx>allocatedDevices</span><span class=p>[</span><span class=nx>resource</span><span class=p>].</span><span class=nf>Insert</span><span class=p>(</span><span class=nx>device</span><span class=p>)</span>
            <span class=nx>allocated</span><span class=p>.</span><span class=nf>Insert</span><span class=p>(</span><span class=nx>device</span><span class=p>)</span>
            <span class=nx>needed</span><span class=o>--</span>
            <span class=k>if</span> <span class=nx>needed</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
                <span class=k>return</span> <span class=kc>true</span>
            <span class=p>}</span>
        <span class=p>}</span>
        <span class=k>return</span> <span class=kc>false</span>
    <span class=p>}</span>

    <span class=c1>// Allocates from reusableDevices list first.
</span><span class=c1></span>    <span class=k>if</span> <span class=nf>allocateRemainingFrom</span><span class=p>(</span><span class=nx>reusableDevices</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>allocated</span><span class=p>,</span> <span class=kc>nil</span>
    <span class=p>}</span>

    <span class=c1>// Needs to allocate additional devices.
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>m</span><span class=p>.</span><span class=nx>allocatedDevices</span><span class=p>[</span><span class=nx>resource</span><span class=p>]</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>m</span><span class=p>.</span><span class=nx>allocatedDevices</span><span class=p>[</span><span class=nx>resource</span><span class=p>]</span> <span class=p>=</span> <span class=nx>sets</span><span class=p>.</span><span class=nf>NewString</span><span class=p>()</span>
    <span class=p>}</span>

    <span class=c1>// Gets Devices in use.
</span><span class=c1></span>    <span class=nx>devicesInUse</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>allocatedDevices</span><span class=p>[</span><span class=nx>resource</span><span class=p>]</span>
    <span class=c1>// Gets Available devices.
</span><span class=c1></span>    <span class=nx>available</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>healthyDevices</span><span class=p>[</span><span class=nx>resource</span><span class=p>].</span><span class=nf>Difference</span><span class=p>(</span><span class=nx>devicesInUse</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>available</span><span class=p>.</span><span class=nf>Len</span><span class=p>()</span> <span class=p>&lt;</span> <span class=nx>needed</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;requested number of devices unavailable for %s. Requested: %d, Available: %d&#34;</span><span class=p>,</span> <span class=nx>resource</span><span class=p>,</span> <span class=nx>needed</span><span class=p>,</span> <span class=nx>available</span><span class=p>.</span><span class=nf>Len</span><span class=p>())</span>
    <span class=p>}</span>

    <span class=c1>// Filters available Devices based on NUMA affinity.
</span><span class=c1></span>    <span class=nx>aligned</span><span class=p>,</span> <span class=nx>unaligned</span><span class=p>,</span> <span class=nx>noAffinity</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nf>filterByAffinity</span><span class=p>(</span><span class=nx>podUID</span><span class=p>,</span> <span class=nx>contName</span><span class=p>,</span> <span class=nx>resource</span><span class=p>,</span> <span class=nx>available</span><span class=p>)</span>

    <span class=c1>// If we can allocate all remaining devices from the set of aligned ones, then
</span><span class=c1></span>    <span class=c1>// give the plugin the chance to influence which ones to allocate from that set.
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>needed</span> <span class=p>&lt;</span> <span class=nx>aligned</span><span class=p>.</span><span class=nf>Len</span><span class=p>()</span> <span class=p>{</span>
        <span class=c1>// First allocate from the preferred devices list (if available).
</span><span class=c1></span>        <span class=nx>preferred</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nf>callGetPreferredAllocationIfAvailable</span><span class=p>(</span><span class=nx>podUID</span><span class=p>,</span> <span class=nx>contName</span><span class=p>,</span> <span class=nx>resource</span><span class=p>,</span> <span class=nx>aligned</span><span class=p>.</span><span class=nf>Union</span><span class=p>(</span><span class=nx>allocated</span><span class=p>),</span> <span class=nx>allocated</span><span class=p>,</span> <span class=nx>required</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=nf>allocateRemainingFrom</span><span class=p>(</span><span class=nx>preferred</span><span class=p>.</span><span class=nf>Intersection</span><span class=p>(</span><span class=nx>aligned</span><span class=p>))</span> <span class=p>{</span>
            <span class=k>return</span> <span class=nx>allocated</span><span class=p>,</span> <span class=kc>nil</span>
        <span class=p>}</span>
        <span class=c1>// Then fallback to allocate from the aligned set if no preferred list
</span><span class=c1></span>        <span class=c1>// is returned (or not enough devices are returned in that list).
</span><span class=c1></span>        <span class=k>if</span> <span class=nf>allocateRemainingFrom</span><span class=p>(</span><span class=nx>aligned</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>return</span> <span class=nx>allocated</span><span class=p>,</span> <span class=kc>nil</span>
        <span class=p>}</span>

        <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;unexpectedly allocated less resources than required. Requested: %d, Got: %d&#34;</span><span class=p>,</span> <span class=nx>required</span><span class=p>,</span> <span class=nx>required</span><span class=o>-</span><span class=nx>needed</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=c1>// If we can&#39;t allocate all remaining devices from the set of aligned ones,
</span><span class=c1></span>    <span class=c1>// then start by first allocating all of the  aligned devices (to ensure
</span><span class=c1></span>    <span class=c1>// that the alignment guaranteed by the TopologyManager is honored).
</span><span class=c1></span>    <span class=k>if</span> <span class=nf>allocateRemainingFrom</span><span class=p>(</span><span class=nx>aligned</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>allocated</span><span class=p>,</span> <span class=kc>nil</span>
    <span class=p>}</span>

    <span class=c1>// Then give the plugin the chance to influence the decision on any
</span><span class=c1></span>    <span class=c1>// remaining devices to allocate.
</span><span class=c1></span>    <span class=nx>preferred</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nf>callGetPreferredAllocationIfAvailable</span><span class=p>(</span><span class=nx>podUID</span><span class=p>,</span> <span class=nx>contName</span><span class=p>,</span> <span class=nx>resource</span><span class=p>,</span> <span class=nx>available</span><span class=p>.</span><span class=nf>Union</span><span class=p>(</span><span class=nx>allocated</span><span class=p>),</span> <span class=nx>allocated</span><span class=p>,</span> <span class=nx>required</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=nf>allocateRemainingFrom</span><span class=p>(</span><span class=nx>preferred</span><span class=p>.</span><span class=nf>Intersection</span><span class=p>(</span><span class=nx>available</span><span class=p>))</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>allocated</span><span class=p>,</span> <span class=kc>nil</span>
    <span class=p>}</span>

    <span class=c1>// Finally, if the plugin did not return a preferred allocation (or didn&#39;t
</span><span class=c1></span>    <span class=c1>// return a large enough one), then fall back to allocating the remaining
</span><span class=c1></span>    <span class=c1>// devices from the &#39;unaligned&#39; and &#39;noAffinity&#39; sets.
</span><span class=c1></span>    <span class=k>if</span> <span class=nf>allocateRemainingFrom</span><span class=p>(</span><span class=nx>unaligned</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>allocated</span><span class=p>,</span> <span class=kc>nil</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=nf>allocateRemainingFrom</span><span class=p>(</span><span class=nx>noAffinity</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>allocated</span><span class=p>,</span> <span class=kc>nil</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;unexpectedly allocated less resources than required. Requested: %d, Got: %d&#34;</span><span class=p>,</span> <span class=nx>required</span><span class=p>,</span> <span class=nx>required</span><span class=o>-</span><span class=nx>needed</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>numa亲和性分配主要在filterByAffinity中</p><ul><li>构造了perNodeDevices map对象: map[numaid]deivces</li><li>构造返回结果集：sets.NewString(fromAffinity&mldr;), sets.NewString(notFromAffinity&mldr;), sets.NewString(withoutTopology&mldr;), 即 基于numa亲和性从available资源中过滤出：aligned, unaligned, noAffinity</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>
<span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>ManagerImpl</span><span class=p>)</span> <span class=nf>filterByAffinity</span><span class=p>(</span><span class=nx>podUID</span><span class=p>,</span> <span class=nx>contName</span><span class=p>,</span> <span class=nx>resource</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>available</span> <span class=nx>sets</span><span class=p>.</span><span class=nx>String</span><span class=p>)</span> <span class=p>(</span><span class=nx>sets</span><span class=p>.</span><span class=nx>String</span><span class=p>,</span> <span class=nx>sets</span><span class=p>.</span><span class=nx>String</span><span class=p>,</span> <span class=nx>sets</span><span class=p>.</span><span class=nx>String</span><span class=p>)</span> <span class=p>{</span>

    <span class=c1>// Build a map of NUMA Nodes to the devices associated with them. A
</span><span class=c1></span>    <span class=c1>// device may be associated to multiple NUMA nodes at the same time. If an
</span><span class=c1></span>    <span class=c1>// available device does not have any NUMA Nodes associated with it, add it
</span><span class=c1></span>    <span class=c1>// to a list of NUMA Nodes for the fake NUMANode -1.
</span><span class=c1></span>    <span class=nx>perNodeDevices</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=nx>sets</span><span class=p>.</span><span class=nx>String</span><span class=p>)</span>
    <span class=nx>nodeWithoutTopology</span> <span class=o>:=</span> <span class=o>-</span><span class=mi>1</span>
    <span class=k>for</span> <span class=nx>d</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>available</span> <span class=p>{</span>
        <span class=k>if</span> <span class=nx>m</span><span class=p>.</span><span class=nx>allDevices</span><span class=p>[</span><span class=nx>resource</span><span class=p>][</span><span class=nx>d</span><span class=p>].</span><span class=nx>Topology</span> <span class=o>==</span> <span class=kc>nil</span> <span class=o>||</span> <span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>allDevices</span><span class=p>[</span><span class=nx>resource</span><span class=p>][</span><span class=nx>d</span><span class=p>].</span><span class=nx>Topology</span><span class=p>.</span><span class=nx>Nodes</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
            <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>perNodeDevices</span><span class=p>[</span><span class=nx>nodeWithoutTopology</span><span class=p>];</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
                <span class=nx>perNodeDevices</span><span class=p>[</span><span class=nx>nodeWithoutTopology</span><span class=p>]</span> <span class=p>=</span> <span class=nx>sets</span><span class=p>.</span><span class=nf>NewString</span><span class=p>()</span>
            <span class=p>}</span>
            <span class=nx>perNodeDevices</span><span class=p>[</span><span class=nx>nodeWithoutTopology</span><span class=p>].</span><span class=nf>Insert</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
            <span class=k>continue</span>
        <span class=p>}</span>

        <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>node</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>m</span><span class=p>.</span><span class=nx>allDevices</span><span class=p>[</span><span class=nx>resource</span><span class=p>][</span><span class=nx>d</span><span class=p>].</span><span class=nx>Topology</span><span class=p>.</span><span class=nx>Nodes</span> <span class=p>{</span>
            <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>perNodeDevices</span><span class=p>[</span><span class=nb>int</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>ID</span><span class=p>)];</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
                <span class=nx>perNodeDevices</span><span class=p>[</span><span class=nb>int</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>ID</span><span class=p>)]</span> <span class=p>=</span> <span class=nx>sets</span><span class=p>.</span><span class=nf>NewString</span><span class=p>()</span>
            <span class=p>}</span>
            <span class=nx>perNodeDevices</span><span class=p>[</span><span class=nb>int</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>ID</span><span class=p>)].</span><span class=nf>Insert</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=c1>// Get a flat list of all of the nodes associated with available devices.
</span><span class=c1></span>    <span class=kd>var</span> <span class=nx>nodes</span> <span class=p>[]</span><span class=kt>int</span>
    <span class=k>for</span> <span class=nx>node</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>perNodeDevices</span> <span class=p>{</span>
        <span class=nx>nodes</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>nodes</span><span class=p>,</span> <span class=nx>node</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=c1>// Sort the list of nodes by how many devices they contain.
</span><span class=c1></span>    <span class=nx>sort</span><span class=p>.</span><span class=nf>Slice</span><span class=p>(</span><span class=nx>nodes</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>perNodeDevices</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nf>Len</span><span class=p>()</span> <span class=p>&lt;</span> <span class=nx>perNodeDevices</span><span class=p>[</span><span class=nx>j</span><span class=p>].</span><span class=nf>Len</span><span class=p>()</span>
    <span class=p>})</span>

    <span class=c1>// Generate three sorted lists of devices. Devices in the first list come
</span><span class=c1></span>    <span class=c1>// from valid NUMA Nodes contained in the affinity mask. Devices in the
</span><span class=c1></span>    <span class=c1>// second list come from valid NUMA Nodes not in the affinity mask. Devices
</span><span class=c1></span>    <span class=c1>// in the third list come from devices with no NUMA Node association (i.e.
</span><span class=c1></span>    <span class=c1>// those mapped to the fake NUMA Node -1). Because we loop through the
</span><span class=c1></span>    <span class=c1>// sorted list of NUMA nodes in order, within each list, devices are sorted
</span><span class=c1></span>    <span class=c1>// by their connection to NUMA Nodes with more devices on them.
</span><span class=c1></span>    <span class=kd>var</span> <span class=nx>fromAffinity</span> <span class=p>[]</span><span class=kt>string</span>
    <span class=kd>var</span> <span class=nx>notFromAffinity</span> <span class=p>[]</span><span class=kt>string</span>
    <span class=kd>var</span> <span class=nx>withoutTopology</span> <span class=p>[]</span><span class=kt>string</span>
    <span class=k>for</span> <span class=nx>d</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>available</span> <span class=p>{</span>
        <span class=c1>// Since the same device may be associated with multiple NUMA Nodes. We
</span><span class=c1></span>        <span class=c1>// need to be careful not to add each device to multiple lists. The
</span><span class=c1></span>        <span class=c1>// logic below ensures this by breaking after the first NUMA node that
</span><span class=c1></span>        <span class=c1>// has the device is encountered.
</span><span class=c1></span>        <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>n</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nodes</span> <span class=p>{</span>
            <span class=k>if</span> <span class=nx>perNodeDevices</span><span class=p>[</span><span class=nx>n</span><span class=p>].</span><span class=nf>Has</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span> <span class=p>{</span>
                <span class=k>if</span> <span class=nx>n</span> <span class=o>==</span> <span class=nx>nodeWithoutTopology</span> <span class=p>{</span>
                    <span class=nx>withoutTopology</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>withoutTopology</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
                <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>hint</span><span class=p>.</span><span class=nx>NUMANodeAffinity</span><span class=p>.</span><span class=nf>IsSet</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span> <span class=p>{</span>
                    <span class=nx>fromAffinity</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>fromAffinity</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
                <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
                    <span class=nx>notFromAffinity</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>notFromAffinity</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
                <span class=p>}</span>
                <span class=k>break</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=c1>// Return all three lists containing the full set of devices across them.
</span><span class=c1></span>    <span class=k>return</span> <span class=nx>sets</span><span class=p>.</span><span class=nf>NewString</span><span class=p>(</span><span class=nx>fromAffinity</span><span class=o>...</span><span class=p>),</span> <span class=nx>sets</span><span class=p>.</span><span class=nf>NewString</span><span class=p>(</span><span class=nx>notFromAffinity</span><span class=o>...</span><span class=p>),</span> <span class=nx>sets</span><span class=p>.</span><span class=nf>NewString</span><span class=p>(</span><span class=nx>withoutTopology</span><span class=o>...</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>这里kubelet会调用grpc接口，通知插件按topo建议方案进行资源分配计算（此时插件并未真正分配资源）。这里的分配方案只是建议。
把上面的代码摘取出跟分配相关的处理，如果分配成功，则返回allocated, nil。如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>
<span class=c1>// If we can allocate all remaining devices from the set of aligned ones, then
</span><span class=c1></span>    <span class=c1>// give the plugin the chance to influence which ones to allocate from that set.
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>needed</span> <span class=p>&lt;</span> <span class=nx>aligned</span><span class=p>.</span><span class=nf>Len</span><span class=p>()</span> <span class=p>{</span>
        <span class=c1>// First allocate from the preferred devices list (if available).
</span><span class=c1></span>        <span class=nx>preferred</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nf>callGetPreferredAllocationIfAvailable</span><span class=p>(</span><span class=nx>podUID</span><span class=p>,</span> <span class=nx>contName</span><span class=p>,</span> <span class=nx>resource</span><span class=p>,</span> <span class=nx>aligned</span><span class=p>.</span><span class=nf>Union</span><span class=p>(</span><span class=nx>allocated</span><span class=p>),</span> <span class=nx>allocated</span><span class=p>,</span> <span class=nx>required</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=nf>allocateRemainingFrom</span><span class=p>(</span><span class=nx>preferred</span><span class=p>.</span><span class=nf>Intersection</span><span class=p>(</span><span class=nx>aligned</span><span class=p>))</span> <span class=p>{</span>
            <span class=k>return</span> <span class=nx>allocated</span><span class=p>,</span> <span class=kc>nil</span>
        <span class=p>}</span>
        <span class=c1>// Then fallback to allocate from the aligned set if no preferred list
</span><span class=c1></span>        <span class=c1>// is returned (or not enough devices are returned in that list).
</span><span class=c1></span>        <span class=k>if</span> <span class=nf>allocateRemainingFrom</span><span class=p>(</span><span class=nx>aligned</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>return</span> <span class=nx>allocated</span><span class=p>,</span> <span class=kc>nil</span>
        <span class=p>}</span>

        <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;unexpectedly allocated less resources than required. Requested: %d, Got: %d&#34;</span><span class=p>,</span> <span class=nx>required</span><span class=p>,</span> <span class=nx>required</span><span class=o>-</span><span class=nx>needed</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=c1>// If we can&#39;t allocate all remaining devices from the set of aligned ones,
</span><span class=c1></span>    <span class=c1>// then start by first allocating all of the  aligned devices (to ensure
</span><span class=c1></span>    <span class=c1>// that the alignment guaranteed by the TopologyManager is honored).
</span><span class=c1></span>    <span class=k>if</span> <span class=nf>allocateRemainingFrom</span><span class=p>(</span><span class=nx>aligned</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>allocated</span><span class=p>,</span> <span class=kc>nil</span>
    <span class=p>}</span>

    <span class=nx>preferred</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nf>callGetPreferredAllocationIfAvailable</span><span class=p>(</span><span class=nx>podUID</span><span class=p>,</span> <span class=nx>contName</span><span class=p>,</span> <span class=nx>resource</span><span class=p>,</span> <span class=nx>available</span><span class=p>.</span><span class=nf>Union</span><span class=p>(</span><span class=nx>allocated</span><span class=p>),</span> <span class=nx>allocated</span><span class=p>,</span> <span class=nx>required</span><span class=p>)</span>

</code></pre></td></tr></table></div></div><p>callGetPreferredAllocationIfAvailable 参数说明：</p><ul><li>mustInclude：allocated，allocated是根据allocateRemainingFrom(reusableDevices)，从可重用device list中获取的设备资源</li><li>available：aligned.Union(allocated)，即numa对齐的资源和mustInclude资源的合集，如果aligned资源不满足request needed，则为available.Union(allocated)</li><li>size：即request size: container.Resources.Limits</li></ul><p><strong>小结：</strong></p><ul><li><p><strong>如果aligned资源不满足request needed，则调用GetPreferredAllocationIfAvailable接口时，可用资源参数为available.Union(allocated)，让插件进行可用设备资源预分配，此时分配资源不再满足numa对齐</strong></p></li><li><p><strong>这里kubelet远程调用插件的GetPreferredAllocationIfAvailable接口，只是告诉插件要可分配资源设备列表清单，最终可以让插件根据自身拓扑情况在设备列表（候选集）中优选pod容器所需size大小的资源。</strong></p></li></ul><p>下面是按topo分配的远程调用getPreferredAllocation</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// callGetPreferredAllocationIfAvailable issues GetPreferredAllocation grpc
</span><span class=c1>// call for device plugin resource with GetPreferredAllocationAvailable option set.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>ManagerImpl</span><span class=p>)</span> <span class=nf>callGetPreferredAllocationIfAvailable</span><span class=p>(</span><span class=nx>podUID</span><span class=p>,</span> <span class=nx>contName</span><span class=p>,</span> <span class=nx>resource</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>available</span><span class=p>,</span> <span class=nx>mustInclude</span> <span class=nx>sets</span><span class=p>.</span><span class=nx>String</span><span class=p>,</span> <span class=nx>size</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>sets</span><span class=p>.</span><span class=nx>String</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
    
    <span class=nx>resp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>eI</span><span class=p>.</span><span class=nx>e</span><span class=p>.</span><span class=nf>getPreferredAllocation</span><span class=p>(</span><span class=nx>available</span><span class=p>.</span><span class=nf>UnsortedList</span><span class=p>(),</span> <span class=nx>mustInclude</span><span class=p>.</span><span class=nf>UnsortedList</span><span class=p>(),</span> <span class=nx>size</span><span class=p>)</span>
    
    <span class=k>return</span> <span class=nx>sets</span><span class=p>.</span><span class=nf>NewString</span><span class=p>(</span><span class=nx>resp</span><span class=p>.</span><span class=nx>ContainerResponses</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=nx>DeviceIDs</span><span class=o>...</span><span class=p>),</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=c1>// getPreferredAllocation issues GetPreferredAllocation gRPC call to the device plugin.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>endpointImpl</span><span class=p>)</span> <span class=nf>getPreferredAllocation</span><span class=p>(</span><span class=nx>available</span><span class=p>,</span> <span class=nx>mustInclude</span> <span class=p>[]</span><span class=kt>string</span><span class=p>,</span> <span class=nx>size</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>pluginapi</span><span class=p>.</span><span class=nx>PreferredAllocationResponse</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=nx>e</span><span class=p>.</span><span class=nf>isStopped</span><span class=p>()</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=nx>errEndpointStopped</span><span class=p>,</span> <span class=nx>e</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>e</span><span class=p>.</span><span class=nx>client</span><span class=p>.</span><span class=nf>GetPreferredAllocation</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=o>&amp;</span><span class=nx>pluginapi</span><span class=p>.</span><span class=nx>PreferredAllocationRequest</span><span class=p>{</span>
        <span class=nx>ContainerRequests</span><span class=p>:</span> <span class=p>[]</span><span class=o>*</span><span class=nx>pluginapi</span><span class=p>.</span><span class=nx>ContainerPreferredAllocationRequest</span><span class=p>{</span>
            <span class=p>{</span>
                <span class=nx>AvailableDeviceIDs</span><span class=p>:</span>   <span class=nx>available</span><span class=p>,</span>
                <span class=nx>MustIncludeDeviceIDs</span><span class=p>:</span> <span class=nx>mustInclude</span><span class=p>,</span>
                <span class=nx>AllocationSize</span><span class=p>:</span>       <span class=nb>int32</span><span class=p>(</span><span class=nx>size</span><span class=p>),</span>
            <span class=p>},</span>
        <span class=p>},</span>
    <span class=p>})</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><p>GetPreferredAllocation从可用设备列表返回要分配的首选设备集。由此产生的首选分配不能保证最终由devicemanager执行。它的目的只是帮助devicemanager在可能的情况下做出更合理的分配决策</p><div class="details admonition note open"><div class="details-summary admonition-title"><i class="icon fas fa-pencil-alt fa-fw"></i>注意<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content><p><i class="far fa-bookmark fa-fw"></i></p><p>GetPreferredAllocation returns a preferred set of devices to allocate
from a list of available ones. The resulting preferred allocation is not
guaranteed to be the allocation ultimately performed by the
devicemanager. It is only designed to help the devicemanager make a more
informed allocation decision when possible.</p></div></div></div><p>最后根据devicesToAllocate返回要分配的资源 allocDevices，并调用远程接口allocate，通知deviceplugin进行资源分配</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// allocateContainerResources attempts to allocate all of required device
</span><span class=c1>// plugin resources for the input container, issues an Allocate rpc request
</span><span class=c1>// for each new device resource requirement, processes their AllocateResponses,
</span><span class=c1>// and updates the cached containerDevices on success.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>ManagerImpl</span><span class=p>)</span> <span class=nf>allocateContainerResources</span><span class=p>(</span><span class=nx>pod</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Pod</span><span class=p>,</span> <span class=nx>container</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Container</span><span class=p>,</span> <span class=nx>devicesToReuse</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>sets</span><span class=p>.</span><span class=nx>String</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=c1>// ... 
</span><span class=c1></span>    <span class=nx>allocDevices</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nf>devicesToAllocate</span><span class=p>(</span><span class=nx>podUID</span><span class=p>,</span> <span class=nx>contName</span><span class=p>,</span> <span class=nx>resource</span><span class=p>,</span> <span class=nx>needed</span><span class=p>,</span> <span class=nx>devicesToReuse</span><span class=p>[</span><span class=nx>resource</span><span class=p>])</span>

    <span class=nx>devs</span> <span class=o>:=</span> <span class=nx>allocDevices</span><span class=p>.</span><span class=nf>UnsortedList</span><span class=p>()</span>

    <span class=nx>resp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>eI</span><span class=p>.</span><span class=nx>e</span><span class=p>.</span><span class=nf>allocate</span><span class=p>(</span><span class=nx>devs</span><span class=p>)</span>

    <span class=c1>// ... 
</span><span class=c1></span>    <span class=c1>// kubeelt更新deviceplugin快照，分配资源可按node.ID索引，如allocDevicesWithNUMA[node.ID]形式保存
</span><span class=c1></span>    <span class=nx>allocDevicesWithNUMA</span> <span class=o>:=</span> <span class=nx>checkpoint</span><span class=p>.</span><span class=nf>NewDevicesPerNUMA</span><span class=p>()</span>
    <span class=c1>// Update internal cached podDevices state.
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>dev</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>allocDevices</span> <span class=p>{</span>
        <span class=k>if</span> <span class=nx>m</span><span class=p>.</span><span class=nx>allDevices</span><span class=p>[</span><span class=nx>resource</span><span class=p>][</span><span class=nx>dev</span><span class=p>].</span><span class=nx>Topology</span> <span class=o>==</span> <span class=kc>nil</span> <span class=o>||</span> <span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>allDevices</span><span class=p>[</span><span class=nx>resource</span><span class=p>][</span><span class=nx>dev</span><span class=p>].</span><span class=nx>Topology</span><span class=p>.</span><span class=nx>Nodes</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
            <span class=nx>allocDevicesWithNUMA</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>allocDevicesWithNUMA</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=nx>dev</span><span class=p>)</span>
            <span class=k>continue</span>
        <span class=p>}</span>
        <span class=k>for</span> <span class=nx>idx</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>m</span><span class=p>.</span><span class=nx>allDevices</span><span class=p>[</span><span class=nx>resource</span><span class=p>][</span><span class=nx>dev</span><span class=p>].</span><span class=nx>Topology</span><span class=p>.</span><span class=nx>Nodes</span> <span class=p>{</span>
            <span class=nx>node</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>allDevices</span><span class=p>[</span><span class=nx>resource</span><span class=p>][</span><span class=nx>dev</span><span class=p>].</span><span class=nx>Topology</span><span class=p>.</span><span class=nx>Nodes</span><span class=p>[</span><span class=nx>idx</span><span class=p>]</span>
            <span class=nx>allocDevicesWithNUMA</span><span class=p>[</span><span class=nx>node</span><span class=p>.</span><span class=nx>ID</span><span class=p>]</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>allocDevicesWithNUMA</span><span class=p>[</span><span class=nx>node</span><span class=p>.</span><span class=nx>ID</span><span class=p>],</span> <span class=nx>dev</span><span class=p>)</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=nx>m</span><span class=p>.</span><span class=nx>podDevices</span><span class=p>.</span><span class=nf>insert</span><span class=p>(</span><span class=nx>podUID</span><span class=p>,</span> <span class=nx>contName</span><span class=p>,</span> <span class=nx>resource</span><span class=p>,</span> <span class=nx>allocDevicesWithNUMA</span><span class=p>,</span> <span class=nx>resp</span><span class=p>.</span><span class=nx>ContainerResponses</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
    <span class=k>if</span> <span class=nx>needsUpdateCheckpoint</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>m</span><span class=p>.</span><span class=nf>writeCheckpoint</span><span class=p>()</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=接口>接口</h2><h3 id=接口位置>接口位置</h3><p>kubernetes/staging/src/k8s.io/kubelet/pkg/apis/deviceplugin/v1beta1/api.proto</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-proto data-lang=proto><span class=err>
</span><span class=err></span><span class=c1>// DevicePlugin is the service advertised by Device Plugins
</span><span class=c1></span><span class=kd>service</span> <span class=n>DevicePlugin</span> <span class=p>{</span><span class=err>
</span><span class=err></span>    <span class=c1>// GetDevicePluginOptions returns options to be communicated with Device
</span><span class=c1></span>    <span class=c1>// Manager
</span><span class=c1></span>    <span class=k>rpc</span> <span class=n>GetDevicePluginOptions</span><span class=p>(</span><span class=n>Empty</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>DevicePluginOptions</span><span class=p>)</span> <span class=p>{}</span><span class=err>
</span><span class=err>
</span><span class=err></span>    <span class=c1>// ListAndWatch returns a stream of List of Devices
</span><span class=c1></span>    <span class=c1>// Whenever a Device state change or a Device disappears, ListAndWatch
</span><span class=c1></span>    <span class=c1>// returns the new list
</span><span class=c1></span>    <span class=k>rpc</span> <span class=n>ListAndWatch</span><span class=p>(</span><span class=n>Empty</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>stream</span> <span class=n>ListAndWatchResponse</span><span class=p>)</span> <span class=p>{}</span><span class=err>
</span><span class=err>
</span><span class=err></span>    <span class=c1>// GetPreferredAllocation returns a preferred set of devices to allocate
</span><span class=c1></span>    <span class=c1>// from a list of available ones. The resulting preferred allocation is not
</span><span class=c1></span>    <span class=c1>// guaranteed to be the allocation ultimately performed by the
</span><span class=c1></span>    <span class=c1>// devicemanager. It is only designed to help the devicemanager make a more
</span><span class=c1></span>    <span class=c1>// informed allocation decision when possible.
</span><span class=c1></span>    <span class=k>rpc</span> <span class=n>GetPreferredAllocation</span><span class=p>(</span><span class=n>PreferredAllocationRequest</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>PreferredAllocationResponse</span><span class=p>)</span> <span class=p>{}</span><span class=err>
</span><span class=err>
</span><span class=err></span>    <span class=c1>// Allocate is called during container creation so that the Device
</span><span class=c1></span>    <span class=c1>// Plugin can run device specific operations and instruct Kubelet
</span><span class=c1></span>    <span class=c1>// of the steps to make the Device available in the container
</span><span class=c1></span>    <span class=k>rpc</span> <span class=n>Allocate</span><span class=p>(</span><span class=n>AllocateRequest</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>AllocateResponse</span><span class=p>)</span> <span class=p>{}</span><span class=err>
</span><span class=err>
</span><span class=err></span>    <span class=c1>// PreStartContainer is called, if indicated by Device Plugin during registeration phase,
</span><span class=c1></span>    <span class=c1>// before each container start. Device plugin can run device specific operations
</span><span class=c1></span>    <span class=c1>// such as resetting the device before making devices available to the container
</span><span class=c1></span>    <span class=k>rpc</span> <span class=n>PreStartContainer</span><span class=p>(</span><span class=n>PreStartContainerRequest</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>PreStartContainerResponse</span><span class=p>)</span> <span class=p>{}</span><span class=err>
</span><span class=err></span><span class=p>}</span><span class=err>
</span><span class=err>
</span><span class=err></span><span class=c1>// ListAndWatch returns a stream of List of Devices
</span><span class=c1>// Whenever a Device state change or a Device disappears, ListAndWatch
</span><span class=c1>// returns the new list
</span><span class=c1></span><span class=kd>message</span> <span class=nc>ListAndWatchResponse</span> <span class=p>{</span><span class=err>
</span><span class=err></span>    <span class=k>repeated</span> <span class=n>Device</span> <span class=n>devices</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span><span class=err></span><span class=p>}</span><span class=err>
</span><span class=err>
</span><span class=err></span><span class=kd>message</span> <span class=nc>TopologyInfo</span> <span class=p>{</span><span class=err>
</span><span class=err></span>    <span class=k>repeated</span> <span class=n>NUMANode</span> <span class=n>nodes</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span><span class=err></span><span class=p>}</span><span class=err>
</span><span class=err>
</span><span class=err></span><span class=kd>message</span> <span class=nc>NUMANode</span> <span class=p>{</span><span class=err>
</span><span class=err></span>    <span class=kt>int64</span> <span class=n>ID</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span><span class=err></span><span class=p>}</span><span class=err>
</span><span class=err>
</span><span class=err></span><span class=cm>/* E.g:
</span><span class=cm>* struct Device {
</span><span class=cm>*    ID: &#34;GPU-fef8089b-4820-abfc-e83e-94318197576e&#34;,
</span><span class=cm>*    Health: &#34;Healthy&#34;,
</span><span class=cm>*    Topology: 
</span><span class=cm>*      Node: 
</span><span class=cm>*        ID: 1 
</span><span class=cm>*} */</span><span class=err>
</span><span class=err></span><span class=kd>message</span> <span class=nc>Device</span> <span class=p>{</span><span class=err>
</span><span class=err></span>    <span class=c1>// A unique ID assigned by the device plugin used
</span><span class=c1></span>    <span class=c1>// to identify devices during the communication
</span><span class=c1></span>    <span class=c1>// Max length of this field is 63 characters
</span><span class=c1></span>    <span class=kt>string</span> <span class=n>ID</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span><span class=err></span>    <span class=c1>// Health of the device, can be healthy or unhealthy, see constants.go
</span><span class=c1></span>    <span class=kt>string</span> <span class=n>health</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span><span class=err>
</span><span class=err></span>    <span class=c1>// Topology for device
</span><span class=c1></span>    <span class=n>TopologyInfo</span> <span class=n>topology</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span><span class=err>
</span><span class=err></span><span class=p>}</span><span class=err>
</span><span class=err>
</span></code></pre></td></tr></table></div></div><h2 id=nvidia-k8s-device-plugin>NVIDIA k8s-device-plugin</h2><p>插件版本：k8s-device-plugin-0.7.3</p><h3 id=gpu-device>gpu device</h3><p>目前插件对分配策略的参数配置如下</p><p>&ldquo;nvidia.com/gpu"的GPU资源，默认采用BestEffortPolicy</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>plugins</span> <span class=o>:=</span> <span class=p>[]</span><span class=o>*</span><span class=nx>NvidiaDevicePlugin</span><span class=p>{</span>
        <span class=nf>NewNvidiaDevicePlugin</span><span class=p>(</span>
            <span class=s>&#34;nvidia.com/gpu&#34;</span><span class=p>,</span>
            <span class=nf>NewGpuDeviceManager</span><span class=p>(</span><span class=kc>true</span><span class=p>),</span>
            <span class=s>&#34;NVIDIA_VISIBLE_DEVICES&#34;</span><span class=p>,</span>
            <span class=nx>gpuallocator</span><span class=p>.</span><span class=nf>NewBestEffortPolicy</span><span class=p>(),</span>
            <span class=nx>pluginapi</span><span class=p>.</span><span class=nx>DevicePluginPath</span><span class=o>+</span><span class=s>&#34;nvidia-gpu.sock&#34;</span><span class=p>),</span>
    <span class=p>}</span>
</code></pre></td></tr></table></div></div><h3 id=处理流程>处理流程</h3><p>分析k8s-device-plugin对GetPreferredAllocation处理</p><ul><li>对kubelet的请求参数AvailableDeviceIDs和MustIncludeDeviceIDs进行校验，构造available和required</li><li>按策略执行allocatePolicy.Allocate</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// GetPreferredAllocation returns the preferred allocation from the set of devices specified in the request
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>NvidiaDevicePlugin</span><span class=p>)</span> <span class=nf>GetPreferredAllocation</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>pluginapi</span><span class=p>.</span><span class=nx>PreferredAllocationRequest</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>pluginapi</span><span class=p>.</span><span class=nx>PreferredAllocationResponse</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>response</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>pluginapi</span><span class=p>.</span><span class=nx>PreferredAllocationResponse</span><span class=p>{}</span>
    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>req</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>r</span><span class=p>.</span><span class=nx>ContainerRequests</span> <span class=p>{</span>
        <span class=nx>available</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>gpuallocator</span><span class=p>.</span><span class=nf>NewDevicesFrom</span><span class=p>(</span><span class=nx>req</span><span class=p>.</span><span class=nx>AvailableDeviceIDs</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;Unable to retrieve list of available devices: %v&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
        <span class=p>}</span>

        <span class=nx>required</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>gpuallocator</span><span class=p>.</span><span class=nf>NewDevicesFrom</span><span class=p>(</span><span class=nx>req</span><span class=p>.</span><span class=nx>MustIncludeDeviceIDs</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;Unable to retrieve list of required devices: %v&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
        <span class=p>}</span>

        <span class=nx>allocated</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nx>allocatePolicy</span><span class=p>.</span><span class=nf>Allocate</span><span class=p>(</span><span class=nx>available</span><span class=p>,</span> <span class=nx>required</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=nx>req</span><span class=p>.</span><span class=nx>AllocationSize</span><span class=p>))</span>

        <span class=kd>var</span> <span class=nx>deviceIds</span> <span class=p>[]</span><span class=kt>string</span>
        <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>device</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>allocated</span> <span class=p>{</span>
            <span class=nx>deviceIds</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>deviceIds</span><span class=p>,</span> <span class=nx>device</span><span class=p>.</span><span class=nx>UUID</span><span class=p>)</span>
        <span class=p>}</span>

        <span class=nx>resp</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>pluginapi</span><span class=p>.</span><span class=nx>ContainerPreferredAllocationResponse</span><span class=p>{</span>
            <span class=nx>DeviceIDs</span><span class=p>:</span> <span class=nx>deviceIds</span><span class=p>,</span>
        <span class=p>}</span>

        <span class=nx>response</span><span class=p>.</span><span class=nx>ContainerResponses</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>response</span><span class=p>.</span><span class=nx>ContainerResponses</span><span class=p>,</span> <span class=nx>resp</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>response</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h3 id=处理策略>处理策略</h3><p>GPU分配算法采用了策略模式，相关代码文件位置在
k8s-device-plugin\vendor\github.com\NVIDIA\go-gpuallocator\gpuallocator</p><p>gpu插件的资源分配算法已经封装为依赖包NVIDIA\go-gpuallocator</p><h4 id=simplepolicy>simplePolicy</h4><p><strong>算法思想</strong>
先选required，再从set(available - required)中，选择满足size大小的gpus数。
该算法简单且没有考虑任何GPU拓扑连接</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>
<span class=c1>// Allocate GPUs following a simple policy.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>simplePolicy</span><span class=p>)</span> <span class=nf>Allocate</span><span class=p>(</span><span class=nx>available</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Device</span><span class=p>,</span> <span class=nx>required</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Device</span><span class=p>,</span> <span class=nx>size</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Device</span> <span class=p>{</span>
    <span class=k>if</span> <span class=nx>size</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=p>{</span>
        <span class=k>return</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Device</span><span class=p>{}</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>available</span><span class=p>)</span> <span class=p>&lt;</span> <span class=nx>size</span> <span class=p>{</span>
        <span class=k>return</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Device</span><span class=p>{}</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>required</span><span class=p>)</span> <span class=p>&gt;</span> <span class=nx>size</span> <span class=p>{</span>
        <span class=k>return</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Device</span><span class=p>{}</span>
    <span class=p>}</span>

    <span class=nx>availableSet</span> <span class=o>:=</span> <span class=nf>NewDeviceSet</span><span class=p>(</span><span class=nx>available</span><span class=o>...</span><span class=p>)</span>
    <span class=k>if</span> <span class=p>!</span><span class=nx>availableSet</span><span class=p>.</span><span class=nf>ContainsAll</span><span class=p>(</span><span class=nx>required</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Device</span><span class=p>{}</span>
    <span class=p>}</span>
    <span class=nx>availableSet</span><span class=p>.</span><span class=nf>Delete</span><span class=p>(</span><span class=nx>required</span><span class=o>...</span><span class=p>)</span>

    <span class=nx>allocated</span> <span class=o>:=</span> <span class=nb>append</span><span class=p>([]</span><span class=o>*</span><span class=nx>Device</span><span class=p>{},</span> <span class=nx>required</span><span class=o>...</span><span class=p>)</span>
    <span class=nx>allocated</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>allocated</span><span class=p>,</span> <span class=nx>availableSet</span><span class=p>.</span><span class=nf>SortedSlice</span><span class=p>()[:</span><span class=nx>size</span><span class=o>-</span><span class=nb>len</span><span class=p>(</span><span class=nx>allocated</span><span class=p>)]</span><span class=o>...</span><span class=p>)</span>
    <span class=k>return</span> <span class=nx>allocated</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><h4 id=besteffortpolicy>bestEffortPolicy</h4><p><strong>算法思想</strong></p><p>Allocate从可用GPU设备列表中查找要分配的<code>最佳大小GPU集</code>，并返回它们。该算法旨在确保必需GPU设备的列表出现在最终分配中。</p><blockquote><p>该算法考虑了大小为“size”的所有可能gpu集。然而，它并不满足于贪婪的解决方案，即寻找具有最高分数的单个大小集“size”。相反，当将节点上所有可用的gpu划分为大小为“size”的集合，然后将它们各自的分数相加时，它会寻找一种使总分最大化的解决方案。然后它返回该分组中具有最高得分的GPU集。</p></blockquote><p>这种解决方案在一般情况下是必要的，因为各种链接的非层次性会影响每对gpu计算的分数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>
<span class=c1>//  Allocate finds the best set of &#39;size&#39; GPUs to allocate from a list of
</span><span class=c1>//  available GPU devices and returns them. The algorithm is designed to
</span><span class=c1>//  ensure that a list of &#39;required&#39; GPU devices is present in the final
</span><span class=c1>//  allocation.
</span><span class=c1>//
</span><span class=c1>//  This algorithm considers all possible sets of GPUs of size &#39;size&#39;.
</span><span class=c1>//  However, it does not settle for the greedy solution of looking for the
</span><span class=c1>//  single set of size &#39;size&#39; with the highest score. Instead, it looks for a
</span><span class=c1>//  solution that maximizes the total score when dividing up all available
</span><span class=c1>//  GPUs on the node into sets of size &#39;size&#39; and then summing their
</span><span class=c1>//  individual scores. It then returns the set of GPUs from that grouping
</span><span class=c1>//  with the highest individual score.
</span><span class=c1>//
</span><span class=c1>//  Such a solution is necessary in the general case because of the
</span><span class=c1>//  non-hierarchical nature of the various links that influence the score
</span><span class=c1>//  calculated for each pair of GPUs.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>bestEffortPolicy</span><span class=p>)</span> <span class=nf>Allocate</span><span class=p>(</span><span class=nx>available</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Device</span><span class=p>,</span> <span class=nx>required</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Device</span><span class=p>,</span> <span class=nx>size</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Device</span> <span class=p>{</span>
    <span class=k>if</span> <span class=nx>size</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=p>{</span>
        <span class=k>return</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Device</span><span class=p>{}</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>available</span><span class=p>)</span> <span class=p>&lt;</span> <span class=nx>size</span> <span class=p>{</span>
        <span class=k>return</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Device</span><span class=p>{}</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>required</span><span class=p>)</span> <span class=p>&gt;</span> <span class=nx>size</span> <span class=p>{</span>
        <span class=k>return</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Device</span><span class=p>{}</span>
    <span class=p>}</span>

    <span class=c1>// Find the highest scoring GPU partition with sets of of size &#39;size&#39;.
</span><span class=c1></span>    <span class=c1>// Don&#39;t consider partitions that don&#39;t have at least one set that contains
</span><span class=c1></span>    <span class=c1>// all of the GPUs &#39;required&#39; by the allocation.
</span><span class=c1></span>    <span class=c1>// 1. 计算出得分最高的gpu分区（分组），该分区需要满足要分配size大小，并包含全部的&#39;required&#39;
</span><span class=c1></span>    <span class=c1>// gpuPartition对devices按size等分，e.g. [[0,1],[2,3]]；如果不能等分，则padding处理，填充devices。？？？
</span><span class=c1></span>    <span class=nx>bestPartition</span> <span class=o>:=</span> <span class=p>[][]</span><span class=o>*</span><span class=nf>Device</span><span class=p>(</span><span class=kc>nil</span><span class=p>)</span>
    <span class=nx>bestScore</span> <span class=o>:=</span> <span class=mi>0</span>
    <span class=nf>iterateGPUPartitions</span><span class=p>(</span><span class=nx>available</span><span class=p>,</span> <span class=nx>size</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>candidate</span> <span class=p>[][]</span><span class=o>*</span><span class=nx>Device</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>!</span><span class=nf>gpuPartitionContainsSetWithAll</span><span class=p>(</span><span class=nx>candidate</span><span class=p>,</span> <span class=nx>required</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>return</span>
        <span class=p>}</span>
        <span class=nx>score</span> <span class=o>:=</span> <span class=nf>calculateGPUPartitionScore</span><span class=p>(</span><span class=nx>candidate</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>score</span> <span class=p>&gt;</span> <span class=nx>bestScore</span> <span class=o>||</span> <span class=nx>bestPartition</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nx>bestPartition</span> <span class=p>=</span> <span class=nx>candidate</span>
            <span class=nx>bestScore</span> <span class=p>=</span> <span class=nx>score</span>
        <span class=p>}</span>
    <span class=p>})</span>

    <span class=c1>// Filter the &#39;bestPartition&#39; to only include sets containing all of the
</span><span class=c1></span>    <span class=c1>// &#39;required&#39; devices (which may be nil so all sets will be valid).
</span><span class=c1></span>    <span class=nx>filteredBestPartition</span> <span class=o>:=</span> <span class=p>[][]</span><span class=o>*</span><span class=nx>Device</span><span class=p>{}</span>
    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>set</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>bestPartition</span> <span class=p>{</span>
        <span class=k>if</span> <span class=nf>gpuSetContainsAll</span><span class=p>(</span><span class=nx>set</span><span class=p>,</span> <span class=nx>required</span><span class=p>)</span> <span class=p>{</span>
            <span class=nx>filteredBestPartition</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>filteredBestPartition</span><span class=p>,</span> <span class=nx>set</span><span class=p>)</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>filteredBestPartition</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
        <span class=k>return</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Device</span><span class=p>{}</span>
    <span class=p>}</span>

    <span class=c1>// Find the highest scoring GPU set in the highest scoring GPU partition.
</span><span class=c1></span>    <span class=c1>// 在得分最高的分区中，找到得分最高的GPUset
</span><span class=c1></span>    <span class=nx>bestSet</span> <span class=o>:=</span> <span class=nx>filteredBestPartition</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
    <span class=nx>bestScore</span> <span class=p>=</span> <span class=nf>calculateGPUSetScore</span><span class=p>(</span><span class=nx>bestSet</span><span class=p>)</span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>filteredBestPartition</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
        <span class=nx>score</span> <span class=o>:=</span> <span class=nf>calculateGPUSetScore</span><span class=p>(</span><span class=nx>filteredBestPartition</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
        <span class=k>if</span> <span class=nx>score</span> <span class=p>&gt;</span> <span class=nx>bestScore</span> <span class=p>{</span>
            <span class=nx>bestSet</span> <span class=p>=</span> <span class=nx>filteredBestPartition</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
            <span class=nx>bestScore</span> <span class=p>=</span> <span class=nx>score</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=c1>// Return the highest scoring GPU set.
</span><span class=c1></span>    <span class=k>return</span> <span class=nx>bestSet</span>
<span class=p>}</span>


</code></pre></td></tr></table></div></div><p>这里处理了gpuSet中的gpu拓扑得分，累计gpuSet中每对设备的得分PairScore，最后得出总分score</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Get the total score of a set of GPUs. The score is calculated as the sum of
</span><span class=c1>// the scores calculated for each pair of GPUs in the set.
</span><span class=c1></span><span class=kd>func</span> <span class=nf>calculateGPUSetScore</span><span class=p>(</span><span class=nx>gpuSet</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Device</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
    <span class=nx>score</span> <span class=o>:=</span> <span class=mi>0</span>

    <span class=nf>iterateGPUSets</span><span class=p>(</span><span class=nx>gpuSet</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>gpus</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Device</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>score</span> <span class=o>+=</span> <span class=nf>calculateGPUPairScore</span><span class=p>(</span><span class=nx>gpus</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=nx>gpus</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
    <span class=p>})</span>

    <span class=k>return</span> <span class=nx>score</span>
<span class=p>}</span>


<span class=c1>// Calculate a &#34;link&#34; score for a pair of GPUs.
</span><span class=c1>// The score is based on the &#34;closeness&#34; of the two GPUs in relation to one
</span><span class=c1>// another in terms of the communication links they have with another, as well
</span><span class=c1>// as the PCIe hierarchy they are in. GPUs connected by an NVLINK receive 100
</span><span class=c1>// points for each link connecting them. GPUs in the PCIe hierarchy receive
</span><span class=c1>// points relative to how close they are to one another.
</span><span class=c1></span><span class=kd>func</span> <span class=nf>calculateGPUPairScore</span><span class=p>(</span><span class=nx>gpu0</span> <span class=o>*</span><span class=nx>Device</span><span class=p>,</span> <span class=nx>gpu1</span> <span class=o>*</span><span class=nx>Device</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
    <span class=k>if</span> <span class=nx>gpu0</span> <span class=o>==</span> <span class=kc>nil</span> <span class=o>||</span> <span class=nx>gpu1</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=mi>0</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=nx>gpu0</span> <span class=o>==</span> <span class=nx>gpu1</span> <span class=p>{</span>
        <span class=k>return</span> <span class=mi>0</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>gpu0</span><span class=p>.</span><span class=nx>Links</span><span class=p>[</span><span class=nx>gpu1</span><span class=p>.</span><span class=nx>Index</span><span class=p>])</span> <span class=o>!=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>gpu1</span><span class=p>.</span><span class=nx>Links</span><span class=p>[</span><span class=nx>gpu0</span><span class=p>.</span><span class=nx>Index</span><span class=p>])</span> <span class=p>{</span>
        <span class=nx>err</span> <span class=o>:=</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;Internal error in bestEffort GPU allocator: all P2PLinks between 2 GPUs should be bidirectional&#34;</span><span class=p>)</span>
        <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=nx>score</span> <span class=o>:=</span> <span class=mi>0</span>

    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>link</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>gpu0</span><span class=p>.</span><span class=nx>Links</span><span class=p>[</span><span class=nx>gpu1</span><span class=p>.</span><span class=nx>Index</span><span class=p>]</span> <span class=p>{</span>
        <span class=k>switch</span> <span class=nx>link</span><span class=p>.</span><span class=nx>Type</span> <span class=p>{</span>
        <span class=k>case</span> <span class=nx>nvml</span><span class=p>.</span><span class=nx>P2PLinkCrossCPU</span><span class=p>:</span>
            <span class=nx>score</span> <span class=o>+=</span> <span class=mi>10</span>
        <span class=k>case</span> <span class=nx>nvml</span><span class=p>.</span><span class=nx>P2PLinkSameCPU</span><span class=p>:</span>
            <span class=nx>score</span> <span class=o>+=</span> <span class=mi>20</span>
        <span class=k>case</span> <span class=nx>nvml</span><span class=p>.</span><span class=nx>P2PLinkHostBridge</span><span class=p>:</span>
            <span class=nx>score</span> <span class=o>+=</span> <span class=mi>30</span>
        <span class=k>case</span> <span class=nx>nvml</span><span class=p>.</span><span class=nx>P2PLinkMultiSwitch</span><span class=p>:</span>
            <span class=nx>score</span> <span class=o>+=</span> <span class=mi>40</span>
        <span class=k>case</span> <span class=nx>nvml</span><span class=p>.</span><span class=nx>P2PLinkSingleSwitch</span><span class=p>:</span>
            <span class=nx>score</span> <span class=o>+=</span> <span class=mi>50</span>
        <span class=k>case</span> <span class=nx>nvml</span><span class=p>.</span><span class=nx>P2PLinkSameBoard</span><span class=p>:</span>
            <span class=nx>score</span> <span class=o>+=</span> <span class=mi>60</span>
        <span class=k>case</span> <span class=nx>nvml</span><span class=p>.</span><span class=nx>SingleNVLINKLink</span><span class=p>:</span>
            <span class=nx>score</span> <span class=o>+=</span> <span class=mi>100</span>
        <span class=k>case</span> <span class=nx>nvml</span><span class=p>.</span><span class=nx>TwoNVLINKLinks</span><span class=p>:</span>
            <span class=nx>score</span> <span class=o>+=</span> <span class=mi>200</span>
        <span class=k>case</span> <span class=nx>nvml</span><span class=p>.</span><span class=nx>ThreeNVLINKLinks</span><span class=p>:</span>
            <span class=nx>score</span> <span class=o>+=</span> <span class=mi>300</span>
        <span class=k>case</span> <span class=nx>nvml</span><span class=p>.</span><span class=nx>FourNVLINKLinks</span><span class=p>:</span>
            <span class=nx>score</span> <span class=o>+=</span> <span class=mi>400</span>
        <span class=k>case</span> <span class=nx>nvml</span><span class=p>.</span><span class=nx>FiveNVLINKLinks</span><span class=p>:</span>
            <span class=nx>score</span> <span class=o>+=</span> <span class=mi>500</span>
        <span class=k>case</span> <span class=nx>nvml</span><span class=p>.</span><span class=nx>SixNVLINKLinks</span><span class=p>:</span>
            <span class=nx>score</span> <span class=o>+=</span> <span class=mi>600</span>
        <span class=k>case</span> <span class=nx>nvml</span><span class=p>.</span><span class=nx>SevenNVLINKLinks</span><span class=p>:</span>
            <span class=nx>score</span> <span class=o>+=</span> <span class=mi>700</span>
        <span class=k>case</span> <span class=nx>nvml</span><span class=p>.</span><span class=nx>EightNVLINKLinks</span><span class=p>:</span>
            <span class=nx>score</span> <span class=o>+=</span> <span class=mi>800</span>
        <span class=k>case</span> <span class=nx>nvml</span><span class=p>.</span><span class=nx>NineNVLINKLinks</span><span class=p>:</span>
            <span class=nx>score</span> <span class=o>+=</span> <span class=mi>900</span>
        <span class=k>case</span> <span class=nx>nvml</span><span class=p>.</span><span class=nx>TenNVLINKLinks</span><span class=p>:</span>
            <span class=nx>score</span> <span class=o>+=</span> <span class=mi>1000</span>
        <span class=k>case</span> <span class=nx>nvml</span><span class=p>.</span><span class=nx>ElevenNVLINKLinks</span><span class=p>:</span>
            <span class=nx>score</span> <span class=o>+=</span> <span class=mi>1100</span>
        <span class=k>case</span> <span class=nx>nvml</span><span class=p>.</span><span class=nx>TwelveNVLINKLinks</span><span class=p>:</span>
            <span class=nx>score</span> <span class=o>+=</span> <span class=mi>1200</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=nx>score</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>从上可以看出，NVLINKLinks的拓扑得分较高。各种link类型分值由高到低（各种vnlink先暂按同一类型SingleNVLINKLink）排列如下：</p><table><thead><tr><th>Link Type</th><th>Score</th></tr></thead><tbody><tr><td>NVLINKLinks</td><td>100</td></tr><tr><td>P2PLinkSameBoard</td><td>60</td></tr><tr><td>P2PLinkSingleSwitch</td><td>50</td></tr><tr><td>P2PLinkMultiSwitch</td><td>40</td></tr><tr><td>P2PLinkHostBridge</td><td>30</td></tr><tr><td>P2PLinkSameCPU</td><td>20</td></tr><tr><td>P2PLinkCrossCPU</td><td>10</td></tr></tbody></table><p>小结：</p><ul><li><strong>gpu插件优选gpu得分最高的gpu卡设备，所以满足nvlink拓扑亲和性的可用gpu卡设备会优先分配。</strong></li><li><strong>可用gpu卡设备需满足 GetPreferredAllocation接口参数要求</strong></li></ul><h4 id=其它策略暂时未用>其它策略（暂时未用）</h4><p>说明，插件项目中还有其他策略，但未使用，如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Policy Definitions
</span><span class=c1></span><span class=kd>type</span> <span class=nx>staticDGX1PascalPolicy</span> <span class=kd>struct</span><span class=p>{}</span>
<span class=kd>type</span> <span class=nx>staticDGX1VoltaPolicy</span> <span class=kd>struct</span><span class=p>{}</span>
<span class=kd>type</span> <span class=nx>staticDGX2VoltaPolicy</span> <span class=kd>struct</span><span class=p>{}</span>

</code></pre></td></tr></table></div></div><h3 id=gpu-拓扑>gpu 拓扑</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>P2PLinkType</span> <span class=kt>uint</span>

<span class=kd>const</span> <span class=p>(</span>
    <span class=nx>P2PLinkUnknown</span> <span class=nx>P2PLinkType</span> <span class=p>=</span> <span class=kc>iota</span>
    <span class=nx>P2PLinkCrossCPU</span>
    <span class=nx>P2PLinkSameCPU</span>
    <span class=nx>P2PLinkHostBridge</span>
    <span class=nx>P2PLinkMultiSwitch</span>
    <span class=nx>P2PLinkSingleSwitch</span>
    <span class=nx>P2PLinkSameBoard</span>
    <span class=nx>SingleNVLINKLink</span>
    <span class=nx>TwoNVLINKLinks</span>
    <span class=nx>ThreeNVLINKLinks</span>
    <span class=nx>FourNVLINKLinks</span>
    <span class=nx>FiveNVLINKLinks</span>
    <span class=nx>SixNVLINKLinks</span>
    <span class=nx>SevenNVLINKLinks</span>
    <span class=nx>EightNVLINKLinks</span>
    <span class=nx>NineNVLINKLinks</span>
    <span class=nx>TenNVLINKLinks</span>
    <span class=nx>ElevenNVLINKLinks</span>
    <span class=nx>TwelveNVLINKLinks</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>t</span> <span class=nx>P2PLinkType</span><span class=p>)</span> <span class=nf>String</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
    <span class=k>switch</span> <span class=nx>t</span> <span class=p>{</span>
    <span class=k>case</span> <span class=nx>P2PLinkCrossCPU</span><span class=p>:</span>
        <span class=k>return</span> <span class=s>&#34;Cross CPU socket&#34;</span>
    <span class=k>case</span> <span class=nx>P2PLinkSameCPU</span><span class=p>:</span>
        <span class=k>return</span> <span class=s>&#34;Same CPU socket&#34;</span>
    <span class=k>case</span> <span class=nx>P2PLinkHostBridge</span><span class=p>:</span>
        <span class=k>return</span> <span class=s>&#34;Host PCI bridge&#34;</span>
    <span class=k>case</span> <span class=nx>P2PLinkMultiSwitch</span><span class=p>:</span>
        <span class=k>return</span> <span class=s>&#34;Multiple PCI switches&#34;</span>
    <span class=k>case</span> <span class=nx>P2PLinkSingleSwitch</span><span class=p>:</span>
        <span class=k>return</span> <span class=s>&#34;Single PCI switch&#34;</span>
    <span class=k>case</span> <span class=nx>P2PLinkSameBoard</span><span class=p>:</span>
        <span class=k>return</span> <span class=s>&#34;Same board&#34;</span>
    <span class=k>case</span> <span class=nx>SingleNVLINKLink</span><span class=p>:</span>
        <span class=k>return</span> <span class=s>&#34;Single NVLink&#34;</span>
    <span class=k>case</span> <span class=nx>TwoNVLINKLinks</span><span class=p>:</span>
        <span class=k>return</span> <span class=s>&#34;Two NVLinks&#34;</span>
    <span class=k>case</span> <span class=nx>ThreeNVLINKLinks</span><span class=p>:</span>
        <span class=k>return</span> <span class=s>&#34;Three NVLinks&#34;</span>
    <span class=k>case</span> <span class=nx>FourNVLINKLinks</span><span class=p>:</span>
        <span class=k>return</span> <span class=s>&#34;Four NVLinks&#34;</span>
    <span class=k>case</span> <span class=nx>FiveNVLINKLinks</span><span class=p>:</span>
        <span class=k>return</span> <span class=s>&#34;Five NVLinks&#34;</span>
    <span class=k>case</span> <span class=nx>SixNVLINKLinks</span><span class=p>:</span>
        <span class=k>return</span> <span class=s>&#34;Six NVLinks&#34;</span>
    <span class=k>case</span> <span class=nx>SevenNVLINKLinks</span><span class=p>:</span>
        <span class=k>return</span> <span class=s>&#34;Seven NVLinks&#34;</span>
    <span class=k>case</span> <span class=nx>EightNVLINKLinks</span><span class=p>:</span>
        <span class=k>return</span> <span class=s>&#34;Eight NVLinks&#34;</span>
    <span class=k>case</span> <span class=nx>NineNVLINKLinks</span><span class=p>:</span>
        <span class=k>return</span> <span class=s>&#34;Nine NVLinks&#34;</span>
    <span class=k>case</span> <span class=nx>TenNVLINKLinks</span><span class=p>:</span>
        <span class=k>return</span> <span class=s>&#34;Ten NVLinks&#34;</span>
    <span class=k>case</span> <span class=nx>ElevenNVLINKLinks</span><span class=p>:</span>
        <span class=k>return</span> <span class=s>&#34;Eleven NVLinks&#34;</span>
    <span class=k>case</span> <span class=nx>TwelveNVLINKLinks</span><span class=p>:</span>
        <span class=k>return</span> <span class=s>&#34;Twelve NVLinks&#34;</span>
    <span class=k>case</span> <span class=nx>P2PLinkUnknown</span><span class=p>:</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=s>&#34;N/A&#34;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>插件实例创建时NewDevices，会构造device信息，其中包括GPU拓扑连接信息</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>
<span class=c1>// Device represents a GPU device as reported by NVML, including all of its
</span><span class=c1>// Point-to-Point link information.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Device</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=o>*</span><span class=nx>nvml</span><span class=p>.</span><span class=nx>Device</span>
    <span class=nx>Index</span> <span class=kt>int</span>
    <span class=nx>Links</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>][]</span><span class=nx>P2PLink</span>
<span class=p>}</span>

<span class=c1>// P2PLink represents a Point-to-Point link between two GPU devices. The link
</span><span class=c1>// is between the Device struct this struct is embedded in and the GPU Device
</span><span class=c1>// contained in the P2PLink struct itself.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>P2PLink</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>GPU</span>  <span class=o>*</span><span class=nx>Device</span>
    <span class=nx>Type</span> <span class=nx>nvml</span><span class=p>.</span><span class=nx>P2PLinkType</span>
<span class=p>}</span>


<span class=c1>// DeviceSet is used to hold and manipulate a set of unique GPU devices.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>DeviceSet</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=o>*</span><span class=nx>Device</span>


<span class=c1>// Create a list of Devices from all available nvml.Devices.
</span><span class=c1></span><span class=kd>func</span> <span class=nf>NewDevices</span><span class=p>()</span> <span class=p>([]</span><span class=o>*</span><span class=nx>Device</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>devices</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>devices</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>Device</span><span class=p>{</span><span class=nx>device</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>][]</span><span class=nx>P2PLink</span><span class=p>)})</span>
 

    <span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>d1</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>devices</span> <span class=p>{</span>
        <span class=k>for</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>d2</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>devices</span> <span class=p>{</span>
            <span class=k>if</span> <span class=nx>d1</span> <span class=o>!=</span> <span class=nx>d2</span> <span class=p>{</span>
                <span class=nx>p2plink</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>nvml</span><span class=p>.</span><span class=nf>GetP2PLink</span><span class=p>(</span><span class=nx>d1</span><span class=p>.</span><span class=nx>Device</span><span class=p>,</span> <span class=nx>d2</span><span class=p>.</span><span class=nx>Device</span><span class=p>)</span>
                <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
                    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;error getting P2PLink for devices (%v, %v): %v&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
                <span class=p>}</span>
                <span class=k>if</span> <span class=nx>p2plink</span> <span class=o>!=</span> <span class=nx>nvml</span><span class=p>.</span><span class=nx>P2PLinkUnknown</span> <span class=p>{</span>
                    <span class=nx>d1</span><span class=p>.</span><span class=nx>Links</span><span class=p>[</span><span class=nx>d2</span><span class=p>.</span><span class=nx>Index</span><span class=p>]</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>d1</span><span class=p>.</span><span class=nx>Links</span><span class=p>[</span><span class=nx>d2</span><span class=p>.</span><span class=nx>Index</span><span class=p>],</span> <span class=nx>P2PLink</span><span class=p>{</span><span class=nx>d2</span><span class=p>,</span> <span class=nx>p2plink</span><span class=p>})</span>
                <span class=p>}</span>

                <span class=nx>nvlink</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>nvml</span><span class=p>.</span><span class=nf>GetNVLink</span><span class=p>(</span><span class=nx>d1</span><span class=p>.</span><span class=nx>Device</span><span class=p>,</span> <span class=nx>d2</span><span class=p>.</span><span class=nx>Device</span><span class=p>)</span>
                <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
                    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;error getting NVLink for devices (%v, %v): %v&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
                <span class=p>}</span>
                <span class=k>if</span> <span class=nx>nvlink</span> <span class=o>!=</span> <span class=nx>nvml</span><span class=p>.</span><span class=nx>P2PLinkUnknown</span> <span class=p>{</span>
                    <span class=nx>d1</span><span class=p>.</span><span class=nx>Links</span><span class=p>[</span><span class=nx>d2</span><span class=p>.</span><span class=nx>Index</span><span class=p>]</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>d1</span><span class=p>.</span><span class=nx>Links</span><span class=p>[</span><span class=nx>d2</span><span class=p>.</span><span class=nx>Index</span><span class=p>],</span> <span class=nx>P2PLink</span><span class=p>{</span><span class=nx>d2</span><span class=p>,</span> <span class=nx>nvlink</span><span class=p>})</span>
                <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=nx>devices</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><h2 id=总结>总结</h2><ol><li>kubelet根据所在节点可用资源和numa对齐准则，提供资源分配建议topo hint</li><li>cpu资源分配，在cpu static分配策略下，由cpumanager根据计算好的topo hint进行cpuset分配</li><li>gpu资源分配：则由kubelet和gpu插件共同作用完成<ul><li>kubelet会计算topo hint，并远程调用gpu插件的GetPreferredAllocation，提供gpu分配建议，包括request、available、size等</li><li>gpu插件根据分配建议，在bestEffortPolicy策略下，还会计算gpu device的拓扑得分，然后优选gpuset，并把该gpuset的devices返回给kubelet</li><li>kbuelet根据gpu插件确认后的gpu devices，再校验处理，调用allocate，通知gpu插件进行资源分配</li></ul></li></ol></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2021-01-05</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/k8s/>K8S</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/2020/12/k8s%E5%9F%BA%E4%BA%8Enuma%E4%BA%B2%E5%92%8C%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95/ class=prev rel=prev title=K8S基于NUMA亲和性的资源分配特性测试><i class="fas fa-angle-left fa-fw"></i>K8S基于NUMA亲和性的资源分配特性测试</a>
<a href=/posts/2021/01/python%E7%94%9F%E6%88%90requirements.txt%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/ class=next rel=next title=python生成requirements.txt环境打包>python生成requirements.txt环境打包<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=utterances></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>Utterances</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2016 - 2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=bingerambo.com target=_blank>Binge</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=http://bingerambo.com/ target=_blank>bingerambo.com</a></span></div><div class=footer-line><i class="fa fa-eye"></i>本站总访问量<span id=busuanzi_value_site_pv></span>次
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/css/lightgallery.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/js/lightgallery.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lg-thumbnail.js@1.2.0/dist/lg-thumbnail.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lg-zoom.js@1.2.0/dist/lg-zoom.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{"utterances":{"darkTheme":"github-dark","issueTerm":"pathname","label":"","lightTheme":"github-light","repo":"bingerambo/myblog-comments"}},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true}};</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','UA-81425808-1',{'anonymize_ip':true});</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=UA-81425808-1" async></script><script src=https://libs.baidu.com/jquery/2.1.4/jquery.min.js></script><script src=https://cdn.bootcdn.net/ajax/libs/jquery-backstretch/2.1.18/jquery.backstretch.min.js></script><script type=text/javascript src=/js/custom.js></script><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?c0176279eee823ce422da4e8d06708f9";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script></body></html>