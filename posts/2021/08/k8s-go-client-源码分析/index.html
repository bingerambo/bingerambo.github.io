<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>K8S go-client 源码分析 - 斌哥的小站|Binge Blog</title><meta name=Description content="斌哥的小站 | 这里是 @BingeRambo斌哥兰博的个人博客"><meta property="og:title" content="K8S go-client 源码分析"><meta property="og:description" content="K8S go-client 源码分析，k8s controller开发所需"><meta property="og:type" content="article"><meta property="og:url" content="http://bingerambo.com/posts/2021/08/k8s-go-client-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><meta property="og:image" content="http://bingerambo.com/logo.png"><meta property="article:published_time" content="2021-08-31T08:43:17+08:00"><meta property="article:modified_time" content="2021-08-31T08:43:17+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://bingerambo.com/logo.png"><meta name=twitter:title content="K8S go-client 源码分析"><meta name=twitter:description content="K8S go-client 源码分析，k8s controller开发所需"><meta name=application-name content="Binge Blog"><meta name=apple-mobile-web-app-title content="Binge Blog"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=http://bingerambo.com/posts/2021/08/k8s-go-client-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/><link rel=prev href=http://bingerambo.com/posts/2021/07/k8s%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AFipclient-ip%E6%96%B9%E6%B3%95/><link rel=next href=http://bingerambo.com/posts/2021/10/lxcfs%E7%9A%84k8s%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB%E8%A7%86%E5%9B%BE/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/custom.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"K8S go-client 源码分析","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/bingerambo.com\/posts\/2021\/08\/k8s-go-client-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\/"},"image":["http:\/\/bingerambo.com\/images\/Apple-Devices-Preview.png"],"genre":"posts","keywords":"K8S","wordcount":33618,"url":"http:\/\/bingerambo.com\/posts\/2021\/08\/k8s-go-client-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\/","datePublished":"2021-08-31T08:43:17+08:00","dateModified":"2021-08-31T08:43:17+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xxxx","logo":"http:\/\/bingerambo.com\/images\/avatar.png"},"author":{"@type":"Person","name":"Binge"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="斌哥的小站|Binge Blog"><span class=header-title-pre><i class="fas fa-biking fa-fw"></i></span>Binge Blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/><i class="fas fa-fw fa-archive"></i>文章 </a><a class=menu-item href=/tags/><i class="fas fa-fw fa-tag"></i>标签 </a><a class=menu-item href=/categories/><i class="fas fa-fw fa-th"></i>分类 </a><a class=menu-item href=/timeline/><i class="fas fa-cog fa-spin"></i>随记 </a><a class=menu-item href=/about/><i class="fas fa-fw fa-at"></i>关于 </a><a class=menu-item href=/search/><i class="fas fa-fw fa-search"></i>搜索 </a><a class=menu-item href=/friend/ title=Friend><i class="fas fa fa-user"></i>友链 </a><a class=menu-item href=https://github.com/bingerambo title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><a class=menu-item href=/><i class="fas fa fa-eye"></i><span id=busuanzi_value_site_uv></span></a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="斌哥的小站|Binge Blog"><span class=header-title-pre><i class="fas fa-biking fa-fw"></i></span>Binge Blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/><i class="fas fa-fw fa-archive"></i>文章</a><a class=menu-item href=/tags/><i class="fas fa-fw fa-tag"></i>标签</a><a class=menu-item href=/categories/><i class="fas fa-fw fa-th"></i>分类</a><a class=menu-item href=/timeline/><i class="fas fa-cog fa-spin"></i>随记</a><a class=menu-item href=/about/><i class="fas fa-fw fa-at"></i>关于</a><a class=menu-item href=/search/><i class="fas fa-fw fa-search"></i>搜索</a><a class=menu-item href=/friend/ title=Friend><i class="fas fa fa-user"></i>友链</a><a class=menu-item href=https://github.com/bingerambo title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><a class=menu-item href=/><i class="fas fa fa-eye"></i><span id=busuanzi_value_site_uv></span></a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">K8S go-client 源码分析</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=http://bingerambo.com title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>Binge</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/k8s/><i class="far fa-folder fa-fw"></i>K8S</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-08-31>2021-08-31</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 33618 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 68 分钟&nbsp;
<i class="fa fa-eye fa-fw"></i>&nbsp;本文总阅读量 <span id=busuanzi_value_page_pv></span>次&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#client-go>Client-go</a></li><li><a href=#设计图>设计图</a></li><li><a href=#informer>Informer</a><ul><li><a href=#listerwatcher>ListerWatcher</a></li><li><a href=#reflector>Reflector</a><ul><li><a href=#run>Run</a></li><li><a href=#listandwatch>ListAndWatch</a></li><li><a href=#syncwith和watchhandler>syncWith和watchHandler</a></li><li><a href=#resyncchan>resyncChan</a></li></ul></li><li><a href=#说明>说明</a></li></ul></li><li><a href=#controller>Controller</a><ul><li><a href=#流程处理>流程处理</a><ul><li><a href=#run-1>Run</a></li><li><a href=#processloop>processLoop</a></li><li><a href=#hassynced>HasSynced</a></li></ul></li></ul></li><li><a href=#sharedinformer>SharedInformer</a><ul><li><a href=#sharedinformer接口>SharedInformer接口</a></li><li><a href=#sharedindexinformer类>sharedIndexInformer类</a></li><li><a href=#cachemutationdetector-非重要可忽略>CacheMutationDetector 【非重要，可忽略】</a></li><li><a href=#sharedprocessor>sharedProcessor</a><ul><li><a href=#processorlistener>processorListener</a></li><li><a href=#sharedprocessor-1>sharedProcessor</a></li></ul></li><li><a href=#sharedinformer实现>SharedInformer实现</a></li><li><a href=#说明-1>说明</a></li></ul></li><li><a href=#deltafifo>DeltaFIFO</a><ul><li><a href=#queue>Queue</a></li><li><a href=#deltafifo实现>DeltaFIFO实现</a></li><li><a href=#说明-2>说明</a></li></ul></li><li><a href=#index>Index</a><ul><li><a href=#index-1>index</a></li><li><a href=#store>store</a></li><li><a href=#thread_safe_store>thread_safe_store</a></li><li><a href=#说明-3>说明</a></li></ul></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div></div><div class=content id=content><p>K8S go-client 源码分析，k8s controller开发所需</p><p>本文参考了CSDN博主「进德」的原创文章，原文链接：https://blog.csdn.net/weixin_42663840/article/details/81699303, <strong>并做了部分内容和注释说明修改：</strong></p><h2 id=client-go>Client-go</h2><p>client-go 设计</p><img src=client-go.jpg style=width:100%><p>可以看到client-go主要模块有：</p><ul><li>client<ul><li>restclient</li><li>clientset</li><li>dynamicclient</li><li>discoveryclient</li></ul></li><li>informer<ul><li>reflactor</li><li>deltafifo</li><li>indexer</li></ul></li><li>workqueue</li></ul><p><strong>说明：client和workqueue源码分析不在本文中介绍。</strong></p><h2 id=设计图>设计图</h2><img src=controller.png style=width:100%>
由上可看出，进行k8s controller开发时，对以下几点进行定制开发：<ul><li>informer的resource event handler处理</li><li>对workqueue的入队和出队操作处理</li><li>如果业务需要，对resource的本地存储操作</li><li>controller自身的业务层逻辑处理</li></ul><img src=controller2.png style=width:100%>
<img src=controller3.png style=width:100%>
informer类图
<img src=informer.png style=width:100%><h2 id=informer>Informer</h2><p>这里介绍常用的SharedInformer</p><p>不难看出Shared指的是多个listeners共享同一个cache，而且资源的变化会同时通知到cache和listeners。这个解释和上面图所展示的内容的是一致的，cache我们在Indexer的介绍中已经分析过了，listerners指的就是OnAdd、OnUpdate、OnDelete这些回调函数背后的对象，本文就要对Informer进行系统性的分析。我们先对上面的图做一些初步的认识：</p><ul><li>List/Watch：List是列举apiserver中对象的接口，Watch是监控apiserver资源变化的接口；</li><li>Reflector：反射器，实现对apiserver指定类型对象的监控，其中反射实现的就是把监控的结果实例化成具体的对象；</li><li>DeltaIFIFO：将Reflector监控的变化的对象形成一个FIFO队列，此处的Delta就是变化</li><li>LocalStore：指的就是Indexer的实现cache，这里面缓存的就是apiserver中的对象(其中有一部分可能还在DeltaFIFO中)，此时使用者再查询对象的时候就直接从cache中查找，减少了apiserver的压力；</li><li>Callbacks：通知回调函数，Infomer感知的所有对象变化都是通过回调函数通知使用者(Listener)，即event_handler处理；</li></ul><h3 id=listerwatcher>ListerWatcher</h3><p>ListerWatcher是一个interface类型
client-go/tools/cache/listwatch.go</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// ListerWatcher is any object that knows how to perform an initial list and start a watch on a resource.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>ListerWatcher</span> <span class=kd>interface</span> <span class=p>{</span>
    <span class=c1>// List should return a list type object; the Items field will be extracted, and the
</span><span class=c1></span>    <span class=c1>// ResourceVersion field will be used to start the watch in the right place.
</span><span class=c1></span>    <span class=nf>List</span><span class=p>(</span><span class=nx>options</span> <span class=nx>metav1</span><span class=p>.</span><span class=nx>ListOptions</span><span class=p>)</span> <span class=p>(</span><span class=nx>runtime</span><span class=p>.</span><span class=nx>Object</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
    <span class=c1>// Watch should begin a watch at the specified version.
</span><span class=c1></span>    <span class=nf>Watch</span><span class=p>(</span><span class=nx>options</span> <span class=nx>metav1</span><span class=p>.</span><span class=nx>ListOptions</span><span class=p>)</span> <span class=p>(</span><span class=nx>watch</span><span class=p>.</span><span class=nx>Interface</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
<span class=p>}</span>

<span class=c1>// ListFunc knows how to list resources
</span><span class=c1></span><span class=kd>type</span> <span class=nx>ListFunc</span> <span class=kd>func</span><span class=p>(</span><span class=nx>options</span> <span class=nx>metav1</span><span class=p>.</span><span class=nx>ListOptions</span><span class=p>)</span> <span class=p>(</span><span class=nx>runtime</span><span class=p>.</span><span class=nx>Object</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>

<span class=c1>// WatchFunc knows how to watch resources
</span><span class=c1></span><span class=kd>type</span> <span class=nx>WatchFunc</span> <span class=kd>func</span><span class=p>(</span><span class=nx>options</span> <span class=nx>metav1</span><span class=p>.</span><span class=nx>ListOptions</span><span class=p>)</span> <span class=p>(</span><span class=nx>watch</span><span class=p>.</span><span class=nx>Interface</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>

<span class=c1>// ListWatch knows how to list and watch a set of apiserver resources.  It satisfies the ListerWatcher interface.
</span><span class=c1>// It is a convenience function for users of NewReflector, etc.
</span><span class=c1>// ListFunc and WatchFunc must not be nil
</span><span class=c1></span><span class=kd>type</span> <span class=nx>ListWatch</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>ListFunc</span>  <span class=nx>ListFunc</span>
    <span class=nx>WatchFunc</span> <span class=nx>WatchFunc</span>
    <span class=c1>// DisableChunking requests no chunking for this list watcher. It has no effect in Kubernetes 1.8, but in
</span><span class=c1></span>    <span class=c1>// 1.9 will allow a controller to opt out of chunking.
</span><span class=c1></span>    <span class=nx>DisableChunking</span> <span class=kt>bool</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p><strong>需要注意一点：ListerWatcher是针对某一类对象的，比如Pod，不是所有对象的，这个在构造ListerWatcher对象的时候由apiserver的client类型决定了。</strong></p><h3 id=reflector>Reflector</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// 代码源自client-go/tools/cache/reflector.go
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Reflector</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>name</span> <span class=kt>string</span>                                 <span class=c1>// 名字
</span><span class=c1></span>    <span class=nx>metrics</span> <span class=o>*</span><span class=nx>reflectorMetrics</span>                   <span class=c1>// 但凡遇到metrics多半是用于做监控的，可以忽略
</span><span class=c1></span>    <span class=nx>expectedType</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Type</span>                   <span class=c1>// 反射的类型，也就是要监控的对象类型，比如Pod
</span><span class=c1></span>    <span class=nx>store</span> <span class=nx>Store</span>                                 <span class=c1>// 存储，就是DeltaFIFO，为什么，后面会有代码证明
</span><span class=c1></span>    <span class=nx>listerWatcher</span> <span class=nx>ListerWatcher</span>                 <span class=c1>// 这个是用来从apiserver获取资源用的
</span><span class=c1></span>    <span class=nx>period</span>       <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span>                  <span class=c1>// 反射器在List和Watch的时候理论上是死循环，只有出现错误才会退出
</span><span class=c1></span>                                                <span class=c1>// 这个变量用在出错后多长时间再执行List和Watch，默认值是1秒钟
</span><span class=c1></span>    <span class=nx>resyncPeriod</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span>                  <span class=c1>// 重新同步的周期，很多人肯定认为这个同步周期指的是从apiserver的同步周期
</span><span class=c1></span>                                                <span class=c1>// 其实这里面同步指的是shared_informer使用者需要定期同步全量对象
</span><span class=c1></span>    <span class=nx>ShouldResync</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>bool</span>                    <span class=c1>// 如果需要同步，调用这个函数问一下，当然前提是该函数指针不为空
</span><span class=c1></span>    <span class=nx>clock</span> <span class=nx>clock</span><span class=p>.</span><span class=nx>Clock</span>                           <span class=c1>// 时钟
</span><span class=c1></span>    <span class=nx>lastSyncResourceVersion</span> <span class=kt>string</span>              <span class=c1>// 最后一次同步的资源版本
</span><span class=c1></span>    <span class=nx>lastSyncResourceVersionMutex</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>   <span class=c1>// 还专门为最后一次同步的资源版本弄了个锁
</span><span class=c1></span><span class=p>}</span>

</code></pre></td></tr></table></div></div><ol><li>listerWatcher用于获取和监控资源，lister可以获取对象的全量，watcher可以获取对象的增量(变化)；</li><li>系统会周期性的执行list-watch的流程，一旦过程中失败就要重新执行流程，这个重新执行的周期就是period指定的；</li><li>expectedType规定了监控对象的类型，非此类型的对象将会被忽略；</li><li>实例化后的expectedType类型的对象会被添加到store中；</li><li>kubernetes资源在apiserver中都是有版本的，对象的任何除了修改(添加、删除、更新)都会造成资源版本更新，所以lastSyncResourceVersion就是指的这个版本；</li><li>如果使用者需要定期同步全量对象，那么Reflector就会定期产生全量对象的同步事件给DeltaFIFO;</li></ol><h4 id=run>Run</h4><p>Reflector有一个Run()函数，这个是Reflector的核心功能流程</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// 代码源自client-go/tools/cache/reflector.go
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>Reflector</span><span class=p>)</span> <span class=nf>Run</span><span class=p>(</span><span class=nx>stopCh</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span> <span class=p>{</span>
    <span class=c1>// func Until(f func(), period time.Duration, stopCh &lt;-chan struct{})是下面函数的声明
</span><span class=c1></span>    <span class=c1>// 这里面我们不用关心wait.Until是如何实现的，只要知道他调用函数f会被每period周期执行一次
</span><span class=c1></span>    <span class=c1>// 意思就是f()函数执行完毕再等period时间后在执行一次，也就是r.ListAndWatch()会被周期性的调用
</span><span class=c1></span>    <span class=nx>wait</span><span class=p>.</span><span class=nf>Until</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>ListAndWatch</span><span class=p>(</span><span class=nx>stopCh</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nx>utilruntime</span><span class=p>.</span><span class=nf>HandleError</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
        <span class=p>}</span>
    <span class=p>},</span> <span class=nx>r</span><span class=p>.</span><span class=nx>period</span><span class=p>,</span> <span class=nx>stopCh</span><span class=p>)</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><h4 id=listandwatch>ListAndWatch</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>
<span class=c1>// 代码源自client-go/tools/cache/reflector.go
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>Reflector</span><span class=p>)</span> <span class=nf>ListAndWatch</span><span class=p>(</span><span class=nx>stopCh</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=kd>var</span> <span class=nx>resourceVersion</span> <span class=kt>string</span>
    <span class=c1>// 很多存储类的系统都是这样设计的，数据采用版本的方式记录，数据每变化(添加、删除、更新)都会触发版本更新，
</span><span class=c1></span>    <span class=c1>// 这样的做法可以避免全量数据访问。以apiserver资源监控为例，只要监控比缓存中资源版本大的对象就可以了，
</span><span class=c1></span>    <span class=c1>// 把变化的部分更新到缓存中就可以达到与apiserver一致的效果，一般资源的初始版本为0，从0版本开始列举就是全量的对象了
</span><span class=c1></span>    <span class=c1>// 1. 从版本号0 开始list，List()可以从缓存中提供，并且可能会相对于etcd内容延迟。
</span><span class=c1></span>    <span class=c1>// 最终，由watch进行监听更新
</span><span class=c1></span>    <span class=nx>options</span> <span class=o>:=</span> <span class=nx>metav1</span><span class=p>.</span><span class=nx>ListOptions</span><span class=p>{</span><span class=nx>ResourceVersion</span><span class=p>:</span> <span class=s>&#34;0&#34;</span><span class=p>}</span>
    <span class=c1>// 与监控相关的内容不多解释
</span><span class=c1></span>    <span class=nx>r</span><span class=p>.</span><span class=nx>metrics</span><span class=p>.</span><span class=nx>numberOfLists</span><span class=p>.</span><span class=nf>Inc</span><span class=p>()</span>
    <span class=nx>start</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>clock</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
    <span class=c1>// 列举资源，这部分是apimachery相关的内容，读者感兴趣可以自己了解
</span><span class=c1></span>    <span class=nx>list</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>listerWatcher</span><span class=p>.</span><span class=nf>List</span><span class=p>(</span><span class=nx>options</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;%s: Failed to list %v: %v&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>expectedType</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=c1>// 还是监控相关的
</span><span class=c1></span>    <span class=nx>r</span><span class=p>.</span><span class=nx>metrics</span><span class=p>.</span><span class=nx>listDuration</span><span class=p>.</span><span class=nf>Observe</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Since</span><span class=p>(</span><span class=nx>start</span><span class=p>).</span><span class=nf>Seconds</span><span class=p>())</span>
    <span class=c1>// 下面的代码主要是利用apimachinery相关的函数实现，就是把列举返回的结果转换为对象数组
</span><span class=c1></span>    <span class=c1>// 下面的代码大部分来自apimachinery，此处不做过多说明，读者只要知道实现什么功能就行了
</span><span class=c1></span>    <span class=nx>listMetaInterface</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>meta</span><span class=p>.</span><span class=nf>ListAccessor</span><span class=p>(</span><span class=nx>list</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;%s: Unable to understand list result %#v: %v&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span> <span class=nx>list</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=c1>// 2. 根据listMeta ResourceVersion的版本号，决定从哪里开始watch
</span><span class=c1></span>    <span class=nx>resourceVersion</span> <span class=p>=</span> <span class=nx>listMetaInterface</span><span class=p>.</span><span class=nf>GetResourceVersion</span><span class=p>()</span>
    <span class=c1>// 3. 将资源数据转换成资源列表 runtime.Object -&gt; []runtime.Object
</span><span class=c1></span>    <span class=nx>items</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>meta</span><span class=p>.</span><span class=nf>ExtractList</span><span class=p>(</span><span class=nx>list</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;%s: Unable to understand list result %#v (%v)&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span> <span class=nx>list</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=c1>// 和监控相关的内容
</span><span class=c1></span>    <span class=nx>r</span><span class=p>.</span><span class=nx>metrics</span><span class=p>.</span><span class=nx>numberOfItemsInList</span><span class=p>.</span><span class=nf>Observe</span><span class=p>(</span><span class=nb>float64</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>items</span><span class=p>)))</span>
    <span class=c1>// 以上部分都是对象实例化的过程，可以称之为反射，也是Reflector这个名字的主要来源，本文不是讲解反射原理的，
</span><span class=c1></span>    <span class=c1>// 而是作为SharedInformer的前端，所以我们重点介绍的是对象在SharedInformer中流转过程，所以反射原理部分不做为重点讲解
</span><span class=c1></span>    <span class=c1>// 这可是真正从apiserver同步过来的全量对象，所以要同步到DeltaFIFO中
</span><span class=c1></span>    <span class=c1>// 4. 将资源对象列表和资源版本号 以r.store.Replace方式存储到DeltaFIFO中
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>syncWith</span><span class=p>(</span><span class=nx>items</span><span class=p>,</span> <span class=nx>resourceVersion</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;%s: Unable to sync list result: %v&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=c1>// 设置最新的同步的对象版本
</span><span class=c1></span>    <span class=c1>// 5. 设置最新的资源版本号
</span><span class=c1></span>    <span class=nx>r</span><span class=p>.</span><span class=nf>setLastSyncResourceVersion</span><span class=p>(</span><span class=nx>resourceVersion</span><span class=p>)</span>
    <span class=c1>// 下面要启动一个后台协程实现定期的同步操作，这个同步就是将SharedInformer里面的对象全量以同步事件的方式通知使用者
</span><span class=c1></span>    <span class=c1>// 我们暂且称之为“后台同步协程”，Run()函数退出需要后台同步协程退出，所以下面的cancelCh就是干这个用的
</span><span class=c1></span>    <span class=c1>// 利用defer close(cancelCh)实现的，而resyncerrc是后台同步协程反向通知Run()函数的报错通道
</span><span class=c1></span>    <span class=c1>// 当后台同步协程出错，Run()函数接收到信号就可以退出了
</span><span class=c1></span>    <span class=nx>resyncerrc</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>error</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
    <span class=nx>cancelCh</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
    <span class=k>defer</span> <span class=nb>close</span><span class=p>(</span><span class=nx>cancelCh</span><span class=p>)</span>
    <span class=c1>// 下面这个匿名函数就是后台同步协程的函数了
</span><span class=c1></span>    <span class=c1>// 6. 开启Resync协程： 根据ShouldResync标识，重新同步处理store.Resync()
</span><span class=c1></span>    <span class=c1>// 这个同步Resync，不是从apiserver中获取，而是从indexer cache的resync处理
</span><span class=c1></span>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
        <span class=c1>// resyncCh返回的就是一个定时器，如果resyncPeriod这个为0那么就会返回一个永久定时器，cleanup函数是用来清理定时器的
</span><span class=c1></span>        <span class=nx>resyncCh</span><span class=p>,</span> <span class=nx>cleanup</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>resyncChan</span><span class=p>()</span>
        <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
            <span class=nf>cleanup</span><span class=p>()</span> 
        <span class=p>}()</span>
        <span class=c1>// 死循环等待各种信号
</span><span class=c1></span>        <span class=k>for</span> <span class=p>{</span>
            <span class=c1>// 只有定时器有信号才继续处理，其他的都会退出
</span><span class=c1></span>            <span class=c1>// 注意case &lt;-resyncCh 定时同步分支，没有return，会继续执行r.store.Resync()处理
</span><span class=c1></span>            <span class=k>select</span> <span class=p>{</span>
            <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>resyncCh</span><span class=p>:</span>
            <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>stopCh</span><span class=p>:</span>
                <span class=k>return</span>
            <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>cancelCh</span><span class=p>:</span>
                <span class=k>return</span>
            <span class=p>}</span>
            <span class=c1>// ShouldResync是个函数地址，创建反射器对象的时候传入，即便时间到了，也要通过函数问问是否需要同步
</span><span class=c1></span>            <span class=k>if</span> <span class=nx>r</span><span class=p>.</span><span class=nx>ShouldResync</span> <span class=o>==</span> <span class=kc>nil</span> <span class=o>||</span> <span class=nx>r</span><span class=p>.</span><span class=nf>ShouldResync</span><span class=p>()</span> <span class=p>{</span>
                <span class=c1>// 我们知道这个store是DeltaFIFO，DeltaFIFO.Resync(): 把knownObjects的objs同步更新到delta_fifo中
</span><span class=c1></span>                <span class=c1>// 就在这里实现了我们前面提到的同步，从这里看所谓的同步就是以全量对象同步事件的方式通知使用者
</span><span class=c1></span>                <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>store</span><span class=p>.</span><span class=nf>Resync</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
                    <span class=nx>resyncerrc</span> <span class=o>&lt;-</span> <span class=nx>err</span>
                    <span class=k>return</span>
                <span class=p>}</span>
            <span class=p>}</span>
            <span class=c1>// 清理掉当前的计时器，获取下一个同步时间定时器
</span><span class=c1></span>            <span class=nf>cleanup</span><span class=p>()</span>
            <span class=nx>resyncCh</span><span class=p>,</span> <span class=nx>cleanup</span> <span class=p>=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>resyncChan</span><span class=p>()</span>
        <span class=p>}</span>
    <span class=p>}()</span>
 
    <span class=c1>// 前面已经列举了全量对象，接下来就是watch的逻辑了
</span><span class=c1></span>    <span class=c1>// 7. 从 资源版本号resourceVersion 开始进行watch处理
</span><span class=c1></span>    <span class=k>for</span> <span class=p>{</span>
        <span class=c1>// 如果有退出信号就立刻返回，否则就会往下走，因为有default.
</span><span class=c1></span>        <span class=k>select</span> <span class=p>{</span>
        <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>stopCh</span><span class=p>:</span>
            <span class=k>return</span> <span class=kc>nil</span>
        <span class=k>default</span><span class=p>:</span>
        <span class=p>}</span>
 
        <span class=c1>// 计算watch的超时时间
</span><span class=c1></span>        <span class=nx>timeoutSeconds</span> <span class=o>:=</span> <span class=nb>int64</span><span class=p>(</span><span class=nx>minWatchTimeout</span><span class=p>.</span><span class=nf>Seconds</span><span class=p>()</span> <span class=o>*</span> <span class=p>(</span><span class=nx>rand</span><span class=p>.</span><span class=nf>Float64</span><span class=p>()</span> <span class=o>+</span> <span class=mf>1.0</span><span class=p>))</span>
        <span class=c1>// 设置watch的选项，因为前期列举了全量对象，从这里只要监听最新版本以后的资源就可以了
</span><span class=c1></span>        <span class=c1>// 如果没有资源变化总不能一直挂着吧？也不知道是卡死了还是怎么了，所以有一个超时会好一点
</span><span class=c1></span>        <span class=nx>options</span> <span class=p>=</span> <span class=nx>metav1</span><span class=p>.</span><span class=nx>ListOptions</span><span class=p>{</span>
            <span class=nx>ResourceVersion</span><span class=p>:</span> <span class=nx>resourceVersion</span><span class=p>,</span>
            <span class=nx>TimeoutSeconds</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>timeoutSeconds</span><span class=p>,</span>
        <span class=p>}</span>
        <span class=c1>// 监控相关
</span><span class=c1></span>        <span class=nx>r</span><span class=p>.</span><span class=nx>metrics</span><span class=p>.</span><span class=nx>numberOfWatches</span><span class=p>.</span><span class=nf>Inc</span><span class=p>()</span>
        <span class=c1>// 开始监控对象
</span><span class=c1></span>        <span class=c1>// 7.1 watch函数阻塞处理，返回w，即监控事件流ResultChan
</span><span class=c1></span>        <span class=nx>w</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>listerWatcher</span><span class=p>.</span><span class=nf>Watch</span><span class=p>(</span><span class=nx>options</span><span class=p>)</span>
        <span class=c1>// watch产生错误了，大部分错误就要退出函数然后再重新来一遍流程
</span><span class=c1></span>        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=k>switch</span> <span class=nx>err</span> <span class=p>{</span>
            <span class=k>case</span> <span class=nx>io</span><span class=p>.</span><span class=nx>EOF</span><span class=p>:</span>
            <span class=k>case</span> <span class=nx>io</span><span class=p>.</span><span class=nx>ErrUnexpectedEOF</span><span class=p>:</span>
            <span class=k>default</span><span class=p>:</span>
                <span class=nx>utilruntime</span><span class=p>.</span><span class=nf>HandleError</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;%s: Failed to watch %v: %v&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>expectedType</span><span class=p>,</span> <span class=nx>err</span><span class=p>))</span>
            <span class=p>}</span>
            <span class=c1>// 类似于网络拒绝连接的错误要等一会儿再试，因为可能网络繁忙
</span><span class=c1></span>            <span class=k>if</span> <span class=nx>urlError</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>err</span><span class=p>.(</span><span class=o>*</span><span class=nx>url</span><span class=p>.</span><span class=nx>Error</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
                <span class=k>if</span> <span class=nx>opError</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>urlError</span><span class=p>.</span><span class=nx>Err</span><span class=p>.(</span><span class=o>*</span><span class=nx>net</span><span class=p>.</span><span class=nx>OpError</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
                    <span class=k>if</span> <span class=nx>errno</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>opError</span><span class=p>.</span><span class=nx>Err</span><span class=p>.(</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>Errno</span><span class=p>);</span> <span class=nx>ok</span> <span class=o>&amp;&amp;</span> <span class=nx>errno</span> <span class=o>==</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>ECONNREFUSED</span> <span class=p>{</span>
                        <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
                        <span class=k>continue</span>
                    <span class=p>}</span>
                <span class=p>}</span>
            <span class=p>}</span>
            <span class=k>return</span> <span class=kc>nil</span>
        <span class=p>}</span>
 
        <span class=c1>// watch返回是流，apiserver会将变化的资源通过这个流发送出来，client-go最终通过chan实现的
</span><span class=c1></span>        <span class=c1>// 所以watchHandler()是一个需要持续从chan读取数据的流程，所以需要传入resyncerrc和stopCh
</span><span class=c1></span>        <span class=c1>// 用于异步通知退出或者后台同步协程错误
</span><span class=c1></span>        <span class=c1>// 7.2 watch 事件处理
</span><span class=c1></span>        <span class=c1>//  Added    EventType = &#34;ADDED&#34;
</span><span class=c1></span>        <span class=c1>//  Modified EventType = &#34;MODIFIED&#34;
</span><span class=c1></span>        <span class=c1>//  Deleted  EventType = &#34;DELETED&#34;
</span><span class=c1></span>        <span class=c1>//  Error    EventType = &#34;ERROR&#34;
</span><span class=c1></span>        <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>watchHandler</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>resourceVersion</span><span class=p>,</span> <span class=nx>resyncerrc</span><span class=p>,</span> <span class=nx>stopCh</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=nx>errorStopRequested</span> <span class=p>{</span>
                <span class=nx>glog</span><span class=p>.</span><span class=nf>Warningf</span><span class=p>(</span><span class=s>&#34;%s: watch of %v ended with: %v&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>expectedType</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
            <span class=p>}</span>
            <span class=k>return</span> <span class=kc>nil</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><p>上面的函数中，调用了两个私有函数，分别为syncWith()和watchHandler()。syncWith()用于实现一次从apiserver全量对象的同步，这里的同步和我们上面提到的同步不是一回事，这里指的是从apiserver的同步。watchHandler是实现监控apiserver资源变化的处理过程，主要就是把apiserver的资源变化转换为DeltaFIFO调用。我们接下来就看这两个函数的具体实现</p><p>接下来我们就要看看watchHandler做了什么？</p><h4 id=syncwith和watchhandler>syncWith和watchHandler</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span><span class=lnt>87
</span><span class=lnt>88
</span><span class=lnt>89
</span><span class=lnt>90
</span><span class=lnt>91
</span><span class=lnt>92
</span><span class=lnt>93
</span><span class=lnt>94
</span><span class=lnt>95
</span><span class=lnt>96
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>
<span class=c1>// 代码源自client-go/tools/cache/reflector.go
</span><span class=c1>// 实现apiserver全量对象的同步
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>Reflector</span><span class=p>)</span> <span class=nf>syncWith</span><span class=p>(</span><span class=nx>items</span> <span class=p>[]</span><span class=nx>runtime</span><span class=p>.</span><span class=nx>Object</span><span class=p>,</span> <span class=nx>resourceVersion</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=c1>// 做一次slice类型转换
</span><span class=c1></span>    <span class=nx>found</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kd>interface</span><span class=p>{},</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>items</span><span class=p>))</span>
    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>item</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>items</span> <span class=p>{</span>
        <span class=nx>found</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>found</span><span class=p>,</span> <span class=nx>item</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=c1>// 直接调用了DeltaFIFO的Replace()接口，这个接口就是用于同步全量对象的
</span><span class=c1></span>    <span class=k>return</span> <span class=nx>r</span><span class=p>.</span><span class=nx>store</span><span class=p>.</span><span class=nf>Replace</span><span class=p>(</span><span class=nx>found</span><span class=p>,</span> <span class=nx>resourceVersion</span><span class=p>)</span>
<span class=p>}</span>
<span class=c1>// 实现从watch返回的chan中持续读取变化的资源，并转换为DeltaFIFO相应的调用
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>Reflector</span><span class=p>)</span> <span class=nf>watchHandler</span><span class=p>(</span><span class=nx>w</span> <span class=nx>watch</span><span class=p>.</span><span class=nx>Interface</span><span class=p>,</span> <span class=nx>resourceVersion</span> <span class=o>*</span><span class=kt>string</span><span class=p>,</span> <span class=nx>errc</span> <span class=kd>chan</span> <span class=kt>error</span><span class=p>,</span> <span class=nx>stopCh</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=nx>start</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>clock</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
    <span class=nx>eventCount</span> <span class=o>:=</span> <span class=mi>0</span>
    <span class=c1>// 监控相关
</span><span class=c1></span>    <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
        <span class=nx>r</span><span class=p>.</span><span class=nx>metrics</span><span class=p>.</span><span class=nx>numberOfItemsInWatch</span><span class=p>.</span><span class=nf>Observe</span><span class=p>(</span><span class=nb>float64</span><span class=p>(</span><span class=nx>eventCount</span><span class=p>))</span>
        <span class=nx>r</span><span class=p>.</span><span class=nx>metrics</span><span class=p>.</span><span class=nx>watchDuration</span><span class=p>.</span><span class=nf>Observe</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Since</span><span class=p>(</span><span class=nx>start</span><span class=p>).</span><span class=nf>Seconds</span><span class=p>())</span>
    <span class=p>}()</span>
 
    <span class=c1>// 这里就开始无限循环的从chan中读取资源的变化，也可以理解为资源的增量变化，同时还要监控各种信号
</span><span class=c1></span><span class=nx>loop</span><span class=p>:</span>
    <span class=k>for</span> <span class=p>{</span>
        <span class=k>select</span> <span class=p>{</span>
        <span class=c1>// 系统退出信号
</span><span class=c1></span>        <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>stopCh</span><span class=p>:</span>
            <span class=k>return</span> <span class=nx>errorStopRequested</span>
        <span class=c1>// 后台同步协程出错信号
</span><span class=c1></span>        <span class=k>case</span> <span class=nx>err</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>errc</span><span class=p>:</span>
            <span class=k>return</span> <span class=nx>err</span>
        <span class=c1>// watch函数返回的是一个chan，通过这个chan持续的读取对象
</span><span class=c1></span>        <span class=k>case</span> <span class=nx>event</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>w</span><span class=p>.</span><span class=nf>ResultChan</span><span class=p>():</span>
            <span class=c1>// 如果不OK，说明chan关闭了，就要重新获取，这里面我们可以推测这个chan可能会运行过程中重新创建
</span><span class=c1></span>            <span class=c1>// 否则就应该退出而不是继续循环
</span><span class=c1></span>            <span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
                <span class=k>break</span> <span class=nx>loop</span>
            <span class=p>}</span>
            <span class=c1>// 看来event可以作为错误的返回值，挺有意思，而不是通过关闭chan，这种方式可以传递错误信息，关闭chan做不到
</span><span class=c1></span>            <span class=k>if</span> <span class=nx>event</span><span class=p>.</span><span class=nx>Type</span> <span class=o>==</span> <span class=nx>watch</span><span class=p>.</span><span class=nx>Error</span> <span class=p>{</span>
                <span class=k>return</span> <span class=nx>apierrs</span><span class=p>.</span><span class=nf>FromObject</span><span class=p>(</span><span class=nx>event</span><span class=p>.</span><span class=nx>Object</span><span class=p>)</span>
            <span class=p>}</span>
            <span class=c1>// 这里面就是利用反射实例化对象了，而且判断了对象类型是我们设定的类型
</span><span class=c1></span>            <span class=k>if</span> <span class=nx>e</span><span class=p>,</span> <span class=nx>a</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>expectedType</span><span class=p>,</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>TypeOf</span><span class=p>(</span><span class=nx>event</span><span class=p>.</span><span class=nx>Object</span><span class=p>);</span> <span class=nx>e</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>e</span> <span class=o>!=</span> <span class=nx>a</span> <span class=p>{</span>
                <span class=nx>utilruntime</span><span class=p>.</span><span class=nf>HandleError</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;%s: expected type %v, but watch event object had type %v&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span> <span class=nx>e</span><span class=p>,</span> <span class=nx>a</span><span class=p>))</span>
                <span class=k>continue</span>
            <span class=p>}</span>
            <span class=c1>// 和list操作相似，也要获取对象的版本，要更新缓存中的版本，下次watch就可以忽略这些资源了
</span><span class=c1></span>            <span class=nx>meta</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>meta</span><span class=p>.</span><span class=nf>Accessor</span><span class=p>(</span><span class=nx>event</span><span class=p>.</span><span class=nx>Object</span><span class=p>)</span>
            <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
                <span class=nx>utilruntime</span><span class=p>.</span><span class=nf>HandleError</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;%s: unable to understand watch event %#v&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span> <span class=nx>event</span><span class=p>))</span>
                <span class=k>continue</span>
            <span class=p>}</span>
            <span class=nx>newResourceVersion</span> <span class=o>:=</span> <span class=nx>meta</span><span class=p>.</span><span class=nf>GetResourceVersion</span><span class=p>()</span>
            <span class=c1>// 根据事件的类型做不同的DeltaFIFO的操作
</span><span class=c1></span>            <span class=k>switch</span> <span class=nx>event</span><span class=p>.</span><span class=nx>Type</span> <span class=p>{</span>
            <span class=c1>// 向DeltaFIFO添加一个添加的Delta
</span><span class=c1></span>            <span class=k>case</span> <span class=nx>watch</span><span class=p>.</span><span class=nx>Added</span><span class=p>:</span>
                <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>store</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=nx>event</span><span class=p>.</span><span class=nx>Object</span><span class=p>)</span>
                <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
                    <span class=nx>utilruntime</span><span class=p>.</span><span class=nf>HandleError</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;%s: unable to add watch event object (%#v) to store: %v&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span> <span class=nx>event</span><span class=p>.</span><span class=nx>Object</span><span class=p>,</span> <span class=nx>err</span><span class=p>))</span>
                <span class=p>}</span>
            <span class=c1>// 更新对象，向DeltaFIFO添加一个更新的Delta
</span><span class=c1></span>            <span class=k>case</span> <span class=nx>watch</span><span class=p>.</span><span class=nx>Modified</span><span class=p>:</span>
                <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>store</span><span class=p>.</span><span class=nf>Update</span><span class=p>(</span><span class=nx>event</span><span class=p>.</span><span class=nx>Object</span><span class=p>)</span>
                <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
                    <span class=nx>utilruntime</span><span class=p>.</span><span class=nf>HandleError</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;%s: unable to update watch event object (%#v) to store: %v&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span> <span class=nx>event</span><span class=p>.</span><span class=nx>Object</span><span class=p>,</span> <span class=nx>err</span><span class=p>))</span>
            <span class=p>}</span>
            <span class=c1>// 删除对象，向DeltaFIFO添加一个删除的Delta
</span><span class=c1></span>            <span class=k>case</span> <span class=nx>watch</span><span class=p>.</span><span class=nx>Deleted</span><span class=p>:</span>
                <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>store</span><span class=p>.</span><span class=nf>Delete</span><span class=p>(</span><span class=nx>event</span><span class=p>.</span><span class=nx>Object</span><span class=p>)</span>
                <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
                    <span class=nx>utilruntime</span><span class=p>.</span><span class=nf>HandleError</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;%s: unable to delete watch event object (%#v) from store: %v&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span> <span class=nx>event</span><span class=p>.</span><span class=nx>Object</span><span class=p>,</span> <span class=nx>err</span><span class=p>))</span>
            <span class=p>}</span>
            <span class=c1>// 其他类型就不知道干什么了，只能报错
</span><span class=c1></span>            <span class=k>default</span><span class=p>:</span>
            <span class=nx>utilruntime</span><span class=p>.</span><span class=nf>HandleError</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;%s: unable to understand watch event %#v&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span> <span class=nx>event</span><span class=p>))</span>
            <span class=p>}</span>
            <span class=c1>// 更新最新资源版本
</span><span class=c1></span>            <span class=o>*</span><span class=nx>resourceVersion</span> <span class=p>=</span> <span class=nx>newResourceVersion</span>
            <span class=nx>r</span><span class=p>.</span><span class=nf>setLastSyncResourceVersion</span><span class=p>(</span><span class=nx>newResourceVersion</span><span class=p>)</span>
            <span class=nx>eventCount</span><span class=o>++</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=c1>// watch返回时间非常短而且没有任何事件要处理，这个属于异常现象，因为我们watch是设置了超时的
</span><span class=c1></span>    <span class=nx>watchDuration</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>clock</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Sub</span><span class=p>(</span><span class=nx>start</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>watchDuration</span> <span class=p>&lt;</span> <span class=mi>1</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>&amp;&amp;</span> <span class=nx>eventCount</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
        <span class=nx>r</span><span class=p>.</span><span class=nx>metrics</span><span class=p>.</span><span class=nx>numberOfShortWatches</span><span class=p>.</span><span class=nf>Inc</span><span class=p>()</span>
        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;very short watch: %s: Unexpected watch close - watch lasted less than a second and no items received&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>name</span><span class=p>)</span>
    <span class=p>}</span>
 
    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>


</code></pre></td></tr></table></div></div><h4 id=resyncchan>resyncChan</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// 代码源自client-go/tools/cache/reflector.go
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>Reflector</span><span class=p>)</span> <span class=nf>setLastSyncResourceVersion</span><span class=p>(</span><span class=nx>v</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 设置已经获取到资源的最新版本
</span><span class=c1></span>    <span class=nx>r</span><span class=p>.</span><span class=nx>lastSyncResourceVersionMutex</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lastSyncResourceVersionMutex</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
    <span class=nx>r</span><span class=p>.</span><span class=nx>lastSyncResourceVersion</span> <span class=p>=</span> <span class=nx>v</span>
 
    <span class=nx>rv</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>Atoi</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>r</span><span class=p>.</span><span class=nx>metrics</span><span class=p>.</span><span class=nx>lastResourceVersion</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=nb>float64</span><span class=p>(</span><span class=nx>rv</span><span class=p>))</span>
    <span class=p>}</span>
<span class=p>}</span>
 
<span class=c1>// 获取resync定时器，叫定时器比较好理解，叫chan很难和定时关联起来
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>Reflector</span><span class=p>)</span> <span class=nf>resyncChan</span><span class=p>()</span> <span class=p>(</span><span class=o>&lt;-</span><span class=kd>chan</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 如果resyncPeriod说明就不用定时同步，返回的是永久超时的定时器
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>r</span><span class=p>.</span><span class=nx>resyncPeriod</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>neverExitWatch</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span> <span class=k>return</span> <span class=kc>false</span> <span class=p>}</span>
    <span class=p>}</span>
    <span class=c1>// 构建定时起
</span><span class=c1></span>    <span class=nx>t</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>clock</span><span class=p>.</span><span class=nf>NewTimer</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>resyncPeriod</span><span class=p>)</span>
    <span class=k>return</span> <span class=nx>t</span><span class=p>.</span><span class=nf>C</span><span class=p>(),</span> <span class=nx>t</span><span class=p>.</span><span class=nx>Stop</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><h3 id=说明>说明</h3><ol><li>Reflector利用apiserver的client列举全量对象(版本为0以后的对象全部列举出来)</li><li>将全量对象采用Replace()接口同步到DeltaFIFO中，并且更新资源的版本号，这个版本号后续会用到；</li><li>开启一个协程定时执行resync，如果没有设置定时同步则不会执行，同步就是把全量对象以同步事件的方式通知出去；<strong>注意：这个resync操作不是跟apiserver的交互操作</strong></li><li>通过apiserver的client监控(watch)资源，监控的当前资源版本号以后的对象，因为之前的都已经获取到了；</li><li>一旦有对象发生变化，那么就会根据变化的类型(新增、更新、删除)调用DeltaFIFO的相应接口，产生一个相应的对象Delta，同时更新当前资源的版本；</li></ol><h2 id=controller>Controller</h2><p>这里的controller定义在client-go/tools/cache/controller.go中，目的是用来把Reflector、DeltaFIFO组合起来形成一个相对固定的、标准的处理流程。理解了Controller，基本就算把SharedInfomer差不多搞懂了。</p><p>实际上informer本质上就是个controller</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>
<span class=c1>// 代码源自client-go/tools/cache/controller.go
</span><span class=c1>// 这是一个Controller的抽象
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Controller</span> <span class=kd>interface</span> <span class=p>{</span>
    <span class=nf>Run</span><span class=p>(</span><span class=nx>stopCh</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>      <span class=c1>// 核心流程函数
</span><span class=c1></span>    <span class=nf>HasSynced</span><span class=p>()</span> <span class=kt>bool</span>                 <span class=c1>// apiserver中的对象是否已经同步到了Store中
</span><span class=c1></span>    <span class=nf>LastSyncResourceVersion</span><span class=p>()</span> <span class=kt>string</span> <span class=c1>// 最新的资源版本号
</span><span class=c1></span><span class=p>}</span>


<span class=kd>type</span> <span class=nx>Config</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>Queue</span>                          <span class=c1>// SharedInformer使用DeltaFIFO
</span><span class=c1></span>    <span class=nx>ListerWatcher</span>                  <span class=c1>// 这个用来构造Reflector
</span><span class=c1></span>    <span class=nx>Process</span> <span class=nx>ProcessFunc</span>            <span class=c1>// 这个在调用DeltaFIFO.Pop()使用，弹出对象要如何处理
</span><span class=c1></span>    <span class=nx>ObjectType</span> <span class=nx>runtime</span><span class=p>.</span><span class=nx>Object</span>      <span class=c1>// 对象类型，这个肯定是Reflector使用
</span><span class=c1></span>    <span class=nx>FullResyncPeriod</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span> <span class=c1>// 全量同步周期，这个在Reflector使用
</span><span class=c1></span>    <span class=nx>ShouldResync</span> <span class=nx>ShouldResyncFunc</span>  <span class=c1>// Reflector在全量更新的时候会调用该函数询问
</span><span class=c1></span>    <span class=nx>RetryOnError</span> <span class=kt>bool</span>              <span class=c1>// 错误是否需要尝试
</span><span class=c1></span><span class=p>}</span>


</code></pre></td></tr></table></div></div><p>从上面的定义来看，HasSynced()可调用DeltaFIFO. HasSynced()实现，LastSyncResourceVersion()可以通过Reflector实现。因为Controller把多个模块整合起来实现了一套业务逻辑，所以在创建Controller需要提供一些配置</p><p>从上面两个类型的定义我们可以猜测：Controller自己构造Reflector获取对象，Reflector作为DeltaFIFO生产者持续监控apiserver的资源变化并推送到队列中。Controller的Run()应该是队列的消费者，从队列中弹出对象并调用Process()处理。所以Controller相比于Reflector因为队列的加持表现为每次有资源变化就会调用一次使用者定义的处理函数。</p><h3 id=流程处理>流程处理</h3><h4 id=run-1>Run</h4><ul><li>NewReflector，Reflector生产者，进行obj入队操作</li><li>processLoop，是消费者，进行obj出队和存储操作</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// 代码源自client-go/tools/cache/controller.go
</span><span class=c1>// controller是Controller的实现类型
</span><span class=c1></span><span class=kd>type</span> <span class=nx>controller</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>config</span>         <span class=nx>Config</span>       <span class=c1>// 配置，上面有讲解
</span><span class=c1></span>    <span class=nx>reflector</span>      <span class=o>*</span><span class=nx>Reflector</span>   <span class=c1>// 反射器
</span><span class=c1></span>    <span class=nx>reflectorMutex</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span> <span class=c1>// 反射器的锁
</span><span class=c1></span>    <span class=nx>clock</span>          <span class=nx>clock</span><span class=p>.</span><span class=nx>Clock</span>  <span class=c1>// 时钟
</span><span class=c1></span><span class=p>}</span>
<span class=c1>// 核心业务逻辑实现
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>controller</span><span class=p>)</span> <span class=nf>Run</span><span class=p>(</span><span class=nx>stopCh</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span> <span class=p>{</span>
    <span class=k>defer</span> <span class=nx>utilruntime</span><span class=p>.</span><span class=nf>HandleCrash</span><span class=p>()</span>
    <span class=c1>// 创建一个协程，如果收到系统退出的信号就关闭队列，相当于在这里析构的队列
</span><span class=c1></span>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
        <span class=o>&lt;-</span><span class=nx>stopCh</span>
        <span class=nx>c</span><span class=p>.</span><span class=nx>config</span><span class=p>.</span><span class=nx>Queue</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
    <span class=p>}()</span>
    <span class=c1>// 创建Reflector
</span><span class=c1></span>    <span class=nx>r</span> <span class=o>:=</span> <span class=nf>NewReflector</span><span class=p>(</span>
        <span class=nx>c</span><span class=p>.</span><span class=nx>config</span><span class=p>.</span><span class=nx>ListerWatcher</span><span class=p>,</span>
        <span class=nx>c</span><span class=p>.</span><span class=nx>config</span><span class=p>.</span><span class=nx>ObjectType</span><span class=p>,</span>
        <span class=nx>c</span><span class=p>.</span><span class=nx>config</span><span class=p>.</span><span class=nx>Queue</span><span class=p>,</span>
        <span class=nx>c</span><span class=p>.</span><span class=nx>config</span><span class=p>.</span><span class=nx>FullResyncPeriod</span><span class=p>,</span>
    <span class=p>)</span>
    <span class=c1>// r.ShouldResync的存在就是为了以后使用少些一点代码？否则直接使用c.config.ShouldResync不就完了么？不明白用意
</span><span class=c1></span>    <span class=nx>r</span><span class=p>.</span><span class=nx>ShouldResync</span> <span class=p>=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>config</span><span class=p>.</span><span class=nx>ShouldResync</span>
    <span class=nx>r</span><span class=p>.</span><span class=nx>clock</span> <span class=p>=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>clock</span>
    <span class=c1>// 记录反射器
</span><span class=c1></span>    <span class=nx>c</span><span class=p>.</span><span class=nx>reflectorMutex</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=nx>c</span><span class=p>.</span><span class=nx>reflector</span> <span class=p>=</span> <span class=nx>r</span>
    <span class=nx>c</span><span class=p>.</span><span class=nx>reflectorMutex</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
    <span class=c1>// wait.Group不是本章的讲解内容，只要把它理解为类似barrier就行了
</span><span class=c1></span>    <span class=c1>// 被他管理的所有的协程都退出后调用Wait()才会退出，否则就会被阻塞
</span><span class=c1></span>    <span class=kd>var</span> <span class=nx>wg</span> <span class=nx>wait</span><span class=p>.</span><span class=nx>Group</span>
    <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
    <span class=c1>// StartWithChannel()会启动协程执行Reflector.Run()，同时接收到stopCh信号就会退出协程
</span><span class=c1></span>    <span class=nx>wg</span><span class=p>.</span><span class=nf>StartWithChannel</span><span class=p>(</span><span class=nx>stopCh</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>Run</span><span class=p>)</span>
    <span class=c1>// wait.Until()在前面的章节讲过了，周期性的调用c.processLoop()，这里来看是1秒
</span><span class=c1></span>    <span class=c1>// 不用担心调用频率太高，正常情况下c.processLoop是不会返回的，除非遇到了解决不了的错误，因为他是个循环
</span><span class=c1></span>    <span class=nx>wait</span><span class=p>.</span><span class=nf>Until</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>processLoop</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>,</span> <span class=nx>stopCh</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h4 id=processloop>processLoop</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// 代码源自client-go/tools/cache/controller.go
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>controller</span><span class=p>)</span> <span class=nf>processLoop</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>for</span> <span class=p>{</span>
        <span class=c1>// 从队列中弹出一个对象，然后处理它,这才是最主要的部分，这个c.config.Process是构造Controller的时候通过Config传进来的
</span><span class=c1></span>        <span class=c1>// 所以这个读者要特别注意了，这个函数其实是ShareInformer传进来的，所以在分析SharedInformer的时候要重点分析的
</span><span class=c1></span>        <span class=c1>// 核心处理逻辑实现在了Process函数中了
</span><span class=c1></span>        <span class=nx>obj</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>config</span><span class=p>.</span><span class=nx>Queue</span><span class=p>.</span><span class=nf>Pop</span><span class=p>(</span><span class=nf>PopProcessFunc</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>config</span><span class=p>.</span><span class=nx>Process</span><span class=p>))</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=c1>// 如果FIFO关闭了那就退出
</span><span class=c1></span>            <span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=nx>FIFOClosedError</span> <span class=p>{</span>
                <span class=k>return</span>
            <span class=p>}</span>
            <span class=c1>// 如果错误可以再试试
</span><span class=c1></span>            <span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>config</span><span class=p>.</span><span class=nx>RetryOnError</span> <span class=p>{</span>
                <span class=nx>c</span><span class=p>.</span><span class=nx>config</span><span class=p>.</span><span class=nx>Queue</span><span class=p>.</span><span class=nf>AddIfNotPresent</span><span class=p>(</span><span class=nx>obj</span><span class=p>)</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h4 id=hassynced>HasSynced</h4><p>HasSynced 表示队列中的全量对象都已同步完成</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// 代码源自client-go/tools/cache/controller.go
</span><span class=c1></span>
<span class=c1>// Returns true once this controller has completed an initial resource listing
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>controller</span><span class=p>)</span> <span class=nf>HasSynced</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>c</span><span class=p>.</span><span class=nx>config</span><span class=p>.</span><span class=nx>Queue</span><span class=p>.</span><span class=nf>HasSynced</span><span class=p>()</span>
<span class=p>}</span>


<span class=c1>// Return true if an Add/Update/Delete/AddIfNotPresent are called first,
</span><span class=c1>// or an Update called first but the first batch of items inserted by Replace() has been popped
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>DeltaFIFO</span><span class=p>)</span> <span class=nf>HasSynced</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
    <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
    <span class=c1>// 这里就比较明白了，一次同步全量对象后，并且全部Pop()出去才能算是同步完成
</span><span class=c1></span>    <span class=c1>// 其实这里所谓的同步就是全量内容已经进入Indexer，Indexer已经是系统中对象的全量快照了
</span><span class=c1></span>    <span class=k>return</span> <span class=nx>f</span><span class=p>.</span><span class=nx>populated</span> <span class=o>&amp;&amp;</span> <span class=nx>f</span><span class=p>.</span><span class=nx>initialPopulationCount</span> <span class=o>==</span> <span class=mi>0</span>
<span class=p>}</span>


</code></pre></td></tr></table></div></div><h2 id=sharedinformer>SharedInformer</h2><h3 id=sharedinformer接口>SharedInformer接口</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>
<span class=c1>// 代码源自client-go/tools/cache/shared_informer.go
</span><span class=c1></span><span class=kd>type</span> <span class=nx>SharedInformer</span> <span class=kd>interface</span> <span class=p>{</span>
    <span class=c1>// 添加资源事件处理器，关于ResourceEventHandler的定义在下面
</span><span class=c1></span>    <span class=c1>// 相当于注册回调函数，当有资源变化就会通过回调通知使用者，是不是能和上面介绍的Controller可以联系上了？
</span><span class=c1></span>    <span class=c1>// 为什么是Add不是Reg，说明可以支持多个handler
</span><span class=c1></span>    <span class=nf>AddEventHandler</span><span class=p>(</span><span class=nx>handler</span> <span class=nx>ResourceEventHandler</span><span class=p>)</span>
    <span class=c1>// 上面添加的是不需要周期同步的处理器，下面的接口添加的是需要周期同步的处理器，周期同步上面提了好多遍了，不赘述
</span><span class=c1></span>    <span class=nf>AddEventHandlerWithResyncPeriod</span><span class=p>(</span><span class=nx>handler</span> <span class=nx>ResourceEventHandler</span><span class=p>,</span> <span class=nx>resyncPeriod</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span><span class=p>)</span>
    <span class=c1>// Store这个有专门的文章介绍，这个函数就是获取Store的接口,说明SharedInformer内有Store对象
</span><span class=c1></span>    <span class=nf>GetStore</span><span class=p>()</span> <span class=nx>Store</span>
    <span class=c1>// Controller在上面的章节介绍了，说明SharedInformer内有Controller对象
</span><span class=c1></span>    <span class=nf>GetController</span><span class=p>()</span> <span class=nx>Controller</span>
    <span class=c1>// 这个应该是SharedInformer的核心逻辑实现的地方
</span><span class=c1></span>    <span class=nf>Run</span><span class=p>(</span><span class=nx>stopCh</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
    <span class=c1>// 因为有Store，这个函数就是告知使用者Store里面是否已经同步了apiserver的资源，这个接口很有用
</span><span class=c1></span>    <span class=c1>// 当创建完SharedInformer后，通过Reflector从apiserver同步全量对象，然后在通过DeltaFIFO一个一个的同志到cache
</span><span class=c1></span>    <span class=c1>// 这个接口就是告知使用者，全量的对象是不是已经同步到了cache，这样就可以从cache列举或者查询了
</span><span class=c1></span>    <span class=nf>HasSynced</span><span class=p>()</span> <span class=kt>bool</span>
    <span class=c1>// 最新同步资源的版本，这个就不多说了，通过Controller(Controller通过Reflector)实现
</span><span class=c1></span>    <span class=nf>LastSyncResourceVersion</span><span class=p>()</span> <span class=kt>string</span>
<span class=p>}</span>
<span class=c1>// 扩展了SharedInformer类型，从类型名字上看共享的是Indexer，Indexer也是一种Store的实现
</span><span class=c1></span><span class=kd>type</span> <span class=nx>SharedIndexInformer</span> <span class=kd>interface</span> <span class=p>{</span>
    <span class=c1>// 继承了SharedInformer
</span><span class=c1></span>    <span class=nx>SharedInformer</span>
    <span class=c1>// 扩展了Indexer相关的接口
</span><span class=c1></span>    <span class=nf>AddIndexers</span><span class=p>(</span><span class=nx>indexers</span> <span class=nx>Indexers</span><span class=p>)</span> <span class=kt>error</span>
    <span class=nf>GetIndexer</span><span class=p>()</span> <span class=nx>Indexer</span>
<span class=p>}</span>
<span class=c1>// 代码源自client-go/tools/cache/controller.go，SharedInformer使用者如果需要处理资源的事件
</span><span class=c1>// 那么就要自己实现相应的回调函数
</span><span class=c1></span><span class=kd>type</span> <span class=nx>ResourceEventHandler</span> <span class=kd>interface</span> <span class=p>{</span>
    <span class=c1>// 添加对象回调函数
</span><span class=c1></span>    <span class=nf>OnAdd</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span>
    <span class=c1>// 更新对象回调函数
</span><span class=c1></span>    <span class=nf>OnUpdate</span><span class=p>(</span><span class=nx>oldObj</span><span class=p>,</span> <span class=nx>newObj</span> <span class=kd>interface</span><span class=p>{})</span>
    <span class=c1>// 删除对象回调函数
</span><span class=c1></span>    <span class=nf>OnDelete</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><h3 id=sharedindexinformer类>sharedIndexInformer类</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>
<span class=c1>// 代码源自client-go/tools/cache/shared_informer.go
</span><span class=c1></span><span class=kd>type</span> <span class=nx>sharedIndexInformer</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=c1>// Indexer也是一种Store，这个我们知道的，Controller负责把Reflector和FIFO逻辑串联起来
</span><span class=c1></span>    <span class=c1>// 所以这两个变量就涵盖了开篇那张图里面的Reflector、DeltaFIFO和LocalStore(cache)
</span><span class=c1></span>    <span class=nx>indexer</span>    <span class=nx>Indexer</span>
    <span class=nx>controller</span> <span class=nx>Controller</span>
    <span class=c1>// sharedIndexInformer把上面提到的ResourceEventHandler进行了在层封装，并统一由sharedProcessor管理，后面章节专门介绍
</span><span class=c1></span>    <span class=nx>processor</span>             <span class=o>*</span><span class=nx>sharedProcessor</span>
    <span class=c1>// CacheMutationDetector其实没啥用，我理解是开发者自己实现的一个调试工具，用来发现对象突变的
</span><span class=c1></span>    <span class=c1>// 实现方法也比较简单，DeltaFIFO弹出的对象在处理前先备份(深度拷贝)一份，然后定期比对两个对象是否相同
</span><span class=c1></span>    <span class=c1>// 如果不同那就报警，说明处理过程中有人修改过对象，这个功能默认是关闭，所以我说没啥用
</span><span class=c1></span>    <span class=nx>cacheMutationDetector</span> <span class=nx>CacheMutationDetector</span>
    <span class=c1>// 这两个变量是给Reflector用的，我们知道Reflector是在Controller创建的
</span><span class=c1></span>    <span class=nx>listerWatcher</span> <span class=nx>ListerWatcher</span>
    <span class=nx>objectType</span>    <span class=nx>runtime</span><span class=p>.</span><span class=nx>Object</span>
    <span class=c1>// 定期同步的周期，因为可能存在多个ResourceEventHandler，就有可能存在多个同步周期，sharedIndexInformer采用最小的周期
</span><span class=c1></span>    <span class=c1>// 这个周期值就存储在resyncCheckPeriod中，通过AddEventHandler()添加的处理器都采用defaultEventHandlerResyncPeriod
</span><span class=c1></span>    <span class=nx>resyncCheckPeriod</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span>
    <span class=nx>defaultEventHandlerResyncPeriod</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span>
    <span class=c1>// 时钟
</span><span class=c1></span>    <span class=nx>clock</span> <span class=nx>clock</span><span class=p>.</span><span class=nx>Clock</span>
    <span class=c1>// 启动、停止标记，肯定有人会问为啥用两个变量，一个变量不就可以实现启动和停止了么？
</span><span class=c1></span>    <span class=c1>// 其实此处是三个状态，启动前，已启动和已停止，start表示了两个状态，而且为启动标记专门做了个锁
</span><span class=c1></span>    <span class=c1>// 说明启动前和启动后有互斥的资源操作
</span><span class=c1></span>    <span class=nx>started</span><span class=p>,</span> <span class=nx>stopped</span> <span class=kt>bool</span>
    <span class=nx>startedLock</span>      <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
 
    <span class=c1>// 这个名字起的也是够了，因为DeltaFIFO每次Pop()的时候需要传入一个函数用来处理Deltas
</span><span class=c1></span>    <span class=c1>// 处理Deltas也就意味着要把消息通知给处理器，如果此时调用了AddEventHandler()
</span><span class=c1></span>    <span class=c1>// 就会存在崩溃的问题，所以要有这个锁，阻塞Deltas....细想名字也没毛病~
</span><span class=c1></span>    <span class=nx>blockDeltas</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><h3 id=cachemutationdetector-非重要可忽略>CacheMutationDetector 【非重要，可忽略】</h3><p>CacheMutationDetector这个就是检测对象在过程中突变的，何所谓突变呢？突变就是莫名其妙的修改了，如何实现突变检测，也是比较简单的。CacheMutationDetector对所有的对象做了一次深度拷贝(DeepCopy)，然后定期比较两个对象是否一致，当发现有不同时说明对象突变了，然后就panic。我认为CacheMutationDetector是用来调试的，因为代码默认是关闭的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// 代码源自client-go/tools/cache/mutation_detector.go
</span><span class=c1>// 默认关闭突变检测
</span><span class=c1></span><span class=kd>var</span> <span class=nx>mutationDetectionEnabled</span> <span class=p>=</span> <span class=kc>false</span>
<span class=c1>// 但是可以通过环境变量的KUBE_CACHE_MUTATION_DETECTOR开启
</span><span class=c1></span><span class=kd>func</span> <span class=nf>init</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>mutationDetectionEnabled</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>ParseBool</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;KUBE_CACHE_MUTATION_DETECTOR&#34;</span><span class=p>))</span>
<span class=p>}</span>
 
<span class=c1>// 这个是突变检测的类型抽象
</span><span class=c1></span><span class=kd>type</span> <span class=nx>CacheMutationDetector</span> <span class=kd>interface</span> <span class=p>{</span>
    <span class=nf>AddObject</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span>  <span class=c1>// 用于记录所有的对象
</span><span class=c1></span>    <span class=nf>Run</span><span class=p>(</span><span class=nx>stopCh</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span> <span class=c1>// 开启协程定期比对
</span><span class=c1></span><span class=p>}</span>
<span class=c1>// 创建CacheMutationDetector对象
</span><span class=c1></span><span class=kd>func</span> <span class=nf>NewCacheMutationDetector</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>)</span> <span class=nx>CacheMutationDetector</span> <span class=p>{</span>
    <span class=c1>// 如果没有开启选项就构造一个什么都不做的对象
</span><span class=c1></span>    <span class=k>if</span> <span class=p>!</span><span class=nx>mutationDetectionEnabled</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>dummyMutationDetector</span><span class=p>{}</span>
    <span class=p>}</span>
    <span class=c1>// 如果开启了选项，那么就构造一个默认的突变检测器
</span><span class=c1></span>    <span class=nx>glog</span><span class=p>.</span><span class=nf>Warningln</span><span class=p>(</span><span class=s>&#34;Mutation detector is enabled, this will result in memory leakage.&#34;</span><span class=p>)</span>
    <span class=k>return</span> <span class=o>&amp;</span><span class=nx>defaultCacheMutationDetector</span><span class=p>{</span><span class=nx>name</span><span class=p>:</span> <span class=nx>name</span><span class=p>,</span> <span class=nx>period</span><span class=p>:</span> <span class=mi>1</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>}</span>
<span class=p>}</span>
<span class=c1>// 这就是什么都不做的突变检测器
</span><span class=c1></span><span class=kd>type</span> <span class=nx>dummyMutationDetector</span> <span class=kd>struct</span><span class=p>{}</span>
<span class=kd>func</span> <span class=p>(</span><span class=nx>dummyMutationDetector</span><span class=p>)</span> <span class=nf>Run</span><span class=p>(</span><span class=nx>stopCh</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span> <span class=p>{</span>
<span class=p>}</span>
<span class=kd>func</span> <span class=p>(</span><span class=nx>dummyMutationDetector</span><span class=p>)</span> <span class=nf>AddObject</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h3 id=sharedprocessor>sharedProcessor</h3><p>有没有感觉shared这个词被kubernetes玩儿坏了(继controller之后有一个背玩儿坏的单词)，sharedProcessor这又shared啥了？首先需要知道Processor的定义，这里定义的Processor就是处理事件的东西。什么事件，就是SharedInformer向外部通知的事件。因为官方代码没有注释，我猜是shared是同一个SharedInformer，有没有很绕嘴？还有更绕的在后面呢，我们还要了解一个新的类型，那就是processorListener，processor刚说完，又来了个Listener！</p><p>通过SharedInformer.AddEventHandler()添加的处理器最终就会封装成processorListener，然后通过sharedProcessor管理起来，通过processorListener的封装就可以达到所谓的有事处理，没事挂起。</p><h4 id=processorlistener>processorListener</h4><p>rocessorListener可以理解为两个核心功能，一个是processor，一个是listener，用一句话概括，有事做事没事挂起。先看看processorListener的定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// 代码源自clien-go/tools/cache/shared_informer.go
</span><span class=c1></span><span class=kd>type</span> <span class=nx>processorListener</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=c1>// nextCh、addCh、handler、pendingNotifications的用法请参看我的《golang的chan有趣用法》里面有相关的例子
</span><span class=c1></span>    <span class=c1>// 总结这四个变量实现了事件的输入、缓冲、处理，事件就是apiserver资源的变化
</span><span class=c1></span>    <span class=nx>nextCh</span> <span class=kd>chan</span> <span class=kd>interface</span><span class=p>{}</span>
    <span class=nx>addCh</span>  <span class=kd>chan</span> <span class=kd>interface</span><span class=p>{}</span>
    <span class=nx>handler</span> <span class=nx>ResourceEventHandler</span>
    <span class=nx>pendingNotifications</span> <span class=nx>buffer</span><span class=p>.</span><span class=nx>RingGrowing</span>
    <span class=c1>// 下面四个变量就是跟定时同步相关的了，requestedResyncPeriod是处理器设定的定时同步周期
</span><span class=c1></span>    <span class=c1>// resyncPeriod是跟sharedIndexInformer对齐的同步时间，因为sharedIndexInformer管理了多个处理器
</span><span class=c1></span>    <span class=c1>// 最终所有的处理器都会对齐到一个周期上，nextResync就是下一次同步的时间点
</span><span class=c1></span>    <span class=nx>requestedResyncPeriod</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span>
    <span class=nx>resyncPeriod</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span>
    <span class=nx>nextResync</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span>
    <span class=nx>resyncLock</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>我们需要知道就是processor如何接收事件(此处事件就是apiserver的资源变化，也就是DeltaFIFO输出的Deltas)？如何通知事件处理器？如何缓冲处理器？如何阻塞处理器进而形成listener的？一系列的问题我们需要沿着处理逻辑的流程逐一解释。第一个问题，事件是如何传入的:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// 代码源自client-go/tools/cache/shared_informer.go
</span><span class=c1>// 对，就这么简单，通过addCh传入，这里面的notification就是我们所谓的事件
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>processorListener</span><span class=p>)</span> <span class=nf>add</span><span class=p>(</span><span class=nx>notification</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
    <span class=nx>p</span><span class=p>.</span><span class=nx>addCh</span> <span class=o>&lt;-</span> <span class=nx>notification</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>因为addCh是无缓冲chan，调用add()函数的人是事件分发器processor.distribute。意思就是从DeltaFIFO弹出的Deltas要要逐一送到多个处理器，此时如果处理器没有及时处理会造成addCh把分发器阻塞，那别的处理器也就同样无法收到新的事件了。这一点，processorListener利用一个后台协程处理这个问题(相应的原理参看《golang的chan有趣用法》)：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>
<span class=c1>// 代码源自client-go/tools/cache/shared_informer.go
</span><span class=c1>// 这个函数是通过sharedProcessor利用wait.Group启动的，读者可以自行查看wait.Group
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>processorListener</span><span class=p>)</span> <span class=nf>pop</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>defer</span> <span class=nx>utilruntime</span><span class=p>.</span><span class=nf>HandleCrash</span><span class=p>()</span>
    <span class=c1>// nextCh是在这里，函数退出前析构的
</span><span class=c1></span>    <span class=k>defer</span> <span class=nb>close</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>nextCh</span><span class=p>)</span>
    <span class=c1>// 临时变量，下面会用到
</span><span class=c1></span>    <span class=kd>var</span> <span class=nx>nextCh</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=kd>interface</span><span class=p>{}</span>
    <span class=kd>var</span> <span class=nx>notification</span> <span class=kd>interface</span><span class=p>{}</span>
    <span class=c1>// 进入死循环啦
</span><span class=c1></span>    <span class=k>for</span> <span class=p>{</span>
        <span class=k>select</span> <span class=p>{</span>
        <span class=c1>// 有两种情况，nextCh还没有初始化，这个语句就会被阻塞，这个我在《深入浅出golang之chan》说过
</span><span class=c1></span>        <span class=c1>// nextChan后面会赋值为p.nextCh，因为p.nextCh也是无缓冲的chan，数据不发送成功就阻塞                        
</span><span class=c1></span>        <span class=k>case</span> <span class=nx>nextCh</span> <span class=o>&lt;-</span> <span class=nx>notification</span><span class=p>:</span>
            <span class=c1>// 如果发送成功了，那就从缓冲中再取一个事件出来
</span><span class=c1></span>            <span class=kd>var</span> <span class=nx>ok</span> <span class=kt>bool</span>
            <span class=nx>notification</span><span class=p>,</span> <span class=nx>ok</span> <span class=p>=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>pendingNotifications</span><span class=p>.</span><span class=nf>ReadOne</span><span class=p>()</span>
            <span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
                <span class=c1>// 如果没有事件，那就把nextCh再次设置为nil，接下来对于nextCh操作还会被阻塞
</span><span class=c1></span>                <span class=nx>nextCh</span> <span class=p>=</span> <span class=kc>nil</span>
            <span class=p>}</span>
        <span class=c1>// 从p.addCh读取一个事件出来，这回看到消费p.addCh的地方了
</span><span class=c1></span>        <span class=k>case</span> <span class=nx>notificationToAdd</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>p</span><span class=p>.</span><span class=nx>addCh</span><span class=p>:</span>
            <span class=c1>// 说明p.addCh关闭了，只能退出
</span><span class=c1></span>            <span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
                <span class=k>return</span>
            <span class=p>}</span>
            <span class=c1>// notification为空说明当前还没发送任何事件给处理器
</span><span class=c1></span>            <span class=k>if</span> <span class=nx>notification</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
                <span class=c1>// 那就把刚刚获取的事件通过p.nextCh发送个处理器
</span><span class=c1></span>                <span class=nx>notification</span> <span class=p>=</span> <span class=nx>notificationToAdd</span>
                <span class=nx>nextCh</span> <span class=p>=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>nextCh</span>
            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
                <span class=c1>// 上一个事件还没有发送成功，那就先放到缓存中
</span><span class=c1></span>                <span class=c1>// pendingNotifications可以想象为一个slice，这样方便理解，是一个动态的缓存，
</span><span class=c1></span>                <span class=nx>p</span><span class=p>.</span><span class=nx>pendingNotifications</span><span class=p>.</span><span class=nf>WriteOne</span><span class=p>(</span><span class=nx>notificationToAdd</span><span class=p>)</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><p>pop()函数实现的非常巧妙，利用一个协程就把接收、缓冲、发送全部解决了。它充分的利用了golang的select可以同时操作多个chan的特性，同时从addChd读取数据从nextCh发送数据，这两个chan任何一个完成都可以激活协程。</p><ul><li>notification 待通知的事件，来源有2个：<ul><li>p.addCh 直接接收到的新事件</li><li>pendingNotifications已阻塞缓存的未通知发送的事件</li></ul></li><li>pendingNotifications 为缓存阻塞中的事件</li><li>pendingNotifications.WriteOne表示缓存事件</li><li>p.pendingNotifications.ReadOne表示从缓存读取事件</li><li>通过把notification 发送到 p.nextCh 表示发送</li><li>notificationToAdd 接收消费最新的p.addCh</li></ul><p>接下来，我们看看从nextCh读取事件后是如何处理的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>
<span class=c1>// 代码源自client-go/tools/cache/shared_informer.go
</span><span class=c1>// 这个也是sharedProcessor通过wait.Group启动的
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>processorListener</span><span class=p>)</span> <span class=nf>run</span><span class=p>()</span> <span class=p>{</span>
    <span class=c1>// 因为wait.Until需要传入退出信号的chan
</span><span class=c1></span>    <span class=nx>stopCh</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
    <span class=c1>// wait.Until不多说了，我在前期不点的文章中说过了，只要没有收到退出信号就会周期的执行传入的函数
</span><span class=c1></span>    <span class=nx>wait</span><span class=p>.</span><span class=nf>Until</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
        <span class=c1>// wait.ExponentialBackoff()和wait.Until()类似，wait.Until()是无限循环
</span><span class=c1></span>        <span class=c1>// wait.ExponentialBackoff()是尝试几次，每次等待时间会以指数上涨
</span><span class=c1></span>        <span class=nx>err</span> <span class=o>:=</span> <span class=nx>wait</span><span class=p>.</span><span class=nf>ExponentialBackoff</span><span class=p>(</span><span class=nx>retry</span><span class=p>.</span><span class=nx>DefaultRetry</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>(</span><span class=kt>bool</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// 这也是chan的range用法，可以参看我的《深入浅出golang的chan》了解细节
</span><span class=c1></span>            <span class=k>for</span> <span class=nx>next</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>p</span><span class=p>.</span><span class=nx>nextCh</span> <span class=p>{</span>
                <span class=c1>// 判断事件类型，这里面的handler就是调用SharedInfomer.AddEventHandler()传入的
</span><span class=c1></span>                <span class=c1>// 理论上处理的不是Deltas么？怎么变成了其他类型，这是SharedInformer做的二次封装，后面会看到
</span><span class=c1></span>                <span class=k>switch</span> <span class=nx>notification</span> <span class=o>:=</span> <span class=nx>next</span><span class=p>.(</span><span class=kd>type</span><span class=p>)</span> <span class=p>{</span>
                <span class=k>case</span> <span class=nx>updateNotification</span><span class=p>:</span>
                    <span class=nx>p</span><span class=p>.</span><span class=nx>handler</span><span class=p>.</span><span class=nf>OnUpdate</span><span class=p>(</span><span class=nx>notification</span><span class=p>.</span><span class=nx>oldObj</span><span class=p>,</span> <span class=nx>notification</span><span class=p>.</span><span class=nx>newObj</span><span class=p>)</span>
                <span class=k>case</span> <span class=nx>addNotification</span><span class=p>:</span>
                    <span class=nx>p</span><span class=p>.</span><span class=nx>handler</span><span class=p>.</span><span class=nf>OnAdd</span><span class=p>(</span><span class=nx>notification</span><span class=p>.</span><span class=nx>newObj</span><span class=p>)</span>
                <span class=k>case</span> <span class=nx>deleteNotification</span><span class=p>:</span>
                    <span class=nx>p</span><span class=p>.</span><span class=nx>handler</span><span class=p>.</span><span class=nf>OnDelete</span><span class=p>(</span><span class=nx>notification</span><span class=p>.</span><span class=nx>oldObj</span><span class=p>)</span>
                <span class=k>default</span><span class=p>:</span>
                    <span class=nx>utilruntime</span><span class=p>.</span><span class=nf>HandleError</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;unrecognized notification: %#v&#34;</span><span class=p>,</span> <span class=nx>next</span><span class=p>))</span>
                <span class=p>}</span>
            <span class=p>}</span>
 
            <span class=k>return</span> <span class=kc>true</span><span class=p>,</span> <span class=kc>nil</span>
        <span class=p>})</span>
 
        <span class=c1>// 执行到这里只能是nextCh已经被关闭了，所以关闭stopCh,通知wait.Until()退出
</span><span class=c1></span>        <span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nb>close</span><span class=p>(</span><span class=nx>stopCh</span><span class=p>)</span>
        <span class=p>}</span>
    <span class=p>},</span> <span class=mi>1</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Minute</span><span class=p>,</span> <span class=nx>stopCh</span><span class=p>)</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><p>因为processorListener其他函数没啥大用，上面两个函数就就已经把核心功能都实现了。processorListener就是实现了事件的缓冲和处理，此处的处理就是使用者传入的函数。在没有事件的时候可以阻塞处理器，当事件较多是可以把事件缓冲起来，实现了事件分发器与处理器的异步处理。</p><p>processorListener的run()和pop()函数是sharedProcessor启动的协程调用的，所以下面就要对sharedProcessor进行分析了。</p><p><strong>总结： 通过p.nextCh方式，processorListener.pop取出事件，然后提供给processorListener.run接收消费事件。这些处理都在sharedProcessor.run中实现，见下面内容。</strong></p><h4 id=sharedprocessor-1>sharedProcessor</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// client-go/tools/cache/shared_informer.go
</span><span class=c1>// sharedProcessor是通过数组组织处理器的，只是分了需要定时同步和不需要要同步两类
</span><span class=c1></span><span class=kd>type</span> <span class=nx>sharedProcessor</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>listenersStarted</span> <span class=kt>bool</span>                 <span class=c1>// 所有处理器是否已经启动的标识
</span><span class=c1></span>    <span class=nx>listenersLock</span>    <span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>         <span class=c1>// 读写锁
</span><span class=c1></span>    <span class=nx>listeners</span>        <span class=p>[]</span><span class=o>*</span><span class=nx>processorListener</span> <span class=c1>// 通用的处理器
</span><span class=c1></span>    <span class=nx>syncingListeners</span> <span class=p>[]</span><span class=o>*</span><span class=nx>processorListener</span> <span class=c1>// 需要定时同步的处理器
</span><span class=c1></span>    <span class=nx>clock</span>            <span class=nx>clock</span><span class=p>.</span><span class=nx>Clock</span>          <span class=c1>// 时钟
</span><span class=c1></span>    <span class=nx>wg</span>               <span class=nx>wait</span><span class=p>.</span><span class=nx>Group</span>           <span class=c1>// 前面讲过了processorListener每个需要两个协程，
</span><span class=c1></span>                                          <span class=c1>// 用wait.Group来管理所有处理器的携程，保证他们都能退出
</span><span class=c1></span><span class=p>}</span>

<span class=c1>// 代码源自client-go/tools/cache/shared_informer.go
</span><span class=c1>// 添加处理器，sharedIndexInformer.AddEventHandler()就会调用这个函数实现处理器的添加
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>sharedProcessor</span><span class=p>)</span> <span class=nf>addListener</span><span class=p>(</span><span class=nx>listener</span> <span class=o>*</span><span class=nx>processorListener</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 加锁，这个很好理解
</span><span class=c1></span>    <span class=nx>p</span><span class=p>.</span><span class=nx>listenersLock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>p</span><span class=p>.</span><span class=nx>listenersLock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
    <span class=c1>// 把处理器添加到数组中
</span><span class=c1></span>    <span class=nx>p</span><span class=p>.</span><span class=nf>addListenerLocked</span><span class=p>(</span><span class=nx>listener</span><span class=p>)</span>
    <span class=c1>// 通过wait.Group启动两个协程，做的事情我们在processorListener说过了，这里就是我们上面提到的启动两个协程的地方
</span><span class=c1></span>    <span class=c1>// 这个地方判断了listenersStarted，这说明sharedProcessor在启动前、后都可以添加处理器
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>p</span><span class=p>.</span><span class=nx>listenersStarted</span> <span class=p>{</span>
        <span class=nx>p</span><span class=p>.</span><span class=nx>wg</span><span class=p>.</span><span class=nf>Start</span><span class=p>(</span><span class=nx>listener</span><span class=p>.</span><span class=nx>run</span><span class=p>)</span>
        <span class=nx>p</span><span class=p>.</span><span class=nx>wg</span><span class=p>.</span><span class=nf>Start</span><span class=p>(</span><span class=nx>listener</span><span class=p>.</span><span class=nx>pop</span><span class=p>)</span>
    <span class=p>}</span>
<span class=p>}</span>
<span class=c1>// 把处理器添加到数组中
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>sharedProcessor</span><span class=p>)</span> <span class=nf>addListenerLocked</span><span class=p>(</span><span class=nx>listener</span> <span class=o>*</span><span class=nx>processorListener</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 两类(定时同步和不同步)的处理器数组都添加了，这是因为没有定时同步的也会用默认的时间，后面我们会看到
</span><span class=c1></span>    <span class=c1>// 那么问题来了，那还用两个数组干什么呢？
</span><span class=c1></span>    <span class=nx>p</span><span class=p>.</span><span class=nx>listeners</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>listeners</span><span class=p>,</span> <span class=nx>listener</span><span class=p>)</span>
    <span class=nx>p</span><span class=p>.</span><span class=nx>syncingListeners</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>syncingListeners</span><span class=p>,</span> <span class=nx>listener</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>在SharedInformer的接口中有一个与之对应的接口，就是SharedInformer.AddEventHandler()。因为SharedInformer没有删除处理器的接口，sharedProcessor也没有相应接口。接下来就是sharedProcessor的分发事件的接口：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>
<span class=c1>// 代码源自client-go/tools/cache/shared_informer.go
</span><span class=c1>// 通过函数名称也能感觉到分发的感觉~sync表示obj对象是否为同步事件对象
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>sharedProcessor</span><span class=p>)</span> <span class=nf>distribute</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{},</span> <span class=nx>sync</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 加锁没毛病
</span><span class=c1></span>    <span class=nx>p</span><span class=p>.</span><span class=nx>listenersLock</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>p</span><span class=p>.</span><span class=nx>listenersLock</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
 
    <span class=c1>// 无论是否为sync，添加处理器的代码中我们知道两个数组都会被添加，所以判断不判断没啥区别~
</span><span class=c1></span>    <span class=c1>// 所以我的猜测是代码以前实现的是明显区分两类的，但随着代码的更新二者的界限已经没那么明显了
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>sync</span> <span class=p>{</span>
        <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>listener</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>p</span><span class=p>.</span><span class=nx>syncingListeners</span> <span class=p>{</span>
            <span class=nx>listener</span><span class=p>.</span><span class=nf>add</span><span class=p>(</span><span class=nx>obj</span><span class=p>)</span>
        <span class=p>}</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>listener</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>p</span><span class=p>.</span><span class=nx>listeners</span> <span class=p>{</span>
            <span class=nx>listener</span><span class=p>.</span><span class=nf>add</span><span class=p>(</span><span class=nx>obj</span><span class=p>)</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><p>sharedProcessor运行起来后，唯一需要做的就是等待退出信号然后关闭所有的处理器，来看看具体实现代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// 代码源自client-go/tools/cache/shared_informer.go
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>sharedProcessor</span><span class=p>)</span> <span class=nf>run</span><span class=p>(</span><span class=nx>stopCh</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span> <span class=p>{</span>
    <span class=c1>// 启动前、后对于添加处理器的逻辑是不同，启动前的处理器是不会立刻启动连个协程执行处理器的pop()和run()函数的
</span><span class=c1></span>    <span class=c1>// 而是在这里统一的启动
</span><span class=c1></span>    <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
        <span class=nx>p</span><span class=p>.</span><span class=nx>listenersLock</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
        <span class=k>defer</span> <span class=nx>p</span><span class=p>.</span><span class=nx>listenersLock</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
        <span class=c1>// 遍历所有的处理器，然后为处理器启动两个后台协程
</span><span class=c1></span>        <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>listener</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>p</span><span class=p>.</span><span class=nx>listeners</span> <span class=p>{</span>
            <span class=nx>p</span><span class=p>.</span><span class=nx>wg</span><span class=p>.</span><span class=nf>Start</span><span class=p>(</span><span class=nx>listener</span><span class=p>.</span><span class=nx>run</span><span class=p>)</span>
            <span class=nx>p</span><span class=p>.</span><span class=nx>wg</span><span class=p>.</span><span class=nf>Start</span><span class=p>(</span><span class=nx>listener</span><span class=p>.</span><span class=nx>pop</span><span class=p>)</span>
        <span class=p>}</span>
        <span class=nx>p</span><span class=p>.</span><span class=nx>listenersStarted</span> <span class=p>=</span> <span class=kc>true</span>
    <span class=p>}()</span>
    <span class=c1>// 等待退出信号
</span><span class=c1></span>    <span class=o>&lt;-</span><span class=nx>stopCh</span>
    <span class=nx>p</span><span class=p>.</span><span class=nx>listenersLock</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>p</span><span class=p>.</span><span class=nx>listenersLock</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
    <span class=c1>// 关闭addCh，processorListener.pop()这个协程就会退出，不明白的可以再次回顾代码
</span><span class=c1></span>    <span class=c1>// 因为processorListener.pop()会关闭processorListener.nextCh，processorListener.run()就会退出
</span><span class=c1></span>    <span class=c1>// 所以这里只要关闭processorListener.addCh就可以自动实现两个协程的退出，不得不说设计的还是挺巧妙的
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>listener</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>p</span><span class=p>.</span><span class=nx>listeners</span> <span class=p>{</span>
        <span class=nb>close</span><span class=p>(</span><span class=nx>listener</span><span class=p>.</span><span class=nx>addCh</span><span class=p>)</span> 
    <span class=p>}</span>
    <span class=c1>// 等待所有的协程退出，这里指的所有协程就是所有处理器的那两个协程
</span><span class=c1></span>    <span class=nx>p</span><span class=p>.</span><span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h3 id=sharedinformer实现>SharedInformer实现</h3><p>client-go实现了两个创建SharedInformer的接口，如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// 代码源自client-go/tools/cache/shared_informer.go
</span><span class=c1>// lw:这个是apiserver客户端相关的，用于Reflector从apiserver获取资源，所以需要外部提供
</span><span class=c1>// objType:这个SharedInformer监控的对象类型
</span><span class=c1>// resyncPeriod:同步周期，SharedInformer需要多长时间给使用者发送一次全量对象的同步时间
</span><span class=c1></span><span class=kd>func</span> <span class=nf>NewSharedInformer</span><span class=p>(</span><span class=nx>lw</span> <span class=nx>ListerWatcher</span><span class=p>,</span> <span class=nx>objType</span> <span class=nx>runtime</span><span class=p>.</span><span class=nx>Object</span><span class=p>,</span> <span class=nx>resyncPeriod</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span><span class=p>)</span> <span class=nx>SharedInformer</span> <span class=p>{</span>
    <span class=c1>// 还是用SharedIndexInformer实现的
</span><span class=c1></span>    <span class=k>return</span> <span class=nf>NewSharedIndexInformer</span><span class=p>(</span><span class=nx>lw</span><span class=p>,</span> <span class=nx>objType</span><span class=p>,</span> <span class=nx>resyncPeriod</span><span class=p>,</span> <span class=nx>Indexers</span><span class=p>{})</span>
<span class=p>}</span>
<span class=c1>// 创建SharedIndexInformer对象，其中大部分参数再上面的函数已经介绍了
</span><span class=c1>// indexers:需要外部提供计算对象索引键的函数，也就是这里面的对象需要通过什么方式创建索引
</span><span class=c1></span><span class=kd>func</span> <span class=nf>NewSharedIndexInformer</span><span class=p>(</span><span class=nx>lw</span> <span class=nx>ListerWatcher</span><span class=p>,</span> <span class=nx>objType</span> <span class=nx>runtime</span><span class=p>.</span><span class=nx>Object</span><span class=p>,</span> <span class=nx>defaultEventHandlerResyncPeriod</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span><span class=p>,</span> <span class=nx>indexers</span> <span class=nx>Indexers</span><span class=p>)</span> <span class=nx>SharedIndexInformer</span> <span class=p>{</span>
    <span class=nx>realClock</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>clock</span><span class=p>.</span><span class=nx>RealClock</span><span class=p>{}</span>
    <span class=nx>sharedIndexInformer</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>sharedIndexInformer</span><span class=p>{</span>
        <span class=c1>// 管理所有处理器用的，这个上面的章节解释了
</span><span class=c1></span>        <span class=nx>processor</span><span class=p>:</span>                       <span class=o>&amp;</span><span class=nx>sharedProcessor</span><span class=p>{</span><span class=nx>clock</span><span class=p>:</span> <span class=nx>realClock</span><span class=p>},</span>
        <span class=c1>// 其实就是在构造cache，读者可以自行查看NewIndexer()的实现，
</span><span class=c1></span>        <span class=c1>// 在cache中的对象用DeletionHandlingMetaNamespaceKeyFunc计算对象键，用indexers计算索引键
</span><span class=c1></span>        <span class=c1>// 可以想象成每个对象键是Namespace/Name，每个索引键是Namespace，即按照Namesapce分类
</span><span class=c1></span>        <span class=c1>// 因为objType决定了只有一种类型对象，所以Namesapce是最大的分类
</span><span class=c1></span>        <span class=nx>indexer</span><span class=p>:</span>                         <span class=nf>NewIndexer</span><span class=p>(</span><span class=nx>DeletionHandlingMetaNamespaceKeyFunc</span><span class=p>,</span> <span class=nx>indexers</span><span class=p>),</span>
        <span class=c1>// 下面这两主要就是给Controller用，确切的说是给Reflector用的
</span><span class=c1></span>        <span class=nx>listerWatcher</span><span class=p>:</span>                   <span class=nx>lw</span><span class=p>,</span>
        <span class=nx>objectType</span><span class=p>:</span>                      <span class=nx>objType</span><span class=p>,</span>
        <span class=c1>// 无论是否需要定时同步，SharedInformer都提供了一个默认的同步时间，当然这个是外部设置的
</span><span class=c1></span>        <span class=nx>resyncCheckPeriod</span><span class=p>:</span>               <span class=nx>defaultEventHandlerResyncPeriod</span><span class=p>,</span>
        <span class=nx>defaultEventHandlerResyncPeriod</span><span class=p>:</span> <span class=nx>defaultEventHandlerResyncPeriod</span><span class=p>,</span>
        <span class=c1>// 默认没有开启的对象突变检测器，没啥用，也不多介绍
</span><span class=c1></span>        <span class=nx>cacheMutationDetector</span><span class=p>:</span>           <span class=nf>NewCacheMutationDetector</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;%T&#34;</span><span class=p>,</span> <span class=nx>objType</span><span class=p>)),</span>
        <span class=nx>clock</span><span class=p>:</span> <span class=nx>realClock</span><span class=p>,</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>sharedIndexInformer</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>创建完ShareInformer对象，就要添加事件处理器了：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// 代码源自client-go/tools/cache/shared_informer.go
</span><span class=c1>// 添加没有指定同步周期的事件处理器
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>sharedIndexInformer</span><span class=p>)</span> <span class=nf>AddEventHandler</span><span class=p>(</span><span class=nx>handler</span> <span class=nx>ResourceEventHandler</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// defaultEventHandlerResyncPeriod是默认的同步周期，在创建SharedInformer的时候设置的
</span><span class=c1></span>    <span class=nx>s</span><span class=p>.</span><span class=nf>AddEventHandlerWithResyncPeriod</span><span class=p>(</span><span class=nx>handler</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nx>defaultEventHandlerResyncPeriod</span><span class=p>)</span>
<span class=p>}</span>
<span class=c1>// 添加需要定期同步的事件处理器
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>sharedIndexInformer</span><span class=p>)</span> <span class=nf>AddEventHandlerWithResyncPeriod</span><span class=p>(</span><span class=nx>handler</span> <span class=nx>ResourceEventHandler</span><span class=p>,</span> <span class=nx>resyncPeriod</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 因为是否已经开始对于添加事件处理器的方式不同，后面会有介绍，所以此处加了锁
</span><span class=c1></span>    <span class=nx>s</span><span class=p>.</span><span class=nx>startedLock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>s</span><span class=p>.</span><span class=nx>startedLock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
 
    <span class=c1>// 如果已经结束了，那就可以直接返回了
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>s</span><span class=p>.</span><span class=nx>stopped</span> <span class=p>{</span>
        <span class=k>return</span>
    <span class=p>}</span>
    <span class=c1>// 如果有同步周期，==0就是永远不用同步
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>resyncPeriod</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
        <span class=c1>// 同步周期不能太短，太短对于系统来说反而是个负担，大量的无效计算浪费在这上面
</span><span class=c1></span>        <span class=k>if</span> <span class=nx>resyncPeriod</span> <span class=p>&lt;</span> <span class=nx>minimumResyncPeriod</span> <span class=p>{</span>
            <span class=nx>resyncPeriod</span> <span class=p>=</span> <span class=nx>minimumResyncPeriod</span>
        <span class=p>}</span>
        <span class=c1>// SharedInformer管理了很多处理器，每个处理器都有自己的同步周期，所以此处要统一成一个，称之为对齐
</span><span class=c1></span>        <span class=c1>// SharedInformer会选择所有处理器中最小的那个作为所有处理器的同步周期，称为对齐后的同步周期
</span><span class=c1></span>        <span class=c1>// 此处就要判断是不是比当前对齐后的同步周期还要小
</span><span class=c1></span>        <span class=k>if</span> <span class=nx>resyncPeriod</span> <span class=p>&lt;</span> <span class=nx>s</span><span class=p>.</span><span class=nx>resyncCheckPeriod</span> <span class=p>{</span>
            <span class=c1>// 如果已经启动了，那么只能用和大家一样的周期
</span><span class=c1></span>            <span class=k>if</span> <span class=nx>s</span><span class=p>.</span><span class=nx>started</span> <span class=p>{</span>
                <span class=nx>resyncPeriod</span> <span class=p>=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>resyncCheckPeriod</span>
            <span class=c1>// 如果没启动，那就让大家都用最新的对齐同步周期
</span><span class=c1></span>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
                <span class=nx>s</span><span class=p>.</span><span class=nx>resyncCheckPeriod</span> <span class=p>=</span> <span class=nx>resyncPeriod</span>
                <span class=nx>s</span><span class=p>.</span><span class=nx>processor</span><span class=p>.</span><span class=nf>resyncCheckPeriodChanged</span><span class=p>(</span><span class=nx>resyncPeriod</span><span class=p>)</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=c1>// 创建处理器，代码一直用listener,可能想强调没事件就挂起把，我反而想用处理器这个名词
</span><span class=c1></span>    <span class=c1>// determineResyncPeriod()这个函数读者自己分析把，非常简单，这里面只要知道创建了处理器就行了
</span><span class=c1></span>    <span class=nx>listener</span> <span class=o>:=</span> <span class=nf>newProcessListener</span><span class=p>(</span><span class=nx>handler</span><span class=p>,</span> <span class=nx>resyncPeriod</span><span class=p>,</span> <span class=nf>determineResyncPeriod</span><span class=p>(</span><span class=nx>resyncPeriod</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nx>resyncCheckPeriod</span><span class=p>),</span> <span class=nx>s</span><span class=p>.</span><span class=nx>clock</span><span class=p>.</span><span class=nf>Now</span><span class=p>(),</span> <span class=nx>initialBufferSize</span><span class=p>)</span>
    <span class=c1>// 如果没有启动，那么直接添加处理器就可以了
</span><span class=c1></span>    <span class=k>if</span> <span class=p>!</span><span class=nx>s</span><span class=p>.</span><span class=nx>started</span> <span class=p>{</span>
        <span class=nx>s</span><span class=p>.</span><span class=nx>processor</span><span class=p>.</span><span class=nf>addListener</span><span class=p>(</span><span class=nx>listener</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>
 
    <span class=c1>// 这个锁就是暂停再想所有的处理器分发事件用的，因为这样会遍历所有的处理器，此时添加会有风险
</span><span class=c1></span>    <span class=nx>s</span><span class=p>.</span><span class=nx>blockDeltas</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>s</span><span class=p>.</span><span class=nx>blockDeltas</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
    <span class=c1>// 添加处理器
</span><span class=c1></span>    <span class=nx>s</span><span class=p>.</span><span class=nx>processor</span><span class=p>.</span><span class=nf>addListener</span><span class=p>(</span><span class=nx>listener</span><span class=p>)</span>
    <span class=c1>// 这里有意思啦，遍历缓冲中的所有对象，通知处理器，因为SharedInformer已经启动了，可能很多对象已经让其他的处理器处理过了，
</span><span class=c1></span>    <span class=c1>// 所以这些对象就不会再通知新添加的处理器，此处就是解决这个问题的
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>item</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span><span class=p>.</span><span class=nx>indexer</span><span class=p>.</span><span class=nf>List</span><span class=p>()</span> <span class=p>{</span>
        <span class=nx>listener</span><span class=p>.</span><span class=nf>add</span><span class=p>(</span><span class=nx>addNotification</span><span class=p>{</span><span class=nx>newObj</span><span class=p>:</span> <span class=nx>item</span><span class=p>})</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>事件处理器添加完了，就要看SharedInformer如何把事件分发给每个处理器的了：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// 代码源自client-go/tools/cache/shared_informer.go
</span><span class=c1>// sharedIndexInformer的核心逻辑函数
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>sharedIndexInformer</span><span class=p>)</span> <span class=nf>Run</span><span class=p>(</span><span class=nx>stopCh</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span> <span class=p>{</span>
    <span class=k>defer</span> <span class=nx>utilruntime</span><span class=p>.</span><span class=nf>HandleCrash</span><span class=p>()</span>
    <span class=c1>// 在此处构造的DeltaFIFO
</span><span class=c1></span>    <span class=nx>fifo</span> <span class=o>:=</span> <span class=nf>NewDeltaFIFO</span><span class=p>(</span><span class=nx>MetaNamespaceKeyFunc</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nx>indexer</span><span class=p>)</span>
    <span class=c1>// 这里的Config是我们介绍Reflector时介绍的那个Config
</span><span class=c1></span>    <span class=nx>cfg</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Config</span><span class=p>{</span>
        <span class=c1>// 我前面一直在说Reflector输入到DeltaFIFO,这里算是直接证明了
</span><span class=c1></span>        <span class=nx>Queue</span><span class=p>:</span>            <span class=nx>fifo</span><span class=p>,</span>            
        <span class=c1>// 下面这些变量我们在Reflector都说了，这里赘述
</span><span class=c1></span>        <span class=nx>ListerWatcher</span><span class=p>:</span>    <span class=nx>s</span><span class=p>.</span><span class=nx>listerWatcher</span><span class=p>,</span> 
        <span class=nx>ObjectType</span><span class=p>:</span>       <span class=nx>s</span><span class=p>.</span><span class=nx>objectType</span><span class=p>,</span>
        <span class=nx>FullResyncPeriod</span><span class=p>:</span> <span class=nx>s</span><span class=p>.</span><span class=nx>resyncCheckPeriod</span><span class=p>,</span>
        <span class=nx>RetryOnError</span><span class=p>:</span>     <span class=kc>false</span><span class=p>,</span>
        <span class=nx>ShouldResync</span><span class=p>:</span>     <span class=nx>s</span><span class=p>.</span><span class=nx>processor</span><span class=p>.</span><span class=nx>shouldResync</span><span class=p>,</span>
        <span class=c1>// 这个才是重点，Controller调用DeltaFIFO.Pop()接口传入的就是这个回调函数，也是我们后续重点介绍的
</span><span class=c1></span>        <span class=nx>Process</span><span class=p>:</span> <span class=nx>s</span><span class=p>.</span><span class=nx>HandleDeltas</span><span class=p>,</span>
    <span class=p>}</span>
    <span class=c1>// 创建Controller，这个不用多说了
</span><span class=c1></span>    <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
        <span class=nx>s</span><span class=p>.</span><span class=nx>startedLock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
        <span class=k>defer</span> <span class=nx>s</span><span class=p>.</span><span class=nx>startedLock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
 
        <span class=nx>s</span><span class=p>.</span><span class=nx>controller</span> <span class=p>=</span> <span class=nf>New</span><span class=p>(</span><span class=nx>cfg</span><span class=p>)</span>
        <span class=nx>s</span><span class=p>.</span><span class=nx>controller</span><span class=p>.(</span><span class=o>*</span><span class=nx>controller</span><span class=p>).</span><span class=nx>clock</span> <span class=p>=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>clock</span>
        <span class=nx>s</span><span class=p>.</span><span class=nx>started</span> <span class=p>=</span> <span class=kc>true</span>
    <span class=p>}()</span>
    <span class=c1>// 这个processorStopCh 是给sharedProcessor和cacheMutationDetector传递退出信号的
</span><span class=c1></span>    <span class=c1>// 因为这里要创建两个协程运行sharedProcessor和cacheMutationDetector的核心函数
</span><span class=c1></span>    <span class=nx>processorStopCh</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
    <span class=kd>var</span> <span class=nx>wg</span> <span class=nx>wait</span><span class=p>.</span><span class=nx>Group</span>
    <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>              <span class=c1>// Wait for Processor to stop
</span><span class=c1></span>    <span class=k>defer</span> <span class=nb>close</span><span class=p>(</span><span class=nx>processorStopCh</span><span class=p>)</span> <span class=c1>// Tell Processor to stop
</span><span class=c1></span>    <span class=nx>wg</span><span class=p>.</span><span class=nf>StartWithChannel</span><span class=p>(</span><span class=nx>processorStopCh</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nx>cacheMutationDetector</span><span class=p>.</span><span class=nx>Run</span><span class=p>)</span>
    <span class=nx>wg</span><span class=p>.</span><span class=nf>StartWithChannel</span><span class=p>(</span><span class=nx>processorStopCh</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nx>processor</span><span class=p>.</span><span class=nx>run</span><span class=p>)</span>
 
    <span class=c1>// Run()函数都退出了，也就应该设置结束的标识了
</span><span class=c1></span>    <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
        <span class=nx>s</span><span class=p>.</span><span class=nx>startedLock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
        <span class=k>defer</span> <span class=nx>s</span><span class=p>.</span><span class=nx>startedLock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
        <span class=nx>s</span><span class=p>.</span><span class=nx>stopped</span> <span class=p>=</span> <span class=kc>true</span> 
    <span class=p>}()</span>
    <span class=c1>// 启动Controller，Controller一旦运行，整个流程就开始启动了，所以叫Controller也不为过
</span><span class=c1></span>    <span class=c1>// 毕竟Controller是SharedInformer的发动机嘛
</span><span class=c1></span>    <span class=nx>s</span><span class=p>.</span><span class=nx>controller</span><span class=p>.</span><span class=nf>Run</span><span class=p>(</span><span class=nx>stopCh</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>sharedIndexInformer通过Run()函数启动了Controller和sharedProcess()，Controller通过DeltaFIFO.Pop()函数弹出Deltas，并调用函数处理，这个处理函数就是sharedIndexInformer.HandleDeltas()，这个函数是衔接Controller和sharedProcess的关键点，他把Deltas转换为sharedProcess需要的各种Notification类型。下面我们就对这个函数进行代码分析：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// 代码源自client-go/tools/cache/shared_informer.go
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>sharedIndexInformer</span><span class=p>)</span> <span class=nf>HandleDeltas</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=c1>// 看到这里就知道为啥起名为blockDeltas了，这是阻塞处理器Deltas啊~因为分发事件到处理器，所以要加锁
</span><span class=c1></span>    <span class=nx>s</span><span class=p>.</span><span class=nx>blockDeltas</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>s</span><span class=p>.</span><span class=nx>blockDeltas</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
 
    <span class=c1>// Deltas里面包含了一个对象的多个增量操作，所以要从最老的Delta到最先的Delta遍历处理
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>d</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>obj</span><span class=p>.(</span><span class=nx>Deltas</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// 根据不同的Delta做不同的操作，但是大致分为对象添加、删除两大类操作
</span><span class=c1></span>        <span class=c1>// 所有的操作都要先同步到cache在通知处理器，这样保持处理器和cache的状态是一致的
</span><span class=c1></span>        <span class=k>switch</span> <span class=nx>d</span><span class=p>.</span><span class=nx>Type</span> <span class=p>{</span>
        <span class=c1>// 同步、添加、更新都是对象添加类的造作，至于是否是更新还要看cache是否有这个对象
</span><span class=c1></span>        <span class=k>case</span> <span class=nx>Sync</span><span class=p>,</span> <span class=nx>Added</span><span class=p>,</span> <span class=nx>Updated</span><span class=p>:</span>
            <span class=c1>// 看看对象是不是有定时同步产生的事件
</span><span class=c1></span>            <span class=nx>isSync</span> <span class=o>:=</span> <span class=nx>d</span><span class=p>.</span><span class=nx>Type</span> <span class=o>==</span> <span class=nx>Sync</span>
            <span class=c1>// 检测突变，没啥用
</span><span class=c1></span>            <span class=nx>s</span><span class=p>.</span><span class=nx>cacheMutationDetector</span><span class=p>.</span><span class=nf>AddObject</span><span class=p>(</span><span class=nx>d</span><span class=p>.</span><span class=nx>Object</span><span class=p>)</span>
            <span class=c1>// 如果cache中有的对象，一律看做是更新事件
</span><span class=c1></span>            <span class=k>if</span> <span class=nx>old</span><span class=p>,</span> <span class=nx>exists</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>indexer</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>d</span><span class=p>.</span><span class=nx>Object</span><span class=p>);</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>exists</span> <span class=p>{</span>
                <span class=c1>// 把对象更新到cache中
</span><span class=c1></span>                <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>indexer</span><span class=p>.</span><span class=nf>Update</span><span class=p>(</span><span class=nx>d</span><span class=p>.</span><span class=nx>Object</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
                    <span class=k>return</span> <span class=nx>err</span>
                <span class=p>}</span>
                <span class=c1>// 通知处理器处理事件
</span><span class=c1></span>                <span class=nx>s</span><span class=p>.</span><span class=nx>processor</span><span class=p>.</span><span class=nf>distribute</span><span class=p>(</span><span class=nx>updateNotification</span><span class=p>{</span><span class=nx>oldObj</span><span class=p>:</span> <span class=nx>old</span><span class=p>,</span> <span class=nx>newObj</span><span class=p>:</span> <span class=nx>d</span><span class=p>.</span><span class=nx>Object</span><span class=p>},</span> <span class=nx>isSync</span><span class=p>)</span>
            <span class=c1>// cache中没有的对象，一律看做是新增事件
</span><span class=c1></span>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
                <span class=c1>// 把对象添加到cache中
</span><span class=c1></span>                <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>indexer</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=nx>d</span><span class=p>.</span><span class=nx>Object</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
                    <span class=k>return</span> <span class=nx>err</span>
                <span class=p>}</span>
                <span class=c1>// 通知处理器处理器事件
</span><span class=c1></span>                <span class=nx>s</span><span class=p>.</span><span class=nx>processor</span><span class=p>.</span><span class=nf>distribute</span><span class=p>(</span><span class=nx>addNotification</span><span class=p>{</span><span class=nx>newObj</span><span class=p>:</span> <span class=nx>d</span><span class=p>.</span><span class=nx>Object</span><span class=p>},</span> <span class=nx>isSync</span><span class=p>)</span>
            <span class=p>}</span>
        <span class=c1>// 对象被删除
</span><span class=c1></span>        <span class=k>case</span> <span class=nx>Deleted</span><span class=p>:</span>
            <span class=c1>// 从cache中删除对象
</span><span class=c1></span>            <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>indexer</span><span class=p>.</span><span class=nf>Delete</span><span class=p>(</span><span class=nx>d</span><span class=p>.</span><span class=nx>Object</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
                <span class=k>return</span> <span class=nx>err</span>
            <span class=p>}</span>
            <span class=c1>// 通知所有的处理器对象被删除了
</span><span class=c1></span>            <span class=nx>s</span><span class=p>.</span><span class=nx>processor</span><span class=p>.</span><span class=nf>distribute</span><span class=p>(</span><span class=nx>deleteNotification</span><span class=p>{</span><span class=nx>oldObj</span><span class=p>:</span> <span class=nx>d</span><span class=p>.</span><span class=nx>Object</span><span class=p>},</span> <span class=kc>false</span><span class=p>)</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><h3 id=说明-1>说明</h3><ol><li><p>利用apiserver的api实现资源的列举和监控(Reflector实现)；</p></li><li><p>利用cache存储apiserver中的部分对象，通过对象类型进行制定，并在cache中采用Namespace做对象的索引</p></li><li><p>先通过apiserver的api将对象的全量列举出来存储在cache中，然后再watch资源，一旦有变化就更新cache中；</p></li><li><p>更新到cache中的过程通过DeltaFIFO实现的有顺序的更新，因为资源状态是通过全量+增量方式实现同步的，所以顺序错误会造成状态不一致；</p></li><li><p>使用者可以注册回调函数(类似挂钩子)，在更新到cache的同时通知使用者处理，为了保证回调处理不被某一个处理器阻塞，SharedInformer实现了processorListener异步缓冲处理；</p></li><li><p>整个过程是Controller是发动机，驱动整个流程运转；</p></li></ol><p>最后我们还是用一幅图来总结SharedInformer，绝对的干货(其中Reflector.resync()因为是个匿名函数，所以用斜体，其实是不存在这个函数的)~</p><img src=sharedinformer.png style=width:100%><h2 id=deltafifo>DeltaFIFO</h2><p>Delta其实就是kubernetes系统中对象的变化(增、删、改、同步)，FIFO比较好理解，是一个先入先出的队列，那么DeltaFIFO就是一个按序的(先入先出)kubernetes对象变化的队列</p><p>client-go/tools/cache/delta_fifo.go</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>
<span class=c1>// A KeyListerGetter is anything that knows how to list its keys and look up by key.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>KeyListerGetter</span> <span class=kd>interface</span> <span class=p>{</span>
    <span class=nx>KeyLister</span>
    <span class=nx>KeyGetter</span>
<span class=p>}</span>

<span class=c1>// A KeyLister is anything that knows how to list its keys.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>KeyLister</span> <span class=kd>interface</span> <span class=p>{</span>
    <span class=nf>ListKeys</span><span class=p>()</span> <span class=p>[]</span><span class=kt>string</span>
<span class=p>}</span>

<span class=c1>// A KeyGetter is anything that knows how to get the value stored under a given key.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>KeyGetter</span> <span class=kd>interface</span> <span class=p>{</span>
    <span class=nf>GetByKey</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=kd>interface</span><span class=p>{},</span> <span class=kt>bool</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
<span class=p>}</span>


</code></pre></td></tr></table></div></div><p>上面两个接口在client-go.tools.cache.Store这个接口类型中也存在，也就是说实现了Store接口的类型同时也实现了上面三个接口。上面三个接口基本上就是kv的标准接口，但凡是通过kv方式访问的对象(存储、队列、索引等)多半具备以上接口。肯定有人会问直接使用具体的类型不就完了么，定义这些有什么用？答案很简单，当你需要对kv的对象只读但是不关心具体实现时就用上了</p><h3 id=queue>Queue</h3><p>client-go/tools/cache/fifo.go</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Queue is exactly like a Store, but has a Pop() method too.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Queue</span> <span class=kd>interface</span> <span class=p>{</span>
    <span class=nx>Store</span>

    <span class=c1>// Pop blocks until it has something to process.
</span><span class=c1></span>    <span class=c1>// It returns the object that was process and the result of processing.
</span><span class=c1></span>    <span class=c1>// The PopProcessFunc may return an ErrRequeue{...} to indicate the item
</span><span class=c1></span>    <span class=c1>// should be requeued before releasing the lock on the queue.
</span><span class=c1></span>    <span class=nf>Pop</span><span class=p>(</span><span class=nx>PopProcessFunc</span><span class=p>)</span> <span class=p>(</span><span class=kd>interface</span><span class=p>{},</span> <span class=kt>error</span><span class=p>)</span>

    <span class=c1>// AddIfNotPresent adds a value previously
</span><span class=c1></span>    <span class=c1>// returned by Pop back into the queue as long
</span><span class=c1></span>    <span class=c1>// as nothing else (presumably more recent)
</span><span class=c1></span>    <span class=c1>// has since been added.
</span><span class=c1></span>    <span class=nf>AddIfNotPresent</span><span class=p>(</span><span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span>

    <span class=c1>// Return true if the first batch of items has been popped
</span><span class=c1></span>    <span class=nf>HasSynced</span><span class=p>()</span> <span class=kt>bool</span>

    <span class=c1>// Close queue
</span><span class=c1></span>    <span class=nf>Close</span><span class=p>()</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><p>Queue是在Store基础上扩展了Pop接口可以让对象有序的弹出，Indexer是在Store基础上建立了索引，可以快速检索对象。</p><h3 id=deltafifo实现>DeltaFIFO实现</h3><p>首先我们想想为什么每个对象一个Deltas而不是Delta？对一个对象的多个操作，什么操作可以合并？</p><p>DeltaFIFO生产者和消费者是异步的，如果同一个目标的频繁操作，前面操作还缓存在队列中的时候，那么队列就要缓冲对象的所有操作，那可以将多个操作合并么？这是下面讨论的了；</p><p>对于更新这种类型的操作在没有全量基础的情况下是没法合并的，同时我们还不知道具体是什么类型的对象，所以能合并的也就是有添加/删除，两个添加/删除操作其实可以视为一个；</p><p><strong>因为系统对于删除的对象有DeletedFinalStateUnknown这个状态，所以会存在两次删除的情况，但是两次添加同一个对象由于apiserver可以保证对象的唯一性，所以处理中就没有考虑合并两次添加操作。</strong> 这就是为什么合并操作处理只考虑了Delete</p><p>client-go/tools/cache/delta_fifo.go</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span><span class=lnt>193
</span><span class=lnt>194
</span><span class=lnt>195
</span><span class=lnt>196
</span><span class=lnt>197
</span><span class=lnt>198
</span><span class=lnt>199
</span><span class=lnt>200
</span><span class=lnt>201
</span><span class=lnt>202
</span><span class=lnt>203
</span><span class=lnt>204
</span><span class=lnt>205
</span><span class=lnt>206
</span><span class=lnt>207
</span><span class=lnt>208
</span><span class=lnt>209
</span><span class=lnt>210
</span><span class=lnt>211
</span><span class=lnt>212
</span><span class=lnt>213
</span><span class=lnt>214
</span><span class=lnt>215
</span><span class=lnt>216
</span><span class=lnt>217
</span><span class=lnt>218
</span><span class=lnt>219
</span><span class=lnt>220
</span><span class=lnt>221
</span><span class=lnt>222
</span><span class=lnt>223
</span><span class=lnt>224
</span><span class=lnt>225
</span><span class=lnt>226
</span><span class=lnt>227
</span><span class=lnt>228
</span><span class=lnt>229
</span><span class=lnt>230
</span><span class=lnt>231
</span><span class=lnt>232
</span><span class=lnt>233
</span><span class=lnt>234
</span><span class=lnt>235
</span><span class=lnt>236
</span><span class=lnt>237
</span><span class=lnt>238
</span><span class=lnt>239
</span><span class=lnt>240
</span><span class=lnt>241
</span><span class=lnt>242
</span><span class=lnt>243
</span><span class=lnt>244
</span><span class=lnt>245
</span><span class=lnt>246
</span><span class=lnt>247
</span><span class=lnt>248
</span><span class=lnt>249
</span><span class=lnt>250
</span><span class=lnt>251
</span><span class=lnt>252
</span><span class=lnt>253
</span><span class=lnt>254
</span><span class=lnt>255
</span><span class=lnt>256
</span><span class=lnt>257
</span><span class=lnt>258
</span><span class=lnt>259
</span><span class=lnt>260
</span><span class=lnt>261
</span><span class=lnt>262
</span><span class=lnt>263
</span><span class=lnt>264
</span><span class=lnt>265
</span><span class=lnt>266
</span><span class=lnt>267
</span><span class=lnt>268
</span><span class=lnt>269
</span><span class=lnt>270
</span><span class=lnt>271
</span><span class=lnt>272
</span><span class=lnt>273
</span><span class=lnt>274
</span><span class=lnt>275
</span><span class=lnt>276
</span><span class=lnt>277
</span><span class=lnt>278
</span><span class=lnt>279
</span><span class=lnt>280
</span><span class=lnt>281
</span><span class=lnt>282
</span><span class=lnt>283
</span><span class=lnt>284
</span><span class=lnt>285
</span><span class=lnt>286
</span><span class=lnt>287
</span><span class=lnt>288
</span><span class=lnt>289
</span><span class=lnt>290
</span><span class=lnt>291
</span><span class=lnt>292
</span><span class=lnt>293
</span><span class=lnt>294
</span><span class=lnt>295
</span><span class=lnt>296
</span><span class=lnt>297
</span><span class=lnt>298
</span><span class=lnt>299
</span><span class=lnt>300
</span><span class=lnt>301
</span><span class=lnt>302
</span><span class=lnt>303
</span><span class=lnt>304
</span><span class=lnt>305
</span><span class=lnt>306
</span><span class=lnt>307
</span><span class=lnt>308
</span><span class=lnt>309
</span><span class=lnt>310
</span><span class=lnt>311
</span><span class=lnt>312
</span><span class=lnt>313
</span><span class=lnt>314
</span><span class=lnt>315
</span><span class=lnt>316
</span><span class=lnt>317
</span><span class=lnt>318
</span><span class=lnt>319
</span><span class=lnt>320
</span><span class=lnt>321
</span><span class=lnt>322
</span><span class=lnt>323
</span><span class=lnt>324
</span><span class=lnt>325
</span><span class=lnt>326
</span><span class=lnt>327
</span><span class=lnt>328
</span><span class=lnt>329
</span><span class=lnt>330
</span><span class=lnt>331
</span><span class=lnt>332
</span><span class=lnt>333
</span><span class=lnt>334
</span><span class=lnt>335
</span><span class=lnt>336
</span><span class=lnt>337
</span><span class=lnt>338
</span><span class=lnt>339
</span><span class=lnt>340
</span><span class=lnt>341
</span><span class=lnt>342
</span><span class=lnt>343
</span><span class=lnt>344
</span><span class=lnt>345
</span><span class=lnt>346
</span><span class=lnt>347
</span><span class=lnt>348
</span><span class=lnt>349
</span><span class=lnt>350
</span><span class=lnt>351
</span><span class=lnt>352
</span><span class=lnt>353
</span><span class=lnt>354
</span><span class=lnt>355
</span><span class=lnt>356
</span><span class=lnt>357
</span><span class=lnt>358
</span><span class=lnt>359
</span><span class=lnt>360
</span><span class=lnt>361
</span><span class=lnt>362
</span><span class=lnt>363
</span><span class=lnt>364
</span><span class=lnt>365
</span><span class=lnt>366
</span><span class=lnt>367
</span><span class=lnt>368
</span><span class=lnt>369
</span><span class=lnt>370
</span><span class=lnt>371
</span><span class=lnt>372
</span><span class=lnt>373
</span><span class=lnt>374
</span><span class=lnt>375
</span><span class=lnt>376
</span><span class=lnt>377
</span><span class=lnt>378
</span><span class=lnt>379
</span><span class=lnt>380
</span><span class=lnt>381
</span><span class=lnt>382
</span><span class=lnt>383
</span><span class=lnt>384
</span><span class=lnt>385
</span><span class=lnt>386
</span><span class=lnt>387
</span><span class=lnt>388
</span><span class=lnt>389
</span><span class=lnt>390
</span><span class=lnt>391
</span><span class=lnt>392
</span><span class=lnt>393
</span><span class=lnt>394
</span><span class=lnt>395
</span><span class=lnt>396
</span><span class=lnt>397
</span><span class=lnt>398
</span><span class=lnt>399
</span><span class=lnt>400
</span><span class=lnt>401
</span><span class=lnt>402
</span><span class=lnt>403
</span><span class=lnt>404
</span><span class=lnt>405
</span><span class=lnt>406
</span><span class=lnt>407
</span><span class=lnt>408
</span><span class=lnt>409
</span><span class=lnt>410
</span><span class=lnt>411
</span><span class=lnt>412
</span><span class=lnt>413
</span><span class=lnt>414
</span><span class=lnt>415
</span><span class=lnt>416
</span><span class=lnt>417
</span><span class=lnt>418
</span><span class=lnt>419
</span><span class=lnt>420
</span><span class=lnt>421
</span><span class=lnt>422
</span><span class=lnt>423
</span><span class=lnt>424
</span><span class=lnt>425
</span><span class=lnt>426
</span><span class=lnt>427
</span><span class=lnt>428
</span><span class=lnt>429
</span><span class=lnt>430
</span><span class=lnt>431
</span><span class=lnt>432
</span><span class=lnt>433
</span><span class=lnt>434
</span><span class=lnt>435
</span><span class=lnt>436
</span><span class=lnt>437
</span><span class=lnt>438
</span><span class=lnt>439
</span><span class=lnt>440
</span><span class=lnt>441
</span><span class=lnt>442
</span><span class=lnt>443
</span><span class=lnt>444
</span><span class=lnt>445
</span><span class=lnt>446
</span><span class=lnt>447
</span><span class=lnt>448
</span><span class=lnt>449
</span><span class=lnt>450
</span><span class=lnt>451
</span><span class=lnt>452
</span><span class=lnt>453
</span><span class=lnt>454
</span><span class=lnt>455
</span><span class=lnt>456
</span><span class=lnt>457
</span><span class=lnt>458
</span><span class=lnt>459
</span><span class=lnt>460
</span><span class=lnt>461
</span><span class=lnt>462
</span><span class=lnt>463
</span><span class=lnt>464
</span><span class=lnt>465
</span><span class=lnt>466
</span><span class=lnt>467
</span><span class=lnt>468
</span><span class=lnt>469
</span><span class=lnt>470
</span><span class=lnt>471
</span><span class=lnt>472
</span><span class=lnt>473
</span><span class=lnt>474
</span><span class=lnt>475
</span><span class=lnt>476
</span><span class=lnt>477
</span><span class=lnt>478
</span><span class=lnt>479
</span><span class=lnt>480
</span><span class=lnt>481
</span><span class=lnt>482
</span><span class=lnt>483
</span><span class=lnt>484
</span><span class=lnt>485
</span><span class=lnt>486
</span><span class=lnt>487
</span><span class=lnt>488
</span><span class=lnt>489
</span><span class=lnt>490
</span><span class=lnt>491
</span><span class=lnt>492
</span><span class=lnt>493
</span><span class=lnt>494
</span><span class=lnt>495
</span><span class=lnt>496
</span><span class=lnt>497
</span><span class=lnt>498
</span><span class=lnt>499
</span><span class=lnt>500
</span><span class=lnt>501
</span><span class=lnt>502
</span><span class=lnt>503
</span><span class=lnt>504
</span><span class=lnt>505
</span><span class=lnt>506
</span><span class=lnt>507
</span><span class=lnt>508
</span><span class=lnt>509
</span><span class=lnt>510
</span><span class=lnt>511
</span><span class=lnt>512
</span><span class=lnt>513
</span><span class=lnt>514
</span><span class=lnt>515
</span><span class=lnt>516
</span><span class=lnt>517
</span><span class=lnt>518
</span><span class=lnt>519
</span><span class=lnt>520
</span><span class=lnt>521
</span><span class=lnt>522
</span><span class=lnt>523
</span><span class=lnt>524
</span><span class=lnt>525
</span><span class=lnt>526
</span><span class=lnt>527
</span><span class=lnt>528
</span><span class=lnt>529
</span><span class=lnt>530
</span><span class=lnt>531
</span><span class=lnt>532
</span><span class=lnt>533
</span><span class=lnt>534
</span><span class=lnt>535
</span><span class=lnt>536
</span><span class=lnt>537
</span><span class=lnt>538
</span><span class=lnt>539
</span><span class=lnt>540
</span><span class=lnt>541
</span><span class=lnt>542
</span><span class=lnt>543
</span><span class=lnt>544
</span><span class=lnt>545
</span><span class=lnt>546
</span><span class=lnt>547
</span><span class=lnt>548
</span><span class=lnt>549
</span><span class=lnt>550
</span><span class=lnt>551
</span><span class=lnt>552
</span><span class=lnt>553
</span><span class=lnt>554
</span><span class=lnt>555
</span><span class=lnt>556
</span><span class=lnt>557
</span><span class=lnt>558
</span><span class=lnt>559
</span><span class=lnt>560
</span><span class=lnt>561
</span><span class=lnt>562
</span><span class=lnt>563
</span><span class=lnt>564
</span><span class=lnt>565
</span><span class=lnt>566
</span><span class=lnt>567
</span><span class=lnt>568
</span><span class=lnt>569
</span><span class=lnt>570
</span><span class=lnt>571
</span><span class=lnt>572
</span><span class=lnt>573
</span><span class=lnt>574
</span><span class=lnt>575
</span><span class=lnt>576
</span><span class=lnt>577
</span><span class=lnt>578
</span><span class=lnt>579
</span><span class=lnt>580
</span><span class=lnt>581
</span><span class=lnt>582
</span><span class=lnt>583
</span><span class=lnt>584
</span><span class=lnt>585
</span><span class=lnt>586
</span><span class=lnt>587
</span><span class=lnt>588
</span><span class=lnt>589
</span><span class=lnt>590
</span><span class=lnt>591
</span><span class=lnt>592
</span><span class=lnt>593
</span><span class=lnt>594
</span><span class=lnt>595
</span><span class=lnt>596
</span><span class=lnt>597
</span><span class=lnt>598
</span><span class=lnt>599
</span><span class=lnt>600
</span><span class=lnt>601
</span><span class=lnt>602
</span><span class=lnt>603
</span><span class=lnt>604
</span><span class=lnt>605
</span><span class=lnt>606
</span><span class=lnt>607
</span><span class=lnt>608
</span><span class=lnt>609
</span><span class=lnt>610
</span><span class=lnt>611
</span><span class=lnt>612
</span><span class=lnt>613
</span><span class=lnt>614
</span><span class=lnt>615
</span><span class=lnt>616
</span><span class=lnt>617
</span><span class=lnt>618
</span><span class=lnt>619
</span><span class=lnt>620
</span><span class=lnt>621
</span><span class=lnt>622
</span><span class=lnt>623
</span><span class=lnt>624
</span><span class=lnt>625
</span><span class=lnt>626
</span><span class=lnt>627
</span><span class=lnt>628
</span><span class=lnt>629
</span><span class=lnt>630
</span><span class=lnt>631
</span><span class=lnt>632
</span><span class=lnt>633
</span><span class=lnt>634
</span><span class=lnt>635
</span><span class=lnt>636
</span><span class=lnt>637
</span><span class=lnt>638
</span><span class=lnt>639
</span><span class=lnt>640
</span><span class=lnt>641
</span><span class=lnt>642
</span><span class=lnt>643
</span><span class=lnt>644
</span><span class=lnt>645
</span><span class=lnt>646
</span><span class=lnt>647
</span><span class=lnt>648
</span><span class=lnt>649
</span><span class=lnt>650
</span><span class=lnt>651
</span><span class=lnt>652
</span><span class=lnt>653
</span><span class=lnt>654
</span><span class=lnt>655
</span><span class=lnt>656
</span><span class=lnt>657
</span><span class=lnt>658
</span><span class=lnt>659
</span><span class=lnt>660
</span><span class=lnt>661
</span><span class=lnt>662
</span><span class=lnt>663
</span><span class=lnt>664
</span><span class=lnt>665
</span><span class=lnt>666
</span><span class=lnt>667
</span><span class=lnt>668
</span><span class=lnt>669
</span><span class=lnt>670
</span><span class=lnt>671
</span><span class=lnt>672
</span><span class=lnt>673
</span><span class=lnt>674
</span><span class=lnt>675
</span><span class=lnt>676
</span><span class=lnt>677
</span><span class=lnt>678
</span><span class=lnt>679
</span><span class=lnt>680
</span><span class=lnt>681
</span><span class=lnt>682
</span><span class=lnt>683
</span><span class=lnt>684
</span><span class=lnt>685
</span><span class=lnt>686
</span><span class=lnt>687
</span><span class=lnt>688
</span><span class=lnt>689
</span><span class=lnt>690
</span><span class=lnt>691
</span><span class=lnt>692
</span><span class=lnt>693
</span><span class=lnt>694
</span><span class=lnt>695
</span><span class=lnt>696
</span><span class=lnt>697
</span><span class=lnt>698
</span><span class=lnt>699
</span><span class=lnt>700
</span><span class=lnt>701
</span><span class=lnt>702
</span><span class=lnt>703
</span><span class=lnt>704
</span><span class=lnt>705
</span><span class=lnt>706
</span><span class=lnt>707
</span><span class=lnt>708
</span><span class=lnt>709
</span><span class=lnt>710
</span><span class=lnt>711
</span><span class=lnt>712
</span><span class=lnt>713
</span><span class=lnt>714
</span><span class=lnt>715
</span><span class=lnt>716
</span><span class=lnt>717
</span><span class=lnt>718
</span><span class=lnt>719
</span><span class=lnt>720
</span><span class=lnt>721
</span><span class=lnt>722
</span><span class=lnt>723
</span><span class=lnt>724
</span><span class=lnt>725
</span><span class=lnt>726
</span><span class=lnt>727
</span><span class=lnt>728
</span><span class=lnt>729
</span><span class=lnt>730
</span><span class=lnt>731
</span><span class=lnt>732
</span><span class=lnt>733
</span><span class=lnt>734
</span><span class=lnt>735
</span><span class=lnt>736
</span><span class=lnt>737
</span><span class=lnt>738
</span><span class=lnt>739
</span><span class=lnt>740
</span><span class=lnt>741
</span><span class=lnt>742
</span><span class=lnt>743
</span><span class=lnt>744
</span><span class=lnt>745
</span><span class=lnt>746
</span><span class=lnt>747
</span><span class=lnt>748
</span><span class=lnt>749
</span><span class=lnt>750
</span><span class=lnt>751
</span><span class=lnt>752
</span><span class=lnt>753
</span><span class=lnt>754
</span><span class=lnt>755
</span><span class=lnt>756
</span><span class=lnt>757
</span><span class=lnt>758
</span><span class=lnt>759
</span><span class=lnt>760
</span><span class=lnt>761
</span><span class=lnt>762
</span><span class=lnt>763
</span><span class=lnt>764
</span><span class=lnt>765
</span><span class=lnt>766
</span><span class=lnt>767
</span><span class=lnt>768
</span><span class=lnt>769
</span><span class=lnt>770
</span><span class=lnt>771
</span><span class=lnt>772
</span><span class=lnt>773
</span><span class=lnt>774
</span><span class=lnt>775
</span><span class=lnt>776
</span><span class=lnt>777
</span><span class=lnt>778
</span><span class=lnt>779
</span><span class=lnt>780
</span><span class=lnt>781
</span><span class=lnt>782
</span><span class=lnt>783
</span><span class=lnt>784
</span><span class=lnt>785
</span><span class=lnt>786
</span><span class=lnt>787
</span><span class=lnt>788
</span><span class=lnt>789
</span><span class=lnt>790
</span><span class=lnt>791
</span><span class=lnt>792
</span><span class=lnt>793
</span><span class=lnt>794
</span><span class=lnt>795
</span><span class=lnt>796
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>
<span class=cm>/*
</span><span class=cm>Copyright 2014 The Kubernetes Authors.
</span><span class=cm>
</span><span class=cm>Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
</span><span class=cm>you may not use this file except in compliance with the License.
</span><span class=cm>You may obtain a copy of the License at
</span><span class=cm>
</span><span class=cm>    http://www.apache.org/licenses/LICENSE-2.0
</span><span class=cm>
</span><span class=cm>Unless required by applicable law or agreed to in writing, software
</span><span class=cm>distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
</span><span class=cm>WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</span><span class=cm>See the License for the specific language governing permissions and
</span><span class=cm>limitations under the License.
</span><span class=cm>*/</span>

<span class=kn>package</span> <span class=nx>cache</span>

<span class=kn>import</span> <span class=p>(</span>
    <span class=s>&#34;errors&#34;</span>
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;sync&#34;</span>

    <span class=s>&#34;k8s.io/apimachinery/pkg/util/sets&#34;</span>

    <span class=s>&#34;github.com/golang/glog&#34;</span>
<span class=p>)</span>

<span class=c1>// NewDeltaFIFO returns a Store which can be used process changes to items.
</span><span class=c1>//
</span><span class=c1>// keyFunc is used to figure out what key an object should have. (It&#39;s
</span><span class=c1>// exposed in the returned DeltaFIFO&#39;s KeyOf() method, with bonus features.)
</span><span class=c1>//
</span><span class=c1>// &#39;compressor&#39; may compress as many or as few items as it wants
</span><span class=c1>// (including returning an empty slice), but it should do what it
</span><span class=c1>// does quickly since it is called while the queue is locked.
</span><span class=c1>// &#39;compressor&#39; may be nil if you don&#39;t want any delta compression.
</span><span class=c1>//
</span><span class=c1>// &#39;keyLister&#39; is expected to return a list of keys that the consumer of
</span><span class=c1>// this queue &#34;knows about&#34;. It is used to decide which items are missing
</span><span class=c1>// when Replace() is called; &#39;Deleted&#39; deltas are produced for these items.
</span><span class=c1>// It may be nil if you don&#39;t need to detect all deletions.
</span><span class=c1>// TODO: consider merging keyLister with this object, tracking a list of
</span><span class=c1>//       &#34;known&#34; keys when Pop() is called. Have to think about how that
</span><span class=c1>//       affects error retrying.
</span><span class=c1>// TODO(lavalamp): I believe there is a possible race only when using an
</span><span class=c1>//                 external known object source that the above TODO would
</span><span class=c1>//                 fix.
</span><span class=c1>//
</span><span class=c1>// Also see the comment on DeltaFIFO.
</span><span class=c1></span><span class=kd>func</span> <span class=nf>NewDeltaFIFO</span><span class=p>(</span><span class=nx>keyFunc</span> <span class=nx>KeyFunc</span><span class=p>,</span> <span class=nx>compressor</span> <span class=nx>DeltaCompressor</span><span class=p>,</span> <span class=nx>knownObjects</span> <span class=nx>KeyListerGetter</span><span class=p>)</span> <span class=o>*</span><span class=nx>DeltaFIFO</span> <span class=p>{</span>
    <span class=nx>f</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>DeltaFIFO</span><span class=p>{</span>
        <span class=nx>items</span><span class=p>:</span>           <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>Deltas</span><span class=p>{},</span>
        <span class=nx>queue</span><span class=p>:</span>           <span class=p>[]</span><span class=kt>string</span><span class=p>{},</span>
        <span class=nx>keyFunc</span><span class=p>:</span>         <span class=nx>keyFunc</span><span class=p>,</span>
        <span class=nx>deltaCompressor</span><span class=p>:</span> <span class=nx>compressor</span><span class=p>,</span>
        <span class=nx>knownObjects</span><span class=p>:</span>    <span class=nx>knownObjects</span><span class=p>,</span>
    <span class=p>}</span>
    <span class=nx>f</span><span class=p>.</span><span class=nx>cond</span><span class=p>.</span><span class=nx>L</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>f</span><span class=p>.</span><span class=nx>lock</span>
    <span class=k>return</span> <span class=nx>f</span>
<span class=p>}</span>

<span class=c1>// DeltaFIFO is like FIFO, but allows you to process deletes.
</span><span class=c1>//
</span><span class=c1>// DeltaFIFO is a producer-consumer queue, where a Reflector is
</span><span class=c1>// intended to be the producer, and the consumer is whatever calls
</span><span class=c1>// the Pop() method.
</span><span class=c1>//
</span><span class=c1>// DeltaFIFO solves this use case:
</span><span class=c1>//  * You want to process every object change (delta) at most once.
</span><span class=c1>//  * When you process an object, you want to see everything
</span><span class=c1>//    that&#39;s happened to it since you last processed it.
</span><span class=c1>//  * You want to process the deletion of objects.
</span><span class=c1>//  * You might want to periodically reprocess objects.
</span><span class=c1>//
</span><span class=c1>// DeltaFIFO&#39;s Pop(), Get(), and GetByKey() methods return
</span><span class=c1>// interface{} to satisfy the Store/Queue interfaces, but it
</span><span class=c1>// will always return an object of type Deltas.
</span><span class=c1>//
</span><span class=c1>// A note on threading: If you call Pop() in parallel from multiple
</span><span class=c1>// threads, you could end up with multiple threads processing slightly
</span><span class=c1>// different versions of the same object.
</span><span class=c1>//
</span><span class=c1>// A note on the KeyLister used by the DeltaFIFO: It&#39;s main purpose is
</span><span class=c1>// to list keys that are &#34;known&#34;, for the purpose of figuring out which
</span><span class=c1>// items have been deleted when Replace() or Delete() are called. The deleted
</span><span class=c1>// object will be included in the DeleteFinalStateUnknown markers. These objects
</span><span class=c1>// could be stale.
</span><span class=c1>//
</span><span class=c1>// You may provide a function to compress deltas (e.g., represent a
</span><span class=c1>// series of Updates as a single Update).
</span><span class=c1></span><span class=kd>type</span> <span class=nx>DeltaFIFO</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=c1>// lock/cond protects access to &#39;items&#39; and &#39;queue&#39;.
</span><span class=c1></span>    <span class=c1>// 读写锁，因为涉及到同时读写，读写锁性能要高
</span><span class=c1></span>    <span class=nx>lock</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
    <span class=c1>// 给Pop()接口使用，在没有对象的时候可以阻塞，内部锁复用读写锁
</span><span class=c1></span>    <span class=nx>cond</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Cond</span>

    <span class=c1>// We depend on the property that items in the set are in
</span><span class=c1></span>    <span class=c1>// the queue and vice versa, and that all Deltas in this
</span><span class=c1></span>    <span class=c1>// map have at least one Delta.
</span><span class=c1></span>    <span class=c1>// 存储对象
</span><span class=c1></span>    <span class=c1>// 这个应该是Store的本质了，按照kv的方式存储对象，但是存储的是对象的Deltas数组
</span><span class=c1></span>    <span class=nx>items</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>Deltas</span>
    <span class=c1>// 队列
</span><span class=c1></span>    <span class=c1>//这个是为先入先出实现的，存储的就是对象的键
</span><span class=c1></span>    <span class=nx>queue</span> <span class=p>[]</span><span class=kt>string</span>

    <span class=c1>// populated is true if the first batch of items inserted by Replace() has been populated
</span><span class=c1></span>    <span class=c1>// or Delete/Add/Update was called first.
</span><span class=c1></span>    <span class=c1>// 通过Replace()接口将第一批对象放入队列，或者第一次调用增、删、改接口时标记为true
</span><span class=c1></span>    <span class=nx>populated</span> <span class=kt>bool</span>
    <span class=c1>// initialPopulationCount is the number of items inserted by the first call of Replace()
</span><span class=c1></span>    <span class=c1>// 通过Replace()接口将第一批对象放入队列的对象数量
</span><span class=c1></span>    <span class=nx>initialPopulationCount</span> <span class=kt>int</span>

    <span class=c1>// keyFunc is used to make the key used for queued item
</span><span class=c1></span>    <span class=c1>// insertion and retrieval, and should be deterministic.
</span><span class=c1></span>    <span class=c1>// 对象键计算函数
</span><span class=c1></span>    <span class=c1>//MetaNamespaceKeyFunc
</span><span class=c1></span>    <span class=c1>//meta.GetNamespace() + &#34;/&#34; + meta.GetName()
</span><span class=c1></span>    <span class=nx>keyFunc</span> <span class=nx>KeyFunc</span>

    <span class=c1>// deltaCompressor tells us how to combine two or more
</span><span class=c1></span>    <span class=c1>// deltas. It may be nil.
</span><span class=c1></span>    <span class=nx>deltaCompressor</span> <span class=nx>DeltaCompressor</span>

    <span class=c1>// knownObjects list keys that are &#34;known&#34;, for the
</span><span class=c1></span>    <span class=c1>// purpose of figuring out which items have been deleted
</span><span class=c1></span>    <span class=c1>// when Replace() or Delete() is called.
</span><span class=c1></span>    <span class=c1>// 前面介绍就是为了这是用，该对象指向的就是Indexer，
</span><span class=c1></span>    <span class=nx>knownObjects</span> <span class=nx>KeyListerGetter</span>

    <span class=c1>// Indication the queue is closed.
</span><span class=c1></span>    <span class=c1>// Used to indicate a queue is closed so a control loop can exit when a queue is empty.
</span><span class=c1></span>    <span class=c1>// Currently, not used to gate any of CRED operations.
</span><span class=c1></span>    <span class=c1>// 是否已经关闭的标记
</span><span class=c1></span>    <span class=nx>closed</span>     <span class=kt>bool</span>
    <span class=c1>// 专为关闭设计的锁，这里非读写锁，可能不是读多写少场景
</span><span class=c1></span>    <span class=nx>closedLock</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
<span class=p>}</span>

<span class=kd>var</span> <span class=p>(</span>
    <span class=nx>_</span> <span class=p>=</span> <span class=nf>Queue</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>DeltaFIFO</span><span class=p>{})</span> <span class=c1>// DeltaFIFO is a Queue
</span><span class=c1></span><span class=p>)</span>

<span class=kd>var</span> <span class=p>(</span>
    <span class=c1>// ErrZeroLengthDeltasObject is returned in a KeyError if a Deltas
</span><span class=c1></span>    <span class=c1>// object with zero length is encountered (should be impossible,
</span><span class=c1></span>    <span class=c1>// even if such an object is accidentally produced by a DeltaCompressor--
</span><span class=c1></span>    <span class=c1>// but included for completeness).
</span><span class=c1></span>    <span class=nx>ErrZeroLengthDeltasObject</span> <span class=p>=</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;0 length Deltas object; can&#39;t get key&#34;</span><span class=p>)</span>
<span class=p>)</span>

<span class=c1>// Close the queue.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>DeltaFIFO</span><span class=p>)</span> <span class=nf>Close</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>f</span><span class=p>.</span><span class=nx>closedLock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nx>closedLock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
    <span class=nx>f</span><span class=p>.</span><span class=nx>closed</span> <span class=p>=</span> <span class=kc>true</span>
    <span class=nx>f</span><span class=p>.</span><span class=nx>cond</span><span class=p>.</span><span class=nf>Broadcast</span><span class=p>()</span>
<span class=p>}</span>

<span class=c1>// KeyOf exposes f&#39;s keyFunc, but also detects the key of a Deltas object or
</span><span class=c1>// DeletedFinalStateUnknown objects.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>DeltaFIFO</span><span class=p>)</span> <span class=nf>KeyOf</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 先用Deltas做一次强行转换
</span><span class=c1></span>    <span class=c1>//DeltaFIFO的计算对象键的方式为什么要先做一次Deltas的类型转换呢？
</span><span class=c1></span>    <span class=c1>//原因很简单，那就是从DeltaFIFO.Pop()出去的对象很可能还要再添加进来(比如处理失败需要再放进来)，
</span><span class=c1></span>    <span class=c1>//此时添加的对象就是已经封装好的Deltas。
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>d</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>obj</span><span class=p>.(</span><span class=nx>Deltas</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
            <span class=k>return</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=nx>KeyError</span><span class=p>{</span><span class=nx>obj</span><span class=p>,</span> <span class=nx>ErrZeroLengthDeltasObject</span><span class=p>}</span>
        <span class=p>}</span>
        <span class=c1>// 只用最新版本的对象就可以了
</span><span class=c1></span>        <span class=c1>// 即该Deltas数组中最后一个元素
</span><span class=c1></span>        <span class=nx>obj</span> <span class=p>=</span> <span class=nx>d</span><span class=p>.</span><span class=nf>Newest</span><span class=p>().</span><span class=nx>Object</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=nx>d</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>obj</span><span class=p>.(</span><span class=nx>DeletedFinalStateUnknown</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>d</span><span class=p>.</span><span class=nx>Key</span><span class=p>,</span> <span class=kc>nil</span>
    <span class=p>}</span>
    <span class=c1>//MetaNamespaceKeyFunc
</span><span class=c1></span>    <span class=c1>//meta.GetNamespace() + &#34;/&#34; + meta.GetName()
</span><span class=c1></span>    <span class=k>return</span> <span class=nx>f</span><span class=p>.</span><span class=nf>keyFunc</span><span class=p>(</span><span class=nx>obj</span><span class=p>)</span>
<span class=p>}</span>

<span class=c1>// Return true if an Add/Update/Delete/AddIfNotPresent are called first,
</span><span class=c1>// or an Update called first but the first batch of items inserted by Replace() has been popped
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>DeltaFIFO</span><span class=p>)</span> <span class=nf>HasSynced</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
    <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
    <span class=c1>// 这里就比较明白了，一次同步全量对象后，并且全部Pop()出去才能算是同步完成
</span><span class=c1></span>    <span class=c1>// 其实这里所谓的同步就是全量内容已经进入Indexer，Indexer已经是系统中对象的全量快照了
</span><span class=c1></span>    <span class=k>return</span> <span class=nx>f</span><span class=p>.</span><span class=nx>populated</span> <span class=o>&amp;&amp;</span> <span class=nx>f</span><span class=p>.</span><span class=nx>initialPopulationCount</span> <span class=o>==</span> <span class=mi>0</span>
<span class=p>}</span>

<span class=c1>// Add inserts an item, and puts it in the queue. The item is only enqueued
</span><span class=c1>// if it doesn&#39;t already exist in the set.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>DeltaFIFO</span><span class=p>)</span> <span class=nf>Add</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
    <span class=c1>// 队列第一次写入操作都要设置标记
</span><span class=c1></span>    <span class=nx>f</span><span class=p>.</span><span class=nx>populated</span> <span class=p>=</span> <span class=kc>true</span>
    <span class=k>return</span> <span class=nx>f</span><span class=p>.</span><span class=nf>queueActionLocked</span><span class=p>(</span><span class=nx>Added</span><span class=p>,</span> <span class=nx>obj</span><span class=p>)</span>
<span class=p>}</span>

<span class=c1>// Update is just like Add, but makes an Updated Delta.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>DeltaFIFO</span><span class=p>)</span> <span class=nf>Update</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
    <span class=c1>// 队列第一次写入操作都要设置标记
</span><span class=c1></span>    <span class=nx>f</span><span class=p>.</span><span class=nx>populated</span> <span class=p>=</span> <span class=kc>true</span>
    <span class=k>return</span> <span class=nx>f</span><span class=p>.</span><span class=nf>queueActionLocked</span><span class=p>(</span><span class=nx>Updated</span><span class=p>,</span> <span class=nx>obj</span><span class=p>)</span>
<span class=p>}</span>

<span class=c1>// Delete is just like Add, but makes an Deleted Delta. If the item does not
</span><span class=c1>// already exist, it will be ignored. (It may have already been deleted by a
</span><span class=c1>// Replace (re-list), for example.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>DeltaFIFO</span><span class=p>)</span> <span class=nf>Delete</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=nx>id</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nf>KeyOf</span><span class=p>(</span><span class=nx>obj</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>KeyError</span><span class=p>{</span><span class=nx>obj</span><span class=p>,</span> <span class=nx>err</span><span class=p>}</span>
    <span class=p>}</span>
    <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
    <span class=c1>// 队列第一次写入操作都要设置标记
</span><span class=c1></span>    <span class=nx>f</span><span class=p>.</span><span class=nx>populated</span> <span class=p>=</span> <span class=kc>true</span>
    <span class=c1>// 此处是需要注意的，knownObjects就是Indexer，里面存有已知全部的对象
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>f</span><span class=p>.</span><span class=nx>knownObjects</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=c1>// 在没有Indexer的条件下只能通过自己存储的对象查一下
</span><span class=c1></span>        <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>exists</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>id</span><span class=p>];</span> <span class=p>!</span><span class=nx>exists</span> <span class=p>{</span>
            <span class=c1>// Presumably, this was deleted when a relist happened.
</span><span class=c1></span>            <span class=c1>// Don&#39;t provide a second report of the same deletion.
</span><span class=c1></span>            <span class=k>return</span> <span class=kc>nil</span>
        <span class=p>}</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=c1>// We only want to skip the &#34;deletion&#34; action if the object doesn&#39;t
</span><span class=c1></span>        <span class=c1>// exist in knownObjects and it doesn&#39;t have corresponding item in items.
</span><span class=c1></span>        <span class=c1>// Note that even if there is a &#34;deletion&#34; action in items, we can ignore it,
</span><span class=c1></span>        <span class=c1>// because it will be deduped automatically in &#34;queueActionLocked&#34;
</span><span class=c1></span>        <span class=c1>// 自己（itemsExist）和Indexer里面（exists）有任何一个有这个对象就算存在
</span><span class=c1></span>        <span class=nx>_</span><span class=p>,</span> <span class=nx>exists</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nx>knownObjects</span><span class=p>.</span><span class=nf>GetByKey</span><span class=p>(</span><span class=nx>id</span><span class=p>)</span>
        <span class=nx>_</span><span class=p>,</span> <span class=nx>itemsExist</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>id</span><span class=p>]</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>exists</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>itemsExist</span> <span class=p>{</span>
            <span class=c1>// Presumably, this was deleted when a relist happened.
</span><span class=c1></span>            <span class=c1>// Don&#39;t provide a second report of the same deletion.
</span><span class=c1></span>            <span class=c1>// TODO(lavalamp): This may be racy-- we aren&#39;t properly locked
</span><span class=c1></span>            <span class=c1>// with knownObjects.
</span><span class=c1></span>            <span class=k>return</span> <span class=kc>nil</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=nx>f</span><span class=p>.</span><span class=nf>queueActionLocked</span><span class=p>(</span><span class=nx>Deleted</span><span class=p>,</span> <span class=nx>obj</span><span class=p>)</span>
<span class=p>}</span>

<span class=c1>// AddIfNotPresent inserts an item, and puts it in the queue. If the item is already
</span><span class=c1>// present in the set, it is neither enqueued nor added to the set.
</span><span class=c1>//
</span><span class=c1>// This is useful in a single producer/consumer scenario so that the consumer can
</span><span class=c1>// safely retry items without contending with the producer and potentially enqueueing
</span><span class=c1>// stale items.
</span><span class=c1>//
</span><span class=c1>// Important: obj must be a Deltas (the output of the Pop() function). Yes, this is
</span><span class=c1>// different from the Add/Update/Delete functions.
</span><span class=c1>// 添加不存在的对象
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>DeltaFIFO</span><span class=p>)</span> <span class=nf>AddIfNotPresent</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=c1>// 这个要求放入的必须是Deltas数组，就是通过Pop（）弹出的对象
</span><span class=c1></span>    <span class=nx>deltas</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>obj</span><span class=p>.(</span><span class=nx>Deltas</span><span class=p>)</span>
    <span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;object must be of type deltas, but got: %#v&#34;</span><span class=p>,</span> <span class=nx>obj</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=c1>// 多个Delta都是一个对象，所以用最新的就可以了
</span><span class=c1></span>    <span class=nx>id</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nf>KeyOf</span><span class=p>(</span><span class=nx>deltas</span><span class=p>.</span><span class=nf>Newest</span><span class=p>().</span><span class=nx>Object</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>KeyError</span><span class=p>{</span><span class=nx>obj</span><span class=p>,</span> <span class=nx>err</span><span class=p>}</span>
    <span class=p>}</span>
    <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
    <span class=nx>f</span><span class=p>.</span><span class=nf>addIfNotPresent</span><span class=p>(</span><span class=nx>id</span><span class=p>,</span> <span class=nx>deltas</span><span class=p>)</span>
    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=c1>// addIfNotPresent inserts deltas under id if it does not exist, and assumes the caller
</span><span class=c1>// already holds the fifo lock.
</span><span class=c1>// 这个是添加不存在对象的实现
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>DeltaFIFO</span><span class=p>)</span> <span class=nf>addIfNotPresent</span><span class=p>(</span><span class=nx>id</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>deltas</span> <span class=nx>Deltas</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>f</span><span class=p>.</span><span class=nx>populated</span> <span class=p>=</span> <span class=kc>true</span>
    <span class=c1>// 这里判断的对象是否存在
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>exists</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>id</span><span class=p>];</span> <span class=nx>exists</span> <span class=p>{</span>
        <span class=k>return</span>
    <span class=p>}</span>
    <span class=c1>// 放入队列中
</span><span class=c1></span>    <span class=nx>f</span><span class=p>.</span><span class=nx>queue</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>f</span><span class=p>.</span><span class=nx>queue</span><span class=p>,</span> <span class=nx>id</span><span class=p>)</span>
    <span class=nx>f</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>id</span><span class=p>]</span> <span class=p>=</span> <span class=nx>deltas</span>
    <span class=nx>f</span><span class=p>.</span><span class=nx>cond</span><span class=p>.</span><span class=nf>Broadcast</span><span class=p>()</span>
<span class=p>}</span>

<span class=c1>// re-listing and watching can deliver the same update multiple times in any
</span><span class=c1>// order. This will combine the most recent two deltas if they are the same.
</span><span class=c1></span><span class=kd>func</span> <span class=nf>dedupDeltas</span><span class=p>(</span><span class=nx>deltas</span> <span class=nx>Deltas</span><span class=p>)</span> <span class=nx>Deltas</span> <span class=p>{</span>
    <span class=c1>// 小于2个delta，那就是1个呗，没啥好合并的
</span><span class=c1></span>    <span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>deltas</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>n</span> <span class=p>&lt;</span> <span class=mi>2</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>deltas</span>
    <span class=p>}</span>
    <span class=c1>// 取出最后两个
</span><span class=c1></span>    <span class=nx>a</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>deltas</span><span class=p>[</span><span class=nx>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
    <span class=nx>b</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>deltas</span><span class=p>[</span><span class=nx>n</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span>
    <span class=c1>// 判断如果是重复的，那就删除这两个delta把合并后的追加到Deltas数组尾部
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>out</span> <span class=o>:=</span> <span class=nf>isDup</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>);</span> <span class=nx>out</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=c1>// 使用deltas 前n-2 元素构造d，然后再把合并后的 out追加
</span><span class=c1></span>        <span class=nx>d</span> <span class=o>:=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>Deltas</span><span class=p>{},</span> <span class=nx>deltas</span><span class=p>[:</span><span class=nx>n</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span><span class=o>...</span><span class=p>)</span>
        <span class=k>return</span> <span class=nb>append</span><span class=p>(</span><span class=nx>d</span><span class=p>,</span> <span class=o>*</span><span class=nx>out</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>deltas</span>
<span class=p>}</span>

<span class=c1>// If a &amp; b represent the same event, returns the delta that ought to be kept.
</span><span class=c1>// Otherwise, returns nil.
</span><span class=c1>// TODO: is there anything other than deletions that need deduping?
</span><span class=c1>// 判断两个Delta是否是重复的
</span><span class=c1></span><span class=kd>func</span> <span class=nf>isDup</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=o>*</span><span class=nx>Delta</span><span class=p>)</span> <span class=o>*</span><span class=nx>Delta</span> <span class=p>{</span>
    <span class=c1>// 只有一个判断，只能判断是否为删除类操作，和我们上面的判断相同
</span><span class=c1></span>    <span class=c1>// 这个函数的本意应该还可以判断多种类型的重复，当前来看只能有删除这一种能够合并
</span><span class=c1></span>    <span class=c1>// 只合并obj前后操作类型都是delete的（即为重复）
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>out</span> <span class=o>:=</span> <span class=nf>isDeletionDup</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>);</span> <span class=nx>out</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>out</span>
    <span class=p>}</span>
    <span class=c1>// TODO: Detect other duplicate situations? Are there any?
</span><span class=c1></span>    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=c1>// keep the one with the most information if both are deletions.
</span><span class=c1>// 判断是否为删除类的重复
</span><span class=c1></span><span class=kd>func</span> <span class=nf>isDeletionDup</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=o>*</span><span class=nx>Delta</span><span class=p>)</span> <span class=o>*</span><span class=nx>Delta</span> <span class=p>{</span>
    <span class=c1>// 二者都是删除那肯定有一个是重复的
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>b</span><span class=p>.</span><span class=nx>Type</span> <span class=o>!=</span> <span class=nx>Deleted</span> <span class=o>||</span> <span class=nx>a</span><span class=p>.</span><span class=nx>Type</span> <span class=o>!=</span> <span class=nx>Deleted</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>nil</span>
    <span class=p>}</span>
    <span class=c1>// Do more sophisticated checks, or is this sufficient?
</span><span class=c1></span>    <span class=c1>// 理论上返回最后一个比较好，但是对象已经不再系统监控范围，前一个删除状态是好的
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>b</span><span class=p>.</span><span class=nx>Object</span><span class=p>.(</span><span class=nx>DeletedFinalStateUnknown</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>a</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>b</span>
<span class=p>}</span>

<span class=c1>// willObjectBeDeletedLocked returns true only if the last delta for the
</span><span class=c1>// given object is Delete. Caller must lock first.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>DeltaFIFO</span><span class=p>)</span> <span class=nf>willObjectBeDeletedLocked</span><span class=p>(</span><span class=nx>id</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
    <span class=nx>deltas</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>id</span><span class=p>]</span>
    <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=nx>deltas</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>deltas</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>deltas</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>].</span><span class=nx>Type</span> <span class=o>==</span> <span class=nx>Deleted</span>
<span class=p>}</span>

<span class=c1>// queueActionLocked appends to the delta list for the object, calling
</span><span class=c1>// f.deltaCompressor if needed. Caller must lock first.
</span><span class=c1>// 从函数名称来看把“动作”放入队列中，这个动作就是DeltaType，而且已经加锁了
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>DeltaFIFO</span><span class=p>)</span> <span class=nf>queueActionLocked</span><span class=p>(</span><span class=nx>actionType</span> <span class=nx>DeltaType</span><span class=p>,</span> <span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=c1>// 1 计算资源对象的key
</span><span class=c1></span>    <span class=nx>id</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nf>KeyOf</span><span class=p>(</span><span class=nx>obj</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>KeyError</span><span class=p>{</span><span class=nx>obj</span><span class=p>,</span> <span class=nx>err</span><span class=p>}</span>
    <span class=p>}</span>

    <span class=c1>// If object is supposed to be deleted (last event is Deleted),
</span><span class=c1></span>    <span class=c1>// then we should ignore Sync events, because it would result in
</span><span class=c1></span>    <span class=c1>// recreation of this object.
</span><span class=c1></span>    <span class=c1>// 2 如果操作类型是Sync，而对象被删除，则忽略Sync事件，直接返回
</span><span class=c1></span>    <span class=c1>// 如果是同步，并且对象未来会被删除，那么就直接返回，没必要记录这个动作了
</span><span class=c1></span>    <span class=c1>// 肯定有人会问为什么Add/Delete/Update这些动作可以，因为同步对于已经删除的对象是没有意义的
</span><span class=c1></span>    <span class=c1>// 已经删除的对象后续跟添加、更新有可能，因为同名的对象又被添加了，删除也是有可能
</span><span class=c1></span>    <span class=c1>// 删除有些复杂
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>actionType</span> <span class=o>==</span> <span class=nx>Sync</span> <span class=o>&amp;&amp;</span> <span class=nx>f</span><span class=p>.</span><span class=nf>willObjectBeDeletedLocked</span><span class=p>(</span><span class=nx>id</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>nil</span>
    <span class=p>}</span>
    <span class=c1>// 3 构造Delta{actionType, obj}，添加到newDeltas 的items[id]
</span><span class=c1></span>    <span class=c1>// 同一个对象的多次操作，所以要追加到Deltas数组f.items[id]中
</span><span class=c1></span>    <span class=nx>newDeltas</span> <span class=o>:=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>f</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>id</span><span class=p>],</span> <span class=nx>Delta</span><span class=p>{</span><span class=nx>actionType</span><span class=p>,</span> <span class=nx>obj</span><span class=p>})</span>
    <span class=c1>// 4 去重操作
</span><span class=c1></span>    <span class=c1>// 合并操作，去掉冗余的delta
</span><span class=c1></span>    <span class=nx>newDeltas</span> <span class=p>=</span> <span class=nf>dedupDeltas</span><span class=p>(</span><span class=nx>newDeltas</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>f</span><span class=p>.</span><span class=nx>deltaCompressor</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>newDeltas</span> <span class=p>=</span> <span class=nx>f</span><span class=p>.</span><span class=nx>deltaCompressor</span><span class=p>.</span><span class=nf>Compress</span><span class=p>(</span><span class=nx>newDeltas</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=c1>// 5. 如果有newDeltas，则通知所有消费者，解除阻塞
</span><span class=c1></span>    <span class=c1>// 判断对象是否已经存在
</span><span class=c1></span>    <span class=nx>_</span><span class=p>,</span> <span class=nx>exists</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>id</span><span class=p>]</span>
    <span class=c1>// 合并后操作有可能变成没有Delta么？后面的代码分析来看应该不会，所以暂时不知道这个判断目的
</span><span class=c1></span>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>newDeltas</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
        <span class=c1>// 如果对象没有存在过，那就放入队列中，如果存在说明已经在queue中了，也就没必要再添加了
</span><span class=c1></span>        <span class=c1>// f.queue 只保存 obj的id，即key
</span><span class=c1></span>        <span class=k>if</span> <span class=p>!</span><span class=nx>exists</span> <span class=p>{</span>
            <span class=nx>f</span><span class=p>.</span><span class=nx>queue</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>f</span><span class=p>.</span><span class=nx>queue</span><span class=p>,</span> <span class=nx>id</span><span class=p>)</span>
        <span class=p>}</span>
        <span class=c1>// 更新Deltas数组，通知所有调用Pop()的消费者模块
</span><span class=c1></span>        <span class=nx>f</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>id</span><span class=p>]</span> <span class=p>=</span> <span class=nx>newDeltas</span>
        <span class=nx>f</span><span class=p>.</span><span class=nx>cond</span><span class=p>.</span><span class=nf>Broadcast</span><span class=p>()</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>exists</span> <span class=p>{</span>
        <span class=c1>// The compression step removed all deltas, so
</span><span class=c1></span>        <span class=c1>// we need to remove this from our map (extra items
</span><span class=c1></span>        <span class=c1>// in the queue are ignored if they are not in the
</span><span class=c1></span>        <span class=c1>// map).
</span><span class=c1></span>        <span class=c1>// 直接把对象删除，这段代码不知道什么条件会进来，因为dedupDeltas()肯定有返回结果的
</span><span class=c1></span>        <span class=c1>// 这个分支不是消费者模块处理的，直接在delta_fifo处理了
</span><span class=c1></span>        <span class=nb>delete</span><span class=p>(</span><span class=nx>f</span><span class=p>.</span><span class=nx>items</span><span class=p>,</span> <span class=nx>id</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=c1>// List returns a list of all the items; it returns the object
</span><span class=c1>// from the most recent Delta.
</span><span class=c1>// You should treat the items returned inside the deltas as immutable.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>DeltaFIFO</span><span class=p>)</span> <span class=nf>List</span><span class=p>()</span> <span class=p>[]</span><span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
    <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
    <span class=k>return</span> <span class=nx>f</span><span class=p>.</span><span class=nf>listLocked</span><span class=p>()</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>DeltaFIFO</span><span class=p>)</span> <span class=nf>listLocked</span><span class=p>()</span> <span class=p>[]</span><span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
    <span class=nx>list</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kd>interface</span><span class=p>{},</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>f</span><span class=p>.</span><span class=nx>items</span><span class=p>))</span>
    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>item</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>f</span><span class=p>.</span><span class=nx>items</span> <span class=p>{</span>
        <span class=c1>// Copy item&#39;s slice so operations on this slice (delta
</span><span class=c1></span>        <span class=c1>// compression) won&#39;t interfere with the object we return.
</span><span class=c1></span>        <span class=nx>item</span> <span class=p>=</span> <span class=nf>copyDeltas</span><span class=p>(</span><span class=nx>item</span><span class=p>)</span>
        <span class=nx>list</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>list</span><span class=p>,</span> <span class=nx>item</span><span class=p>.</span><span class=nf>Newest</span><span class=p>().</span><span class=nx>Object</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>list</span>
<span class=p>}</span>

<span class=c1>// ListKeys returns a list of all the keys of the objects currently
</span><span class=c1>// in the FIFO.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>DeltaFIFO</span><span class=p>)</span> <span class=nf>ListKeys</span><span class=p>()</span> <span class=p>[]</span><span class=kt>string</span> <span class=p>{</span>
    <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
    <span class=nx>list</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>string</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>f</span><span class=p>.</span><span class=nx>items</span><span class=p>))</span>
    <span class=k>for</span> <span class=nx>key</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>f</span><span class=p>.</span><span class=nx>items</span> <span class=p>{</span>
        <span class=nx>list</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>list</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>list</span>
<span class=p>}</span>

<span class=c1>// Get returns the complete list of deltas for the requested item,
</span><span class=c1>// or sets exists=false.
</span><span class=c1>// You should treat the items returned inside the deltas as immutable.
</span><span class=c1>//Get返回请求项的完整deltas列表，或不存在，则将集合exists=false。
</span><span class=c1>//您应该将delta中返回的项视为不可变的。
</span><span class=c1>// 获取对象接口，这个有意思哈，用对象获取对象？如果说用Service对象获取Pod对象是不是就能接受了？
</span><span class=c1>// 因为他们的对象键是相同的
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>DeltaFIFO</span><span class=p>)</span> <span class=nf>Get</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>item</span> <span class=kd>interface</span><span class=p>{},</span> <span class=nx>exists</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>key</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nf>KeyOf</span><span class=p>(</span><span class=nx>obj</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>KeyError</span><span class=p>{</span><span class=nx>obj</span><span class=p>,</span> <span class=nx>err</span><span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>f</span><span class=p>.</span><span class=nf>GetByKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span>
<span class=p>}</span>

<span class=c1>// GetByKey returns the complete list of deltas for the requested item,
</span><span class=c1>// setting exists=false if that list is empty.
</span><span class=c1>// You should treat the items returned inside the deltas as immutable.
</span><span class=c1>// 通过对象键获取对象
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>DeltaFIFO</span><span class=p>)</span> <span class=nf>GetByKey</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>item</span> <span class=kd>interface</span><span class=p>{},</span> <span class=nx>exists</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
    <span class=nx>d</span><span class=p>,</span> <span class=nx>exists</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span>
    <span class=k>if</span> <span class=nx>exists</span> <span class=p>{</span>
        <span class=c1>// Copy item&#39;s slice so operations on this slice (delta
</span><span class=c1></span>        <span class=c1>// compression) won&#39;t interfere with the object we return.
</span><span class=c1></span>        <span class=nx>d</span> <span class=p>=</span> <span class=nf>copyDeltas</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>d</span><span class=p>,</span> <span class=nx>exists</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=c1>// Checks if the queue is closed
</span><span class=c1>// 判断是否关闭
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>DeltaFIFO</span><span class=p>)</span> <span class=nf>IsClosed</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
    <span class=nx>f</span><span class=p>.</span><span class=nx>closedLock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nx>closedLock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
    <span class=k>if</span> <span class=nx>f</span><span class=p>.</span><span class=nx>closed</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>true</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=kc>false</span>
<span class=p>}</span>

<span class=c1>// Pop blocks until an item is added to the queue, and then returns it.  If
</span><span class=c1>// multiple items are ready, they are returned in the order in which they were
</span><span class=c1>// added/updated. The item is removed from the queue (and the store) before it
</span><span class=c1>// is returned, so if you don&#39;t successfully process it, you need to add it back
</span><span class=c1>// with AddIfNotPresent().
</span><span class=c1>// process function is called under lock, so it is safe update data structures
</span><span class=c1>// in it that need to be in sync with the queue (e.g. knownKeys). The PopProcessFunc
</span><span class=c1>// may return an instance of ErrRequeue with a nested error to indicate the current
</span><span class=c1>// item should be requeued (equivalent to calling AddIfNotPresent under the lock).
</span><span class=c1>//
</span><span class=c1>// Pop returns a &#39;Deltas&#39;, which has a complete list of all the things
</span><span class=c1>// that happened to the object (deltas) while it was sitting in the queue.
</span><span class=c1>// 对queue中的资源对象数据进行process处理
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>DeltaFIFO</span><span class=p>)</span> <span class=nf>Pop</span><span class=p>(</span><span class=nx>process</span> <span class=nx>PopProcessFunc</span><span class=p>)</span> <span class=p>(</span><span class=kd>interface</span><span class=p>{},</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// DeltaFIFO 处理，加锁
</span><span class=c1></span>    <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
    <span class=k>for</span> <span class=p>{</span>
        <span class=c1>// 队列中有数据么？
</span><span class=c1></span>        <span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>f</span><span class=p>.</span><span class=nx>queue</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
            <span class=c1>// When the queue is empty, invocation of Pop() is blocked until new item is enqueued.
</span><span class=c1></span>            <span class=c1>// When Close() is called, the f.closed is set and the condition is broadcasted.
</span><span class=c1></span>            <span class=c1>// Which causes this loop to continue and return from the Pop().
</span><span class=c1></span>            <span class=c1>// 看来是先判断的是否有数据，后判断是否关闭，这个和chan像
</span><span class=c1></span>            <span class=k>if</span> <span class=nx>f</span><span class=p>.</span><span class=nf>IsClosed</span><span class=p>()</span> <span class=p>{</span>
                <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>FIFOClosedError</span>
            <span class=p>}</span>
            <span class=c1>// 没数据那就等待
</span><span class=c1></span>            <span class=c1>// 阻塞处理，直到队列有数据添加，此时len(f.queue) &gt; 0, 跳出该for{}，执行后续pop处理流程
</span><span class=c1></span>            <span class=nx>f</span><span class=p>.</span><span class=nx>cond</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
        <span class=p>}</span>
        <span class=c1>// 取出第一个对象
</span><span class=c1></span>        <span class=c1>// 取出id 即object的key
</span><span class=c1></span>        <span class=nx>id</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nx>queue</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
        <span class=c1>// 数组缩小，相当于把数组中的第一个元素弹出去了
</span><span class=c1></span>        <span class=c1>// 去掉一个pod的id，更新queue
</span><span class=c1></span>        <span class=nx>f</span><span class=p>.</span><span class=nx>queue</span> <span class=p>=</span> <span class=nx>f</span><span class=p>.</span><span class=nx>queue</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
        <span class=c1>// 取出对象，因为queue中存的是对象键
</span><span class=c1></span>        <span class=c1>// 根据id 检索item 即某object所有的事件Deltas
</span><span class=c1></span>        <span class=nx>item</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>id</span><span class=p>]</span>
        <span class=c1>// 同步对象计数减一，当减到0就说明外部已经全部同步完毕了
</span><span class=c1></span>        <span class=k>if</span> <span class=nx>f</span><span class=p>.</span><span class=nx>initialPopulationCount</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
            <span class=nx>f</span><span class=p>.</span><span class=nx>initialPopulationCount</span><span class=o>--</span>
        <span class=p>}</span>
        <span class=c1>// 对象不存在，这个是什么情况？貌似我们在合并对象的时候代码上有这个逻辑，估计永远不会执行
</span><span class=c1></span>        <span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
            <span class=c1>// Item may have been deleted subsequently.
</span><span class=c1></span>            <span class=k>continue</span>
        <span class=p>}</span>
        <span class=c1>// 把对象删除
</span><span class=c1></span>        <span class=c1>// 删除要处理的item的Deltas
</span><span class=c1></span>        <span class=nb>delete</span><span class=p>(</span><span class=nx>f</span><span class=p>.</span><span class=nx>items</span><span class=p>,</span> <span class=nx>id</span><span class=p>)</span>
        <span class=c1>// Pop()需要传入一个回调函数，用于处理对象
</span><span class=c1></span>        <span class=c1>// 处理该id-object的所有事件Deltas
</span><span class=c1></span>        <span class=nx>err</span> <span class=o>:=</span> <span class=nf>process</span><span class=p>(</span><span class=nx>item</span><span class=p>)</span>
        <span class=c1>// 如果需要重新入队列，那就重新入队列
</span><span class=c1></span>        <span class=k>if</span> <span class=nx>e</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>err</span><span class=p>.(</span><span class=nx>ErrRequeue</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
            <span class=nx>f</span><span class=p>.</span><span class=nf>addIfNotPresent</span><span class=p>(</span><span class=nx>id</span><span class=p>,</span> <span class=nx>item</span><span class=p>)</span>
            <span class=nx>err</span> <span class=p>=</span> <span class=nx>e</span><span class=p>.</span><span class=nx>Err</span>
        <span class=p>}</span>
        <span class=c1>// Don&#39;t need to copyDeltas here, because we&#39;re transferring
</span><span class=c1></span>        <span class=c1>// ownership to the caller.
</span><span class=c1></span>        <span class=k>return</span> <span class=nx>item</span><span class=p>,</span> <span class=nx>err</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=c1>// Replace will delete the contents of &#39;f&#39;, using instead the given map.
</span><span class=c1>// &#39;f&#39; takes ownership of the map, you should not reference the map again
</span><span class=c1>// after calling this function. f&#39;s queue is reset, too; upon return, it
</span><span class=c1>// will contain the items in the map, in no particular order.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>DeltaFIFO</span><span class=p>)</span> <span class=nf>Replace</span><span class=p>(</span><span class=nx>list</span> <span class=p>[]</span><span class=kd>interface</span><span class=p>{},</span> <span class=nx>resourceVersion</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
    <span class=nx>keys</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=nx>sets</span><span class=p>.</span><span class=nx>String</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>list</span><span class=p>))</span>
    <span class=c1>// 遍历所有的输入目标
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>item</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>list</span> <span class=p>{</span>
        <span class=c1>// 计算目标键
</span><span class=c1></span>        <span class=nx>key</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nf>KeyOf</span><span class=p>(</span><span class=nx>item</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=k>return</span> <span class=nx>KeyError</span><span class=p>{</span><span class=nx>item</span><span class=p>,</span> <span class=nx>err</span><span class=p>}</span>
        <span class=p>}</span>
        <span class=c1>// 记录处理过的目标键，采用set存储，是为了后续快速查找
</span><span class=c1></span>        <span class=nx>keys</span><span class=p>.</span><span class=nf>Insert</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span>
        <span class=c1>// 因为输入是目标全量，所以每个目标相当于重新同步了一次
</span><span class=c1></span>        <span class=c1>// 每个obj进行同步
</span><span class=c1></span>        <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nf>queueActionLocked</span><span class=p>(</span><span class=nx>Sync</span><span class=p>,</span> <span class=nx>item</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;couldn&#39;t enqueue object: %v&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=c1>// 如果没有存储的话，自己存储的就是所有的老对象，目的要看看哪些老对象不在全量集合中，那么就是删除的对象了
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>f</span><span class=p>.</span><span class=nx>knownObjects</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=c1>// Do deletion detection against our own list.
</span><span class=c1></span>        <span class=c1>// 遍历所有的元素
</span><span class=c1></span>        <span class=k>for</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>oldItem</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>f</span><span class=p>.</span><span class=nx>items</span> <span class=p>{</span>
            <span class=c1>// 这个目标在输入的对象中存在就可以忽略
</span><span class=c1></span>            <span class=c1>// 因为输入对象keys是要更新替换（replace）到存储（indexer）中的obj
</span><span class=c1></span>            <span class=k>if</span> <span class=nx>keys</span><span class=p>.</span><span class=nf>Has</span><span class=p>(</span><span class=nx>k</span><span class=p>)</span> <span class=p>{</span>
                <span class=k>continue</span>
            <span class=p>}</span>
            <span class=c1>// 输入对象中没有，说明对象已经被删除了
</span><span class=c1></span>            <span class=kd>var</span> <span class=nx>deletedObj</span> <span class=kd>interface</span><span class=p>{}</span>
            <span class=k>if</span> <span class=nx>n</span> <span class=o>:=</span> <span class=nx>oldItem</span><span class=p>.</span><span class=nf>Newest</span><span class=p>();</span> <span class=nx>n</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
                <span class=nx>deletedObj</span> <span class=p>=</span> <span class=nx>n</span><span class=p>.</span><span class=nx>Object</span>
            <span class=p>}</span>
            <span class=c1>// 终于看到哪里用到DeletedFinalStateUnknown了，队列中存储对象的Deltas数组中
</span><span class=c1></span>            <span class=c1>// 可能已经存在Delete了，避免重复，采用DeletedFinalStateUnknown这种类型
</span><span class=c1></span>            <span class=c1>// DeletedFinalStateUnknown 状态：是delat_fifo本地检查出该obj要删除，但是没有从list-watch到这个ojb的删除事件（可能丢失或延时）
</span><span class=c1></span>            <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nf>queueActionLocked</span><span class=p>(</span><span class=nx>Deleted</span><span class=p>,</span> <span class=nx>DeletedFinalStateUnknown</span><span class=p>{</span><span class=nx>k</span><span class=p>,</span> <span class=nx>deletedObj</span><span class=p>});</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
                <span class=k>return</span> <span class=nx>err</span>
            <span class=p>}</span>
        <span class=p>}</span>
        <span class=c1>// 如果populated还没有设置，说明是第一次并且还没有任何修改操作执行过
</span><span class=c1></span>        <span class=c1>// 队列中第1次输入数据，设置标志符号和initialPopulationCount
</span><span class=c1></span>        <span class=k>if</span> <span class=p>!</span><span class=nx>f</span><span class=p>.</span><span class=nx>populated</span> <span class=p>{</span>
            <span class=nx>f</span><span class=p>.</span><span class=nx>populated</span> <span class=p>=</span> <span class=kc>true</span>
            <span class=nx>f</span><span class=p>.</span><span class=nx>initialPopulationCount</span> <span class=p>=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>list</span><span class=p>)</span>
        <span class=p>}</span>

        <span class=k>return</span> <span class=kc>nil</span>
    <span class=p>}</span>

    <span class=c1>// Detect deletions not already in the queue.
</span><span class=c1></span>    <span class=c1>// TODO(lavalamp): This may be racy-- we aren&#39;t properly locked
</span><span class=c1></span>    <span class=c1>// with knownObjects. Unproven.
</span><span class=c1></span>    <span class=c1>// 下面处理的就是检测某些目标删除但是Delta没有在队列中
</span><span class=c1></span>    <span class=c1>// 从存储中获取所有对象键
</span><span class=c1></span>    <span class=nx>knownKeys</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nx>knownObjects</span><span class=p>.</span><span class=nf>ListKeys</span><span class=p>()</span>
    <span class=nx>queuedDeletions</span> <span class=o>:=</span> <span class=mi>0</span>
    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>k</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>knownKeys</span> <span class=p>{</span>
        <span class=c1>// knownKeys存储的对象还在目标对象keys中，那就忽略
</span><span class=c1></span>        <span class=k>if</span> <span class=nx>keys</span><span class=p>.</span><span class=nf>Has</span><span class=p>(</span><span class=nx>k</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>continue</span>
        <span class=p>}</span>
        <span class=c1>// 获取待deletedObj对象
</span><span class=c1></span>        <span class=nx>deletedObj</span><span class=p>,</span> <span class=nx>exists</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nx>knownObjects</span><span class=p>.</span><span class=nf>GetByKey</span><span class=p>(</span><span class=nx>k</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nx>deletedObj</span> <span class=p>=</span> <span class=kc>nil</span>
            <span class=nx>glog</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;Unexpected error %v during lookup of key %v, placing DeleteFinalStateUnknown marker without object&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>,</span> <span class=nx>k</span><span class=p>)</span>
        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>!</span><span class=nx>exists</span> <span class=p>{</span>
            <span class=nx>deletedObj</span> <span class=p>=</span> <span class=kc>nil</span>
            <span class=nx>glog</span><span class=p>.</span><span class=nf>Infof</span><span class=p>(</span><span class=s>&#34;Key %v does not exist in known objects store, placing DeleteFinalStateUnknown marker without object&#34;</span><span class=p>,</span> <span class=nx>k</span><span class=p>)</span>
        <span class=p>}</span>
        <span class=c1>// 累积删除的对象数量
</span><span class=c1></span>        <span class=nx>queuedDeletions</span><span class=o>++</span>
        <span class=c1>// 把对象删除的Delta放入队列
</span><span class=c1></span>        <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nf>queueActionLocked</span><span class=p>(</span><span class=nx>Deleted</span><span class=p>,</span> <span class=nx>DeletedFinalStateUnknown</span><span class=p>{</span><span class=nx>k</span><span class=p>,</span> <span class=nx>deletedObj</span><span class=p>});</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=k>return</span> <span class=nx>err</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=c1>// 和上面的代码差不多，只是计算initialPopulationCount值的时候增加了删除对象的数量
</span><span class=c1></span>    <span class=k>if</span> <span class=p>!</span><span class=nx>f</span><span class=p>.</span><span class=nx>populated</span> <span class=p>{</span>
        <span class=nx>f</span><span class=p>.</span><span class=nx>populated</span> <span class=p>=</span> <span class=kc>true</span>
        <span class=nx>f</span><span class=p>.</span><span class=nx>initialPopulationCount</span> <span class=p>=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>list</span><span class=p>)</span> <span class=o>+</span> <span class=nx>queuedDeletions</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=c1>// Resync will send a sync event for each item
</span><span class=c1>// 重新同步，这个在cache实现是空的，这里面有具体实现
</span><span class=c1>// 把knownObjects的objs同步更新到delta_fifo中
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>DeltaFIFO</span><span class=p>)</span> <span class=nf>Resync</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
    <span class=c1>// 如果没有Indexer那么重新同步是没有意义的，因为连同步了哪些对象都不知道
</span><span class=c1></span>    <span class=c1>// 列举Indexer里面所有的对象键
</span><span class=c1></span>    <span class=nx>keys</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nx>knownObjects</span><span class=p>.</span><span class=nf>ListKeys</span><span class=p>()</span>
    <span class=c1>// 遍历对象键，为每个对象产生一个同步的Delta
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>k</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>keys</span> <span class=p>{</span>
        <span class=c1>// 具体对象同步实现接口
</span><span class=c1></span>        <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nf>syncKeyLocked</span><span class=p>(</span><span class=nx>k</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=k>return</span> <span class=nx>err</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>DeltaFIFO</span><span class=p>)</span> <span class=nf>syncKey</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>

    <span class=k>return</span> <span class=nx>f</span><span class=p>.</span><span class=nf>syncKeyLocked</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span>
<span class=p>}</span>
<span class=c1>// 具体对象同步实现接口
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>DeltaFIFO</span><span class=p>)</span> <span class=nf>syncKeyLocked</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=c1>// 获取对象
</span><span class=c1></span>    <span class=nx>obj</span><span class=p>,</span> <span class=nx>exists</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nx>knownObjects</span><span class=p>.</span><span class=nf>GetByKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>glog</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;Unexpected error %v during lookup of key %v, unable to queue object for sync&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
        <span class=k>return</span> <span class=kc>nil</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>!</span><span class=nx>exists</span> <span class=p>{</span>
        <span class=nx>glog</span><span class=p>.</span><span class=nf>Infof</span><span class=p>(</span><span class=s>&#34;Key %v does not exist in known objects store, unable to queue object for sync&#34;</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
        <span class=k>return</span> <span class=kc>nil</span>
    <span class=p>}</span>

    <span class=c1>// If we are doing Resync() and there is already an event queued for that object,
</span><span class=c1></span>    <span class=c1>// we ignore the Resync for it. This is to avoid the race, in which the resync
</span><span class=c1></span>    <span class=c1>// comes with the previous value of object (since queueing an event for the object
</span><span class=c1></span>    <span class=c1>// doesn&#39;t trigger changing the underlying store &lt;knownObjects&gt;.
</span><span class=c1></span>    <span class=c1>// 计算对象的键值，有人会问对象键不是已经传入了么？那个是存在Indexer里面的对象键，可能与这里的计算方式不同
</span><span class=c1></span>    <span class=nx>id</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nf>KeyOf</span><span class=p>(</span><span class=nx>obj</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>KeyError</span><span class=p>{</span><span class=nx>obj</span><span class=p>,</span> <span class=nx>err</span><span class=p>}</span>
    <span class=p>}</span>
    <span class=c1>// 对象已经在存在，说明后续会通知对象的新变化，所以再加更新也没意义
</span><span class=c1></span>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>f</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>id</span><span class=p>])</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>nil</span>
    <span class=p>}</span>
    <span class=c1>// 添加对象同步的这个Delta
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>.</span><span class=nf>queueActionLocked</span><span class=p>(</span><span class=nx>Sync</span><span class=p>,</span> <span class=nx>obj</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;couldn&#39;t queue object: %v&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=c1>// A KeyListerGetter is anything that knows how to list its keys and look up by key.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>KeyListerGetter</span> <span class=kd>interface</span> <span class=p>{</span>
    <span class=nx>KeyLister</span>
    <span class=nx>KeyGetter</span>
<span class=p>}</span>

<span class=c1>// A KeyLister is anything that knows how to list its keys.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>KeyLister</span> <span class=kd>interface</span> <span class=p>{</span>
    <span class=nf>ListKeys</span><span class=p>()</span> <span class=p>[]</span><span class=kt>string</span>
<span class=p>}</span>

<span class=c1>// A KeyGetter is anything that knows how to get the value stored under a given key.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>KeyGetter</span> <span class=kd>interface</span> <span class=p>{</span>
    <span class=nf>GetByKey</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=kd>interface</span><span class=p>{},</span> <span class=kt>bool</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
<span class=p>}</span>

<span class=c1>// DeltaCompressor is an algorithm that removes redundant changes.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>DeltaCompressor</span> <span class=kd>interface</span> <span class=p>{</span>
    <span class=nf>Compress</span><span class=p>(</span><span class=nx>Deltas</span><span class=p>)</span> <span class=nx>Deltas</span>
<span class=p>}</span>

<span class=c1>// DeltaCompressorFunc should remove redundant changes; but changes that
</span><span class=c1>// are redundant depend on one&#39;s desired semantics, so this is an
</span><span class=c1>// injectable function.
</span><span class=c1>//
</span><span class=c1>// DeltaCompressorFunc adapts a raw function to be a DeltaCompressor.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>DeltaCompressorFunc</span> <span class=kd>func</span><span class=p>(</span><span class=nx>Deltas</span><span class=p>)</span> <span class=nx>Deltas</span>

<span class=c1>// Compress just calls dc.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=nx>DeltaCompressorFunc</span><span class=p>)</span> <span class=nf>Compress</span><span class=p>(</span><span class=nx>d</span> <span class=nx>Deltas</span><span class=p>)</span> <span class=nx>Deltas</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nf>dc</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
<span class=p>}</span>

<span class=c1>// DeltaType is the type of a change (addition, deletion, etc)
</span><span class=c1></span><span class=kd>type</span> <span class=nx>DeltaType</span> <span class=kt>string</span>

<span class=kd>const</span> <span class=p>(</span>
    <span class=nx>Added</span>   <span class=nx>DeltaType</span> <span class=p>=</span> <span class=s>&#34;Added&#34;</span>
    <span class=nx>Updated</span> <span class=nx>DeltaType</span> <span class=p>=</span> <span class=s>&#34;Updated&#34;</span>
    <span class=nx>Deleted</span> <span class=nx>DeltaType</span> <span class=p>=</span> <span class=s>&#34;Deleted&#34;</span>
    <span class=c1>// The other types are obvious. You&#39;ll get Sync deltas when:
</span><span class=c1></span>    <span class=c1>//  * A watch expires/errors out and a new list/watch cycle is started.
</span><span class=c1></span>    <span class=c1>//  * You&#39;ve turned on periodic syncs.
</span><span class=c1></span>    <span class=c1>// (Anything that trigger&#39;s DeltaFIFO&#39;s Replace() method.)
</span><span class=c1></span>    <span class=nx>Sync</span> <span class=nx>DeltaType</span> <span class=p>=</span> <span class=s>&#34;Sync&#34;</span>
<span class=p>)</span>

<span class=c1>// Delta is the type stored by a DeltaFIFO. It tells you what change
</span><span class=c1>// happened, and the object&#39;s state after* that change.
</span><span class=c1>//
</span><span class=c1>// [*] Unless the change is a deletion, and then you&#39;ll get the final
</span><span class=c1>//     state of the object before it was deleted.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Delta</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>Type</span>   <span class=nx>DeltaType</span>
    <span class=nx>Object</span> <span class=kd>interface</span><span class=p>{}</span>
<span class=p>}</span>

<span class=c1>// Deltas is a list of one or more &#39;Delta&#39;s to an individual object.
</span><span class=c1>// The oldest delta is at index 0, the newest delta is the last one.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Deltas</span> <span class=p>[]</span><span class=nx>Delta</span>

<span class=c1>// Oldest is a convenience function that returns the oldest delta, or
</span><span class=c1>// nil if there are no deltas.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>d</span> <span class=nx>Deltas</span><span class=p>)</span> <span class=nf>Oldest</span><span class=p>()</span> <span class=o>*</span><span class=nx>Delta</span> <span class=p>{</span>
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
        <span class=k>return</span> <span class=o>&amp;</span><span class=nx>d</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=c1>// Newest is a convenience function that returns the newest delta, or
</span><span class=c1>// nil if there are no deltas.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>d</span> <span class=nx>Deltas</span><span class=p>)</span> <span class=nf>Newest</span><span class=p>()</span> <span class=o>*</span><span class=nx>Delta</span> <span class=p>{</span>
    <span class=k>if</span> <span class=nx>n</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>d</span><span class=p>);</span> <span class=nx>n</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
        <span class=k>return</span> <span class=o>&amp;</span><span class=nx>d</span><span class=p>[</span><span class=nx>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=c1>// copyDeltas returns a shallow copy of d; that is, it copies the slice but not
</span><span class=c1>// the objects in the slice. This allows Get/List to return an object that we
</span><span class=c1>// know won&#39;t be clobbered by a subsequent call to a delta compressor.
</span><span class=c1></span><span class=kd>func</span> <span class=nf>copyDeltas</span><span class=p>(</span><span class=nx>d</span> <span class=nx>Deltas</span><span class=p>)</span> <span class=nx>Deltas</span> <span class=p>{</span>
    <span class=nx>d2</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=nx>Deltas</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>d</span><span class=p>))</span>
    <span class=nb>copy</span><span class=p>(</span><span class=nx>d2</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
    <span class=k>return</span> <span class=nx>d2</span>
<span class=p>}</span>

<span class=c1>// DeletedFinalStateUnknown is placed into a DeltaFIFO in the case where
</span><span class=c1>// an object was deleted but the watch deletion event was missed. In this
</span><span class=c1>// case we don&#39;t know the final &#34;resting&#34; state of the object, so there&#39;s
</span><span class=c1>// a chance the included `Obj` is stale.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>DeletedFinalStateUnknown</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>Key</span> <span class=kt>string</span>
    <span class=nx>Obj</span> <span class=kd>interface</span><span class=p>{}</span>
<span class=p>}</span>


</code></pre></td></tr></table></div></div><p>主要处理函数</p><ul><li><p>queueActionLocked：生产者方法，relactor调用，主要处理obj的的入队和保存</p></li><li><p>pop：消费者方法，conroller通过DeltaFIFO的process回调函数HandleDeltas处理</p></li><li><p>从Replace()的实现来看，主要用于实现对象的全量更新。这个可以理解为DeltaFIFO在必要的时刻做一次全量更新，这个时刻可以是定期的，也可以是事件触发的。由于DeltaFIFO对外输出的就是所有目标的增量变化，所以每次全量更新都要判断对象是否已经删除，因为在全量更新前可能没有收到目标删除的请求。这一点与cache不同，cache的Replace()相当于重建，因为cache就是对象全量的一种内存映射，所以Replace()就等于重建。</p></li><li><p>那我来问题一个非常有水平的问题，为什么knownObjects为nil时需要对比队列和对象全量来判断对象是否删除，而knownObjects不为空的时候就不需要了？如果读者想判断自己是否已经全部理解可以不看下面自己想想。</p><ul><li>knownObjects就是Indexer(具体实现是cache)，而开篇的那副图已经非常明确的描述了二者以及使用之间的关系。也就是说knownObjects有的对象就是使用者知道的所有对象，此时即便队列(DeltaFIFO)中有相应的对象，在更新的全量对象中又被删除了，那就没必要通知使用者对象删除了，这种情况可以假想为系统短时间添加并删除了对象，对使用者来说等同于没有这个对象。</li></ul></li></ul><h3 id=说明-2>说明</h3><ul><li>判断是否已同步populated和initialPopulationCount这两个变量存在的目的是什么？我的理解是否已同步指的是第一次从apiserver获取全量对象是否已经全部通知到外部，也就是通过Pop()被取走。所谓的同步就是指apiserver的状态已经同步到缓存中了，也就是Indexer中；</li><li>接口AddIfNotPresent()存在的目的是什么，只有在Pop()函数中使用了一次，但是在调用这个接口的时候已经从map中删除了，所以肯定不存在。这个接口在我看来主要用来保险的，因为Pop()本身就存在重入队列的可能，外部如果判断返回错误重入队列就可能会重复；
最后，我们还是用一幅图来总结一下</li></ul><img src=delta-queue.png style=width:100%><h2 id=index>Index</h2><p>index 就是带索引器的本地缓存</p><h3 id=index-1>index</h3><p>tools/cache/index.go</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span><span class=lnt>87
</span><span class=lnt>88
</span><span class=lnt>89
</span><span class=lnt>90
</span><span class=lnt>91
</span><span class=lnt>92
</span><span class=lnt>93
</span><span class=lnt>94
</span><span class=lnt>95
</span><span class=lnt>96
</span><span class=lnt>97
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go>

<span class=kn>package</span> <span class=nx>cache</span>

<span class=kn>import</span> <span class=p>(</span>
    <span class=s>&#34;fmt&#34;</span>

    <span class=s>&#34;k8s.io/apimachinery/pkg/api/meta&#34;</span>
    <span class=s>&#34;k8s.io/apimachinery/pkg/util/sets&#34;</span>
<span class=p>)</span>

<span class=c1>// Indexer is a storage interface that lets you list objects using multiple indexing functions
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Indexer</span> <span class=kd>interface</span> <span class=p>{</span>
    <span class=nx>Store</span>
    <span class=c1>// Retrieve list of objects that match on the named indexing function
</span><span class=c1></span>    <span class=c1>// indexName索引类，obj是对象，计算obj在indexName索引类中的索引键，通过索引键把所有的对象取出来
</span><span class=c1></span>    <span class=c1>// 基本就是获取符合obj特征的所有对象，所谓的特征就是对象在索引类中的索引键
</span><span class=c1></span>    <span class=nf>Index</span><span class=p>(</span><span class=nx>indexName</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>([]</span><span class=kd>interface</span><span class=p>{},</span> <span class=kt>error</span><span class=p>)</span>
    <span class=c1>// IndexKeys returns the set of keys that match on the named indexing function.
</span><span class=c1></span>    <span class=c1>// indexKey是indexName索引类中一个索引键，函数返回indexKey指定的所有对象键
</span><span class=c1></span>    <span class=c1>// 这个对象键是Indexer内唯一的，在添加的时候会计算
</span><span class=c1></span>    <span class=nf>IndexKeys</span><span class=p>(</span><span class=nx>indexName</span><span class=p>,</span> <span class=nx>indexKey</span> <span class=kt>string</span><span class=p>)</span> <span class=p>([]</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
    <span class=c1>// ListIndexFuncValues returns the list of generated values of an Index func
</span><span class=c1></span>    <span class=c1>// 获取indexName索引类中的所有索引键
</span><span class=c1></span>    <span class=nf>ListIndexFuncValues</span><span class=p>(</span><span class=nx>indexName</span> <span class=kt>string</span><span class=p>)</span> <span class=p>[]</span><span class=kt>string</span>
    <span class=c1>// ByIndex lists object that match on the named indexing function with the exact key
</span><span class=c1></span>    <span class=c1>// 这个函数和Index类似，只是返回值不是对象键，而是所有对象
</span><span class=c1></span>    <span class=nf>ByIndex</span><span class=p>(</span><span class=nx>indexName</span><span class=p>,</span> <span class=nx>indexKey</span> <span class=kt>string</span><span class=p>)</span> <span class=p>([]</span><span class=kd>interface</span><span class=p>{},</span> <span class=kt>error</span><span class=p>)</span>
    <span class=c1>// GetIndexer return the indexers
</span><span class=c1></span>    <span class=c1>// 返回Indexers
</span><span class=c1></span>    <span class=nf>GetIndexers</span><span class=p>()</span> <span class=nx>Indexers</span>

    <span class=c1>// AddIndexers adds more indexers to this store.  If you call this after you already have data
</span><span class=c1></span>    <span class=c1>// in the store, the results are undefined.
</span><span class=c1></span>    <span class=c1>// 添加Indexers，就是增加更多的索引分类
</span><span class=c1></span>    <span class=nf>AddIndexers</span><span class=p>(</span><span class=nx>newIndexers</span> <span class=nx>Indexers</span><span class=p>)</span> <span class=kt>error</span>
<span class=p>}</span>

<span class=c1>// IndexFunc knows how to provide an indexed value for an object.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>IndexFunc</span> <span class=kd>func</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>([]</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>

<span class=c1>// IndexFuncToKeyFuncAdapter adapts an indexFunc to a keyFunc.  This is only useful if your index function returns
</span><span class=c1>// unique values for every object.  This is conversion can create errors when more than one key is found.  You
</span><span class=c1>// should prefer to make proper key and index functions.
</span><span class=c1></span><span class=kd>func</span> <span class=nf>IndexFuncToKeyFuncAdapter</span><span class=p>(</span><span class=nx>indexFunc</span> <span class=nx>IndexFunc</span><span class=p>)</span> <span class=nx>KeyFunc</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>indexKeys</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>indexFunc</span><span class=p>(</span><span class=nx>obj</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=k>return</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=nx>err</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>indexKeys</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>1</span> <span class=p>{</span>
            <span class=k>return</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;too many keys: %v&#34;</span><span class=p>,</span> <span class=nx>indexKeys</span><span class=p>)</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>indexKeys</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
            <span class=k>return</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;unexpected empty indexKeys&#34;</span><span class=p>)</span>
        <span class=p>}</span>
        <span class=k>return</span> <span class=nx>indexKeys</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=kc>nil</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kd>const</span> <span class=p>(</span>
    <span class=nx>NamespaceIndex</span> <span class=kt>string</span> <span class=p>=</span> <span class=s>&#34;namespace&#34;</span>
<span class=p>)</span>

<span class=c1>// MetaNamespaceIndexFunc is a default index function that indexes based on an object&#39;s namespace
</span><span class=c1></span><span class=kd>func</span> <span class=nf>MetaNamespaceIndexFunc</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>([]</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>meta</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>meta</span><span class=p>.</span><span class=nf>Accessor</span><span class=p>(</span><span class=nx>obj</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;&#34;</span><span class=p>},</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;object has no meta: %v&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=nx>meta</span><span class=p>.</span><span class=nf>GetNamespace</span><span class=p>()},</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=c1>// Index maps the indexed value to a set of keys in the store that match on that value
</span><span class=c1>// sets.String 保存的是 本地缓存的key set，
</span><span class=c1>// 这个map的key 即为索引值keyvalue，比如usernmae1
</span><span class=c1>// map[string]sets.String map[username1]{default/pod1, default/pod2}
</span><span class=c1>// Index 索引器，包含不同keyvalue的map
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Index</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>sets</span><span class=p>.</span><span class=nx>String</span>

<span class=c1>// sets.String is a set of strings, implemented via map[string]struct{} for minimal memory consumption.
</span><span class=c1>// sets.String 保存的是 本地缓存的key set，即cache items存储obj的key
</span><span class=c1>//type String map[string]Empty
</span><span class=c1></span>
<span class=c1>// Indexers maps a name to a IndexFunc
</span><span class=c1>// 计算索引的函数有很多, 采用map，用名字分类
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Indexers</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>IndexFunc</span>
<span class=c1>// 计算索引的函数，传入对象，输出字符串索引，注意是数组哦！
</span><span class=c1>//type IndexFunc func(obj interface{}) ([]string, error)
</span><span class=c1></span>
<span class=c1>// Indices maps a name to an Index
</span><span class=c1>// 由于有多种计算索引的方式，那就又要按照计算索引的方式组织索引
</span><span class=c1>// Indices的 key 即为 Indexers的key
</span><span class=c1>// Indices 索引器map，包含不同命名的索引器
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Indices</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>Index</span>


</code></pre></td></tr></table></div></div><ul><li>Indexer->Store就是缓存接口</li><li>cache实现了store接口</li><li>数据对象缓存到了cache.cacheStorage ThreadSafeStore</li><li>ThreadSafeStore 是线程安全的</li></ul><p>所谓索引，索引目的就是为了快速查找。比如，我们需要查找某个节点上的所有Pod，那就要Pod按照节点名称排序，对应上面的Index类型就是map[nodename]sets.podname。我们可能有很多种查找方式，这就是Indexers这个类型作用了。
<img src=index.png style=width:100%></p><ul><li>IndexFunc1&mldr;..这些都是索引函数的名称，我们称之为索引类，大概意思就是把索引分类了；</li><li>IndexKey1&mldr;.这些是同一个对象在同一个索引类中的多个索引键值，我们称为索引键，切记索引键有多个；</li><li>ObjKey1&mldr;..这些是对象键，每个对象都有唯一的名称；</li></ul><p>Indexers和Indices都是按照IndexFunc(名字)分组， 每个IndexFunc输出多个IndexKey，产生相同IndexKey的多个对象存储在一个集合中。</p><h3 id=store>store</h3><p>tools/cache/store.go</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>cache</span>

<span class=kn>import</span> <span class=p>(</span>
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;strings&#34;</span>

    <span class=s>&#34;k8s.io/apimachinery/pkg/api/meta&#34;</span>
<span class=p>)</span>

<span class=c1>// Store is a generic object storage interface. Reflector knows how to watch a server
</span><span class=c1>// and update a store. A generic store is provided, which allows Reflector to be used
</span><span class=c1>// as a local caching system, and an LRU store, which allows Reflector to work like a
</span><span class=c1>// queue of items yet to be processed.
</span><span class=c1>//
</span><span class=c1>// Store makes no assumptions about stored object identity; it is the responsibility
</span><span class=c1>// of a Store implementation to provide a mechanism to correctly key objects and to
</span><span class=c1>// define the contract for obtaining objects by some arbitrary key type.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Store</span> <span class=kd>interface</span> <span class=p>{</span>
    <span class=nf>Add</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span>
    <span class=nf>Update</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span>
    <span class=nf>Delete</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span>
    <span class=nf>List</span><span class=p>()</span> <span class=p>[]</span><span class=kd>interface</span><span class=p>{}</span>
    <span class=c1>// 列举对象键
</span><span class=c1></span>    <span class=nf>ListKeys</span><span class=p>()</span> <span class=p>[]</span><span class=kt>string</span>
    <span class=c1>// 返回obj相同对象键的对象，对象键是通过对象计算出来的字符串
</span><span class=c1></span>    <span class=nf>Get</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>item</span> <span class=kd>interface</span><span class=p>{},</span> <span class=nx>exists</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
    <span class=c1>// 通过对象键获取对象
</span><span class=c1></span>    <span class=nf>GetByKey</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>item</span> <span class=kd>interface</span><span class=p>{},</span> <span class=nx>exists</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>

    <span class=c1>// Replace will delete the contents of the store, using instead the
</span><span class=c1></span>    <span class=c1>// given list. Store takes ownership of the list, you should not reference
</span><span class=c1></span>    <span class=c1>// it after calling this function.
</span><span class=c1></span>    <span class=c1>// 用[]interface{}替换Store存储的所有对象，等同于删除全部原有对象在逐一添加新的对象
</span><span class=c1></span>    <span class=nf>Replace</span><span class=p>([]</span><span class=kd>interface</span><span class=p>{},</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span>
    <span class=c1>// 重新同步
</span><span class=c1></span>    <span class=nf>Resync</span><span class=p>()</span> <span class=kt>error</span>
<span class=p>}</span>

<span class=c1>// KeyFunc knows how to make a key from an object. Implementations should be deterministic.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>KeyFunc</span> <span class=kd>func</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>



<span class=c1>// cache responsibilities are limited to:
</span><span class=c1>//  1. Computing keys for objects via keyFunc
</span><span class=c1>//  2. Invoking methods of a ThreadSafeStorage interface
</span><span class=c1></span><span class=kd>type</span> <span class=nx>cache</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=c1>// cacheStorage bears the burden of thread safety for the cache
</span><span class=c1></span>    <span class=nx>cacheStorage</span> <span class=nx>ThreadSafeStore</span>
    <span class=c1>// keyFunc is used to make the key for objects stored in and retrieved from items, and
</span><span class=c1></span>    <span class=c1>// should be deterministic.
</span><span class=c1></span>    <span class=nx>keyFunc</span> <span class=nx>KeyFunc</span>
<span class=p>}</span>

<span class=kd>var</span> <span class=nx>_</span> <span class=nx>Store</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>cache</span><span class=p>{}</span>

</code></pre></td></tr></table></div></div><h3 id=thread_safe_store>thread_safe_store</h3><p>tools/cache/thread_safe_store.go</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span><span class=lnt>193
</span><span class=lnt>194
</span><span class=lnt>195
</span><span class=lnt>196
</span><span class=lnt>197
</span><span class=lnt>198
</span><span class=lnt>199
</span><span class=lnt>200
</span><span class=lnt>201
</span><span class=lnt>202
</span><span class=lnt>203
</span><span class=lnt>204
</span><span class=lnt>205
</span><span class=lnt>206
</span><span class=lnt>207
</span><span class=lnt>208
</span><span class=lnt>209
</span><span class=lnt>210
</span><span class=lnt>211
</span><span class=lnt>212
</span><span class=lnt>213
</span><span class=lnt>214
</span><span class=lnt>215
</span><span class=lnt>216
</span><span class=lnt>217
</span><span class=lnt>218
</span><span class=lnt>219
</span><span class=lnt>220
</span><span class=lnt>221
</span><span class=lnt>222
</span><span class=lnt>223
</span><span class=lnt>224
</span><span class=lnt>225
</span><span class=lnt>226
</span><span class=lnt>227
</span><span class=lnt>228
</span><span class=lnt>229
</span><span class=lnt>230
</span><span class=lnt>231
</span><span class=lnt>232
</span><span class=lnt>233
</span><span class=lnt>234
</span><span class=lnt>235
</span><span class=lnt>236
</span><span class=lnt>237
</span><span class=lnt>238
</span><span class=lnt>239
</span><span class=lnt>240
</span><span class=lnt>241
</span><span class=lnt>242
</span><span class=lnt>243
</span><span class=lnt>244
</span><span class=lnt>245
</span><span class=lnt>246
</span><span class=lnt>247
</span><span class=lnt>248
</span><span class=lnt>249
</span><span class=lnt>250
</span><span class=lnt>251
</span><span class=lnt>252
</span><span class=lnt>253
</span><span class=lnt>254
</span><span class=lnt>255
</span><span class=lnt>256
</span><span class=lnt>257
</span><span class=lnt>258
</span><span class=lnt>259
</span><span class=lnt>260
</span><span class=lnt>261
</span><span class=lnt>262
</span><span class=lnt>263
</span><span class=lnt>264
</span><span class=lnt>265
</span><span class=lnt>266
</span><span class=lnt>267
</span><span class=lnt>268
</span><span class=lnt>269
</span><span class=lnt>270
</span><span class=lnt>271
</span><span class=lnt>272
</span><span class=lnt>273
</span><span class=lnt>274
</span><span class=lnt>275
</span><span class=lnt>276
</span><span class=lnt>277
</span><span class=lnt>278
</span><span class=lnt>279
</span><span class=lnt>280
</span><span class=lnt>281
</span><span class=lnt>282
</span><span class=lnt>283
</span><span class=lnt>284
</span><span class=lnt>285
</span><span class=lnt>286
</span><span class=lnt>287
</span><span class=lnt>288
</span><span class=lnt>289
</span><span class=lnt>290
</span><span class=lnt>291
</span><span class=lnt>292
</span><span class=lnt>293
</span><span class=lnt>294
</span><span class=lnt>295
</span><span class=lnt>296
</span><span class=lnt>297
</span><span class=lnt>298
</span><span class=lnt>299
</span><span class=lnt>300
</span><span class=lnt>301
</span><span class=lnt>302
</span><span class=lnt>303
</span><span class=lnt>304
</span><span class=lnt>305
</span><span class=lnt>306
</span><span class=lnt>307
</span><span class=lnt>308
</span><span class=lnt>309
</span><span class=lnt>310
</span><span class=lnt>311
</span><span class=lnt>312
</span><span class=lnt>313
</span><span class=lnt>314
</span><span class=lnt>315
</span><span class=lnt>316
</span><span class=lnt>317
</span><span class=lnt>318
</span><span class=lnt>319
</span><span class=lnt>320
</span><span class=lnt>321
</span><span class=lnt>322
</span><span class=lnt>323
</span><span class=lnt>324
</span><span class=lnt>325
</span><span class=lnt>326
</span><span class=lnt>327
</span><span class=lnt>328
</span><span class=lnt>329
</span><span class=lnt>330
</span><span class=lnt>331
</span><span class=lnt>332
</span><span class=lnt>333
</span><span class=lnt>334
</span><span class=lnt>335
</span><span class=lnt>336
</span><span class=lnt>337
</span><span class=lnt>338
</span><span class=lnt>339
</span><span class=lnt>340
</span><span class=lnt>341
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=cm>/*
</span><span class=cm>Copyright 2014 The Kubernetes Authors.
</span><span class=cm>
</span><span class=cm>Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
</span><span class=cm>you may not use this file except in compliance with the License.
</span><span class=cm>You may obtain a copy of the License at
</span><span class=cm>
</span><span class=cm>    http://www.apache.org/licenses/LICENSE-2.0
</span><span class=cm>
</span><span class=cm>Unless required by applicable law or agreed to in writing, software
</span><span class=cm>distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
</span><span class=cm>WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</span><span class=cm>See the License for the specific language governing permissions and
</span><span class=cm>limitations under the License.
</span><span class=cm>*/</span>

<span class=kn>package</span> <span class=nx>cache</span>

<span class=kn>import</span> <span class=p>(</span>
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;sync&#34;</span>

    <span class=s>&#34;k8s.io/apimachinery/pkg/util/sets&#34;</span>
<span class=p>)</span>

<span class=c1>// ThreadSafeStore is an interface that allows concurrent access to a storage backend.
</span><span class=c1>// TL;DR caveats: you must not modify anything returned by Get or List as it will break
</span><span class=c1>// the indexing feature in addition to not being thread safe.
</span><span class=c1>//
</span><span class=c1>// The guarantees of thread safety provided by List/Get are only valid if the caller
</span><span class=c1>// treats returned items as read-only. For example, a pointer inserted in the store
</span><span class=c1>// through `Add` will be returned as is by `Get`. Multiple clients might invoke `Get`
</span><span class=c1>// on the same key and modify the pointer in a non-thread-safe way. Also note that
</span><span class=c1>// modifying objects stored by the indexers (if any) will *not* automatically lead
</span><span class=c1>// to a re-index. So it&#39;s not a good idea to directly modify the objects returned by
</span><span class=c1>// Get/List, in general.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>ThreadSafeStore</span> <span class=kd>interface</span> <span class=p>{</span>
    <span class=nf>Add</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span>
    <span class=nf>Update</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span>
    <span class=nf>Delete</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>)</span>
    <span class=nf>Get</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>item</span> <span class=kd>interface</span><span class=p>{},</span> <span class=nx>exists</span> <span class=kt>bool</span><span class=p>)</span>
    <span class=nf>List</span><span class=p>()</span> <span class=p>[]</span><span class=kd>interface</span><span class=p>{}</span>
    <span class=nf>ListKeys</span><span class=p>()</span> <span class=p>[]</span><span class=kt>string</span>
    <span class=nf>Replace</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>interface</span><span class=p>{},</span> <span class=kt>string</span><span class=p>)</span>
    <span class=nf>Index</span><span class=p>(</span><span class=nx>indexName</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>([]</span><span class=kd>interface</span><span class=p>{},</span> <span class=kt>error</span><span class=p>)</span>
    <span class=nf>IndexKeys</span><span class=p>(</span><span class=nx>indexName</span><span class=p>,</span> <span class=nx>indexKey</span> <span class=kt>string</span><span class=p>)</span> <span class=p>([]</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
    <span class=nf>ListIndexFuncValues</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>)</span> <span class=p>[]</span><span class=kt>string</span>
    <span class=nf>ByIndex</span><span class=p>(</span><span class=nx>indexName</span><span class=p>,</span> <span class=nx>indexKey</span> <span class=kt>string</span><span class=p>)</span> <span class=p>([]</span><span class=kd>interface</span><span class=p>{},</span> <span class=kt>error</span><span class=p>)</span>
    <span class=nf>GetIndexers</span><span class=p>()</span> <span class=nx>Indexers</span>

    <span class=c1>// AddIndexers adds more indexers to this store.  If you call this after you already have data
</span><span class=c1></span>    <span class=c1>// in the store, the results are undefined.
</span><span class=c1></span>    <span class=nf>AddIndexers</span><span class=p>(</span><span class=nx>newIndexers</span> <span class=nx>Indexers</span><span class=p>)</span> <span class=kt>error</span>
    <span class=nf>Resync</span><span class=p>()</span> <span class=kt>error</span>
<span class=p>}</span>

<span class=c1>// threadSafeMap implements ThreadSafeStore
</span><span class=c1></span><span class=kd>type</span> <span class=nx>threadSafeMap</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>lock</span>  <span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
    <span class=c1>// key为keyfunc计算得出，namespace/name
</span><span class=c1></span>    <span class=nx>items</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>interface</span><span class=p>{}</span>

    <span class=c1>// indexers maps a name to an IndexFunc
</span><span class=c1></span>    <span class=c1>// 索引器函数，用于计算索引key，如按注解byuser，构建索引
</span><span class=c1></span>    <span class=nx>indexers</span> <span class=nx>Indexers</span>
    <span class=c1>// indices maps a name to an Index
</span><span class=c1></span>    <span class=nx>indices</span> <span class=nx>Indices</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>threadSafeMap</span><span class=p>)</span> <span class=nf>Add</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
    <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
    <span class=nx>oldObject</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span>
    <span class=nx>c</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span> <span class=p>=</span> <span class=nx>obj</span>
    <span class=nx>c</span><span class=p>.</span><span class=nf>updateIndices</span><span class=p>(</span><span class=nx>oldObject</span><span class=p>,</span> <span class=nx>obj</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>threadSafeMap</span><span class=p>)</span> <span class=nf>Update</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
    <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
    <span class=nx>oldObject</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span>
    <span class=nx>c</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span> <span class=p>=</span> <span class=nx>obj</span>
    <span class=nx>c</span><span class=p>.</span><span class=nf>updateIndices</span><span class=p>(</span><span class=nx>oldObject</span><span class=p>,</span> <span class=nx>obj</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>threadSafeMap</span><span class=p>)</span> <span class=nf>Delete</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
    <span class=k>if</span> <span class=nx>obj</span><span class=p>,</span> <span class=nx>exists</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>key</span><span class=p>];</span> <span class=nx>exists</span> <span class=p>{</span>
        <span class=nx>c</span><span class=p>.</span><span class=nf>deleteFromIndices</span><span class=p>(</span><span class=nx>obj</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
        <span class=nb>delete</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>items</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>threadSafeMap</span><span class=p>)</span> <span class=nf>Get</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>item</span> <span class=kd>interface</span><span class=p>{},</span> <span class=nx>exists</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
    <span class=nx>item</span><span class=p>,</span> <span class=nx>exists</span> <span class=p>=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span>
    <span class=k>return</span> <span class=nx>item</span><span class=p>,</span> <span class=nx>exists</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>threadSafeMap</span><span class=p>)</span> <span class=nf>List</span><span class=p>()</span> <span class=p>[]</span><span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
    <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
    <span class=nx>list</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kd>interface</span><span class=p>{},</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>items</span><span class=p>))</span>
    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>item</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span><span class=p>.</span><span class=nx>items</span> <span class=p>{</span>
        <span class=nx>list</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>list</span><span class=p>,</span> <span class=nx>item</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>list</span>
<span class=p>}</span>

<span class=c1>// ListKeys returns a list of all the keys of the objects currently
</span><span class=c1>// in the threadSafeMap.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>threadSafeMap</span><span class=p>)</span> <span class=nf>ListKeys</span><span class=p>()</span> <span class=p>[]</span><span class=kt>string</span> <span class=p>{</span>
    <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
    <span class=nx>list</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>string</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>items</span><span class=p>))</span>
    <span class=k>for</span> <span class=nx>key</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span><span class=p>.</span><span class=nx>items</span> <span class=p>{</span>
        <span class=nx>list</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>list</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>list</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>threadSafeMap</span><span class=p>)</span> <span class=nf>Replace</span><span class=p>(</span><span class=nx>items</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>interface</span><span class=p>{},</span> <span class=nx>resourceVersion</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
    <span class=nx>c</span><span class=p>.</span><span class=nx>items</span> <span class=p>=</span> <span class=nx>items</span>

    <span class=c1>// rebuild any index
</span><span class=c1></span>    <span class=nx>c</span><span class=p>.</span><span class=nx>indices</span> <span class=p>=</span> <span class=nx>Indices</span><span class=p>{}</span>
    <span class=k>for</span> <span class=nx>key</span><span class=p>,</span> <span class=nx>item</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span><span class=p>.</span><span class=nx>items</span> <span class=p>{</span>
        <span class=nx>c</span><span class=p>.</span><span class=nf>updateIndices</span><span class=p>(</span><span class=kc>nil</span><span class=p>,</span> <span class=nx>item</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=c1>// Index returns a list of items that match on the index function
</span><span class=c1>// Index is thread-safe so long as you treat all items as immutable
</span><span class=c1>// 这个函数就是通过指定的索引函数计算对象的索引键，然后把索引键的对象全部取出来
</span><span class=c1>// 利用一个对象计算出来的索引键，然后把所有具备这些索引键的对象全部取出来，
</span><span class=c1>// 比如取出一个Pod所在节点上的所有Pod，这样理解就会非常方便，但是kubernetes可能就不这么用。
</span><span class=c1>// 再比如取出满足某个标签或者注解的所有Pod
</span><span class=c1>// 如果更抽象一点，就是符合对象某些特征的所有对象，而这个特征就是我们指定的索引函数计算出来的
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>threadSafeMap</span><span class=p>)</span> <span class=nf>Index</span><span class=p>(</span><span class=nx>indexName</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>([]</span><span class=kd>interface</span><span class=p>{},</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
    <span class=c1>// 取出indexName这个分类索引函数
</span><span class=c1></span>    <span class=nx>indexFunc</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>indexers</span><span class=p>[</span><span class=nx>indexName</span><span class=p>]</span>
    <span class=k>if</span> <span class=nx>indexFunc</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;Index with name %s does not exist&#34;</span><span class=p>,</span> <span class=nx>indexName</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=c1>// 计算对象的索引键
</span><span class=c1></span>    <span class=nx>indexKeys</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>indexFunc</span><span class=p>(</span><span class=nx>obj</span><span class=p>)</span>
    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
    <span class=p>}</span>
    <span class=c1>// 取出indexName这个分类所有索引
</span><span class=c1></span>    <span class=nx>index</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>indices</span><span class=p>[</span><span class=nx>indexName</span><span class=p>]</span>

    <span class=c1>// need to de-dupe the return list.  Since multiple keys are allowed, this can happen.
</span><span class=c1></span>    <span class=c1>// 返回对象的对象键的集合
</span><span class=c1></span>    <span class=nx>returnKeySet</span> <span class=o>:=</span> <span class=nx>sets</span><span class=p>.</span><span class=nx>String</span><span class=p>{}</span>
    <span class=c1>// 遍历刚刚计算出来的所有索引键
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>indexKey</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>indexKeys</span> <span class=p>{</span>
        <span class=c1>// 取出索引键的所有对象键，数组形式
</span><span class=c1></span>        <span class=nx>set</span> <span class=o>:=</span> <span class=nx>index</span><span class=p>[</span><span class=nx>indexKey</span><span class=p>]</span>
        <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>key</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>set</span><span class=p>.</span><span class=nf>UnsortedList</span><span class=p>()</span> <span class=p>{</span>
            <span class=c1>// 这里的每个key 代表一个obj的key，标识一个obj
</span><span class=c1></span>            <span class=c1>// 把所有的对象键输出到对象键的集合中
</span><span class=c1></span>            <span class=nx>returnKeySet</span><span class=p>.</span><span class=nf>Insert</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=c1>// 通过对象键逐一的把对象取出
</span><span class=c1></span>    <span class=c1>// 根据obj key，从items取出obj，放入list中
</span><span class=c1></span>    <span class=nx>list</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kd>interface</span><span class=p>{},</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>returnKeySet</span><span class=p>.</span><span class=nf>Len</span><span class=p>())</span>
    <span class=k>for</span> <span class=nx>absoluteKey</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>returnKeySet</span> <span class=p>{</span>
        <span class=nx>list</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>list</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>absoluteKey</span><span class=p>])</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>list</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=c1>// ByIndex returns a list of items that match an exact value on the index function
</span><span class=c1>// 这个函数和上面的函数基本一样，只是索引键不用再计算了，使用者提供
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>threadSafeMap</span><span class=p>)</span> <span class=nf>ByIndex</span><span class=p>(</span><span class=nx>indexName</span><span class=p>,</span> <span class=nx>indexKey</span> <span class=kt>string</span><span class=p>)</span> <span class=p>([]</span><span class=kd>interface</span><span class=p>{},</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>

    <span class=nx>indexFunc</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>indexers</span><span class=p>[</span><span class=nx>indexName</span><span class=p>]</span>
    <span class=k>if</span> <span class=nx>indexFunc</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;Index with name %s does not exist&#34;</span><span class=p>,</span> <span class=nx>indexName</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=nx>index</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>indices</span><span class=p>[</span><span class=nx>indexName</span><span class=p>]</span>
    <span class=c1>// 根据indexkey索引key，找到object items的key，然后再从c.items中取出
</span><span class=c1></span>    <span class=nx>set</span> <span class=o>:=</span> <span class=nx>index</span><span class=p>[</span><span class=nx>indexKey</span><span class=p>]</span>
    <span class=nx>list</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kd>interface</span><span class=p>{},</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>set</span><span class=p>.</span><span class=nf>Len</span><span class=p>())</span>
    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>key</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>set</span><span class=p>.</span><span class=nf>List</span><span class=p>()</span> <span class=p>{</span>
        <span class=nx>list</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>list</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=nx>key</span><span class=p>])</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=nx>list</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=c1>// IndexKeys returns a list of keys that match on the index function.
</span><span class=c1>// IndexKeys is thread-safe so long as you treat all items as immutable.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>threadSafeMap</span><span class=p>)</span> <span class=nf>IndexKeys</span><span class=p>(</span><span class=nx>indexName</span><span class=p>,</span> <span class=nx>indexKey</span> <span class=kt>string</span><span class=p>)</span> <span class=p>([]</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>

    <span class=nx>indexFunc</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>indexers</span><span class=p>[</span><span class=nx>indexName</span><span class=p>]</span>
    <span class=k>if</span> <span class=nx>indexFunc</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;Index with name %s does not exist&#34;</span><span class=p>,</span> <span class=nx>indexName</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=nx>index</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>indices</span><span class=p>[</span><span class=nx>indexName</span><span class=p>]</span>

    <span class=nx>set</span> <span class=o>:=</span> <span class=nx>index</span><span class=p>[</span><span class=nx>indexKey</span><span class=p>]</span>
    <span class=k>return</span> <span class=nx>set</span><span class=p>.</span><span class=nf>List</span><span class=p>(),</span> <span class=kc>nil</span>
<span class=p>}</span>
<span class=c1>// 这个函数用来获取索引分类内的所有索引键的
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>threadSafeMap</span><span class=p>)</span> <span class=nf>ListIndexFuncValues</span><span class=p>(</span><span class=nx>indexName</span> <span class=kt>string</span><span class=p>)</span> <span class=p>[]</span><span class=kt>string</span> <span class=p>{</span>
    <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
    <span class=c1>// 获取索引分类的所有索引
</span><span class=c1></span>    <span class=nx>index</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>indices</span><span class=p>[</span><span class=nx>indexName</span><span class=p>]</span>
    <span class=nx>names</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>string</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>index</span><span class=p>))</span>
    <span class=c1>// 直接遍历后输出索引键
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>key</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>index</span> <span class=p>{</span>
        <span class=nx>names</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>names</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>names</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>threadSafeMap</span><span class=p>)</span> <span class=nf>GetIndexers</span><span class=p>()</span> <span class=nx>Indexers</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>c</span><span class=p>.</span><span class=nx>indexers</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>threadSafeMap</span><span class=p>)</span> <span class=nf>AddIndexers</span><span class=p>(</span><span class=nx>newIndexers</span> <span class=nx>Indexers</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>lock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>

    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>items</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;cannot add indexers to running index&#34;</span><span class=p>)</span>
    <span class=p>}</span>

    <span class=nx>oldKeys</span> <span class=o>:=</span> <span class=nx>sets</span><span class=p>.</span><span class=nf>StringKeySet</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>indexers</span><span class=p>)</span>
    <span class=nx>newKeys</span> <span class=o>:=</span> <span class=nx>sets</span><span class=p>.</span><span class=nf>StringKeySet</span><span class=p>(</span><span class=nx>newIndexers</span><span class=p>)</span>

    <span class=k>if</span> <span class=nx>oldKeys</span><span class=p>.</span><span class=nf>HasAny</span><span class=p>(</span><span class=nx>newKeys</span><span class=p>.</span><span class=nf>List</span><span class=p>()</span><span class=o>...</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;indexer conflict: %v&#34;</span><span class=p>,</span> <span class=nx>oldKeys</span><span class=p>.</span><span class=nf>Intersection</span><span class=p>(</span><span class=nx>newKeys</span><span class=p>))</span>
    <span class=p>}</span>

    <span class=k>for</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>newIndexers</span> <span class=p>{</span>
        <span class=nx>c</span><span class=p>.</span><span class=nx>indexers</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=p>=</span> <span class=nx>v</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=c1>// updateIndices modifies the objects location in the managed indexes, if this is an update, you must provide an oldObj
</span><span class=c1>// updateIndices must be called from a function that already has a lock on the cache
</span><span class=c1>// 当有对象添加或者更新时，需要更新索引，因为调用该函数的函数已经加锁了，所以这个函数没有加锁操作
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>threadSafeMap</span><span class=p>)</span> <span class=nf>updateIndices</span><span class=p>(</span><span class=nx>oldObj</span> <span class=kd>interface</span><span class=p>{},</span> <span class=nx>newObj</span> <span class=kd>interface</span><span class=p>{},</span> <span class=nx>key</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=c1>// 在添加和更新的时候都会获取老对象，如果存在老对象，那么就要删除老对象的索引
</span><span class=c1></span>    <span class=c1>// key 就是本地缓存caech item的object的key
</span><span class=c1></span>    <span class=c1>// 如果已有old object 则删除，后面进行更新
</span><span class=c1></span>    <span class=c1>// if we got an old object, we need to remove it before we add it again
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>oldObj</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>c</span><span class=p>.</span><span class=nf>deleteFromIndices</span><span class=p>(</span><span class=nx>oldObj</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=c1>// 遍历所有的索引函数，因为要为对象在所有的索引分类中创建索引键
</span><span class=c1></span>    <span class=c1>// 索引器函数indexFunc， 如name为byuser，fnc为 UserIndexFunc
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>name</span><span class=p>,</span> <span class=nx>indexFunc</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span><span class=p>.</span><span class=nx>indexers</span> <span class=p>{</span>
        <span class=c1>// 计算索引键
</span><span class=c1></span>        <span class=c1>// 根据索引器 检索出的索引值，比如根据pod object 的user注解，检索出username 列表
</span><span class=c1></span>        <span class=nx>indexValues</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>indexFunc</span><span class=p>(</span><span class=nx>newObj</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=k>return</span> <span class=nx>err</span>
        <span class=p>}</span>
        <span class=c1>// 获取索引分类的所有索引
</span><span class=c1></span>        <span class=nx>index</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>indices</span><span class=p>[</span><span class=nx>name</span><span class=p>]</span>
        <span class=c1>// 为空说明这个索引分类还没有任何索引
</span><span class=c1></span>        <span class=k>if</span> <span class=nx>index</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nx>index</span> <span class=p>=</span> <span class=nx>Index</span><span class=p>{}</span>
            <span class=c1>// 按name 构建索引器，比如按user注解构建的name=byuser 的索引器
</span><span class=c1></span>            <span class=nx>c</span><span class=p>.</span><span class=nx>indices</span><span class=p>[</span><span class=nx>name</span><span class=p>]</span> <span class=p>=</span> <span class=nx>index</span>
        <span class=p>}</span>
        <span class=c1>// 遍历对象的索引键，上面刚刚用索引函数计算出来的，如注解users的各个值，即indexvalue
</span><span class=c1></span>        <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>indexValue</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>indexValues</span> <span class=p>{</span>
            <span class=c1>// 找到索引键的对象集合
</span><span class=c1></span>            <span class=nx>set</span> <span class=o>:=</span> <span class=nx>index</span><span class=p>[</span><span class=nx>indexValue</span><span class=p>]</span>
            <span class=c1>// 为空说明这个索引键下还没有对象
</span><span class=c1></span>            <span class=k>if</span> <span class=nx>set</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
                <span class=c1>// 创建对象键集合
</span><span class=c1></span>                <span class=nx>set</span> <span class=p>=</span> <span class=nx>sets</span><span class=p>.</span><span class=nx>String</span><span class=p>{}</span>
                <span class=nx>index</span><span class=p>[</span><span class=nx>indexValue</span><span class=p>]</span> <span class=p>=</span> <span class=nx>set</span>
            <span class=p>}</span>
            <span class=c1>// 把这个obj的对象键添加到集合中，即这个obj的name类型索引已创建完成
</span><span class=c1></span>            <span class=nx>set</span><span class=p>.</span><span class=nf>Insert</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=c1>// deleteFromIndices removes the object from each of the managed indexes
</span><span class=c1>// it is intended to be called from a function that already has a lock on the cache
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>threadSafeMap</span><span class=p>)</span> <span class=nf>deleteFromIndices</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{},</span> <span class=nx>key</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=c1>// 遍历索引函数，也就是把所有索引分类
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>name</span><span class=p>,</span> <span class=nx>indexFunc</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span><span class=p>.</span><span class=nx>indexers</span> <span class=p>{</span>
        <span class=nx>indexValues</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>indexFunc</span><span class=p>(</span><span class=nx>obj</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=k>return</span> <span class=nx>err</span>
        <span class=p>}</span>
        <span class=c1>// 获取索引分类的所有索引
</span><span class=c1></span>        <span class=nx>index</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>indices</span><span class=p>[</span><span class=nx>name</span><span class=p>]</span>
        <span class=k>if</span> <span class=nx>index</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=k>continue</span>
        <span class=p>}</span>
        <span class=c1>// 遍历对象的索引键
</span><span class=c1></span>        <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>indexValue</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>indexValues</span> <span class=p>{</span>
            <span class=c1>//把对象从索引键指定对对象集合删除
</span><span class=c1></span>            <span class=nx>set</span> <span class=o>:=</span> <span class=nx>index</span><span class=p>[</span><span class=nx>indexValue</span><span class=p>]</span>
            <span class=k>if</span> <span class=nx>set</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
                <span class=nx>set</span><span class=p>.</span><span class=nf>Delete</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>threadSafeMap</span><span class=p>)</span> <span class=nf>Resync</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=c1>// Nothing to do
</span><span class=c1></span>    <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>NewThreadSafeStore</span><span class=p>(</span><span class=nx>indexers</span> <span class=nx>Indexers</span><span class=p>,</span> <span class=nx>indices</span> <span class=nx>Indices</span><span class=p>)</span> <span class=nx>ThreadSafeStore</span> <span class=p>{</span>
    <span class=k>return</span> <span class=o>&amp;</span><span class=nx>threadSafeMap</span><span class=p>{</span>
        <span class=nx>items</span><span class=p>:</span>    <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>interface</span><span class=p>{}{},</span>
        <span class=nx>indexers</span><span class=p>:</span> <span class=nx>indexers</span><span class=p>,</span>
        <span class=nx>indices</span><span class=p>:</span>  <span class=nx>indices</span><span class=p>,</span>
    <span class=p>}</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><p>-store -> threadSafeMap 通过 updateIndices、deleteFromIndices方法来更新或删除本地存储的obj和索引器</p><h3 id=说明-3>说明</h3><p>索引键和对象键是两个重要概念</p><ul><li>indexkey: 索引键是用于对象快速查找的，经过索引建在map中排序查找会更快；</li><li>objkey: 对象键是为对象在存储中的唯一命名的，对象是通过名字+对象的方式存储的。默认格式为：namespace/name</li></ul><p>kubernetes中主要的索引函数，最主要的索引的函数大概就下面几种：</p><ul><li>MetaNamespaceIndexFunc，定义在client-go/tools/cache/index.go中，从名字看就是获取对象元数据的namesapce字段，也就是所有对象以namespace作为索引键，这个就很好理解了；</li><li>indexByPodNodeName，定义在kubernetes/pkg/controller/daemon/deamon_controller.go，该索引函数计算的是Pod对象所在节点的名字；
为了方便理解，我们可以假设kubernetes主要就是一种索引函数（MetaNamespaceIndexFunc），也就是在索引中大部分就一个分类，这个分类的索引键就是namesapce。那么有人肯定会问，如果这样的话，所有的对象都存在一个namesapce索引键下面，这样的效率岂不是太低了?其实client-go为每类对象都创建了Informer(Informer内有Indexer)，所以即便存储在相同namesapce下的对象都是同一类，这个问题自然也就没有了，详情可以看我针对Informer写的文章。</li></ul><p>注意：一定要区分MetaNamespaceIndexFunc和MetaNamespaceKeyFunc的区分，第一个索引键计算函数，第二个是对象键计算函数，第一个返回的是namespace，第二个返回的是对象包含namespace在内的对象全称。<br>所有的对象(Pod、Node、Service等等)都是有属性/标签的，如果属性/标签就是索引键，Indexer就会把相同属性/标签的所有对象放在一个集合中，如果在对属性/标签分一下类，也就就是我们本文的将的Indexer的核心内容了。甚至你可以简单的理解为Indexer就是简单的把相同namesapce对象放在一个集合中，kubernetes就是基于属性/标签/注解来检索的</p><h2 id=参考资料>参考资料</h2><ul><li><a href=https://blog.csdn.net/cbmljs/article/details/103088183 target=_blank rel="noopener noreffer">client-go源码分析&ndash;informer机制流程分析</a></li><li><a href=https://blog.csdn.net/weixin_42663840/article/details/81530606 target=_blank rel="noopener noreffer">深入浅出kubernetes之client-go的Indexer</a></li><li><a href=https://blog.csdn.net/weixin_42663840/article/details/81626789 target=_blank rel="noopener noreffer">深入浅出kubernetes之client-go的DeltaFIFO</a></li><li><a href=https://blog.csdn.net/weixin_42663840/article/details/81699303 target=_blank rel="noopener noreffer">深入浅出kubernetes之client-go的SharedInformer</a></li><li><a href=https://github.com/kubernetes/sample-controller target=_blank rel="noopener noreffer">k8s-sample-controller</a></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2021-08-31</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/k8s/>K8S</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/2021/07/k8s%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AFipclient-ip%E6%96%B9%E6%B3%95/ class=prev rel=prev title="K8S获取客户端ip[client ip]方法"><i class="fas fa-angle-left fa-fw"></i>K8S获取客户端ip[client ip]方法</a>
<a href=/posts/2021/10/lxcfs%E7%9A%84k8s%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB%E8%A7%86%E5%9B%BE/ class=next rel=next title=lxcfs的k8s部署方式，实现容器资源隔离视图>lxcfs的k8s部署方式，实现容器资源隔离视图<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=utterances></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>Utterances</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2016 - 2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=bingerambo.com target=_blank>Binge</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=http://bingerambo.com/ target=_blank>bingerambo.com</a></span></div><div class=footer-line><i class="fa fa-eye"></i>本站总访问量<span id=busuanzi_value_site_pv></span>次
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/css/lightgallery.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/js/lightgallery.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lg-thumbnail.js@1.2.0/dist/lg-thumbnail.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lg-zoom.js@1.2.0/dist/lg-zoom.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{"utterances":{"darkTheme":"github-dark","issueTerm":"pathname","label":"","lightTheme":"github-light","repo":"bingerambo/myblog-comments"}},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true}};</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','UA-81425808-1',{'anonymize_ip':true});</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=UA-81425808-1" async></script><script src=https://libs.baidu.com/jquery/2.1.4/jquery.min.js></script><script src=https://cdn.bootcdn.net/ajax/libs/jquery-backstretch/2.1.18/jquery.backstretch.min.js></script><script type=text/javascript src=/js/custom.js></script><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?c0176279eee823ce422da4e8d06708f9";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script></body></html>