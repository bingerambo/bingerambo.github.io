<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>JavaScript 模式设计-02 - 斌哥的小站|Binge Blog</title><meta name=Description content="斌哥的小站 | 这里是 @BingeRambo斌哥兰博的个人博客"><meta property="og:title" content="JavaScript 模式设计-02"><meta property="og:description" content="JQuery源码-Deferred 寥寥代码，犀利锋锐，设计思想，值得学习       ——Binge"><meta property="og:type" content="article"><meta property="og:url" content="http://bingerambo.com/posts/2016/08/javascript-%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1-02/"><meta property="og:image" content="http://bingerambo.com/logo.png"><meta property="article:published_time" content="2016-08-03T21:43:17+08:00"><meta property="article:modified_time" content="2016-08-03T21:43:17+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://bingerambo.com/logo.png"><meta name=twitter:title content="JavaScript 模式设计-02"><meta name=twitter:description content="JQuery源码-Deferred 寥寥代码，犀利锋锐，设计思想，值得学习       ——Binge"><meta name=application-name content="Binge Blog"><meta name=apple-mobile-web-app-title content="Binge Blog"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=http://bingerambo.com/posts/2016/08/javascript-%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1-02/><link rel=prev href=http://bingerambo.com/posts/2016/07/javascript-%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1-01/><link rel=next href=http://bingerambo.com/posts/2016/09/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%A4%A7%E5%85%A8/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/custom.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"JavaScript 模式设计-02","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/bingerambo.com\/posts\/2016\/08\/javascript-%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1-02\/"},"image":["http:\/\/bingerambo.com\/images\/Apple-Devices-Preview.png"],"genre":"posts","keywords":"JS","wordcount":5028,"url":"http:\/\/bingerambo.com\/posts\/2016\/08\/javascript-%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1-02\/","datePublished":"2016-08-03T21:43:17+08:00","dateModified":"2016-08-03T21:43:17+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xxxx","logo":"http:\/\/bingerambo.com\/images\/avatar.png"},"author":{"@type":"Person","name":"Binge"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="斌哥的小站|Binge Blog"><span class=header-title-pre><i class="fas fa-biking fa-fw"></i></span>Binge Blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/><i class="fas fa-fw fa-archive"></i>文章 </a><a class=menu-item href=/tags/><i class="fas fa-fw fa-tag"></i>标签 </a><a class=menu-item href=/categories/><i class="fas fa-fw fa-th"></i>分类 </a><a class=menu-item href=/notes/><i class="fas fa-cog fa-spin"></i>随记 </a><a class=menu-item href=/about/><i class="fas fa-fw fa-at"></i>关于 </a><a class=menu-item href=/search/><i class="fas fa-fw fa-search"></i>搜索 </a><a class=menu-item href=/friend/ title=Friend><i class="fas fa fa-user"></i>友链 </a><a class=menu-item href=https://github.com/bingerambo title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><a class=menu-item href=/><i class="fas fa fa-eye"></i><span id=busuanzi_value_site_uv></span></a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="斌哥的小站|Binge Blog"><span class=header-title-pre><i class="fas fa-biking fa-fw"></i></span>Binge Blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/><i class="fas fa-fw fa-archive"></i>文章</a><a class=menu-item href=/tags/><i class="fas fa-fw fa-tag"></i>标签</a><a class=menu-item href=/categories/><i class="fas fa-fw fa-th"></i>分类</a><a class=menu-item href=/notes/><i class="fas fa-cog fa-spin"></i>随记</a><a class=menu-item href=/about/><i class="fas fa-fw fa-at"></i>关于</a><a class=menu-item href=/search/><i class="fas fa-fw fa-search"></i>搜索</a><a class=menu-item href=/friend/ title=Friend><i class="fas fa fa-user"></i>友链</a><a class=menu-item href=https://github.com/bingerambo title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><a class=menu-item href=/><i class="fas fa fa-eye"></i><span id=busuanzi_value_site_uv></span></a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">JavaScript 模式设计-02</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=http://bingerambo.com title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>Binge</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/js/><i class="far fa-folder fa-fw"></i>JS</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2016-08-03>2016-08-03</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 5028 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 11 分钟&nbsp;
<i class="fa fa-eye fa-fw"></i>&nbsp;本文总阅读量 <span id=busuanzi_value_page_pv></span>次&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents></nav></div></div><div class=content id=content><blockquote><p>JQuery源码-Deferred 寥寥代码，犀利锋锐，设计思想，值得学习 ——Binge</p></blockquote><br><br><div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><strong>Deferred的概念请看第一篇</strong></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><a target=_blank href=http://www.cnblogs.com/aaronjs/p/3348569.html style=color:#1a8bc8;text-decoration:none>http://www.cnblogs.com/aaronjs/p/3348569.html</a></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">&nbsp;</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><strong><span style=color:red><span style=line-height:27px;font-size:18px>******************
<strong>构建Deferred对象时候的流程图**************************</strong></span></span></strong></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><img src=http://images.cnitblog.com/blog/329084/201310/07212436-77fb87abe03846cd857da70ab1698c32.jpg alt style=border:0></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">&nbsp;</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><strong><span style=line-height:27px;color:red;font-size:18px>**********************源码解析**********************</span></strong></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">&nbsp;</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">因为callback被剥离出去后，整个deferred就显得非常的精简</p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><div class=cnblogs_code_toolbar style=margin-top:5px><span class=cnblogs_code_copy style=padding-right:5px;line-height:1.5!important><a target=_blank title=复制代码 style=color:#1a8bc8;border:none!important><img src=http://common.cnblogs.com/images/copycode.gif alt=复制代码 style=border:none!important></a></span></div><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important"><span style=line-height:1.5!important>jQuery.extend({ 
<pre><code>Deferred : &lt;/span&gt;&lt;span style=&quot;color:rgb(0,0,255); line-height:1.5!important&quot;&gt;function&lt;/span&gt;&lt;span style=&quot;line-height:1.5!important&quot;&gt;(){}

when : &lt;/span&gt;&lt;span style=&quot;color:rgb(0,0,255); line-height:1.5!important&quot;&gt;function&lt;/span&gt;&lt;span style=&quot;line-height:1.5!important&quot;&gt;()
</code></pre><p>)}</span></pre><div class=cnblogs_code_toolbar style=margin-top:5px><span class=cnblogs_code_copy style=padding-right:5px;line-height:1.5!important><a target=_blank title=复制代码 style=color:#1a8bc8;border:none!important><img src=http://common.cnblogs.com/images/copycode.gif alt=复制代码 style=border:none!important></a></span></div></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">对于extend的继承这个东东，在之前就提及过jquery如何处理内部jquery与init相互引用this的问题</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">对于JQ的整体架构一定要弄懂 
<a target=_blank href=http://www.cnblogs.com/aaronjs/p/3278578.html style=color:#1a8bc8;text-decoration:none><a href=http://www.cnblogs.com/aaronjs/p/3278578.html>http://www.cnblogs.com/aaronjs/p/3278578.html</a></a></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">所以当jQuery.extend只有一个参数的时候，其实就是对jQuery静态方法的一个扩展</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">我们在具体看看2个静态方法内部都干了些什么：</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">Deferred整体结构：</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">源码精简了部分代码</p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><div class=cnblogs_code_toolbar style=margin-top:5px><span class=cnblogs_code_copy style=padding-right:5px;line-height:1.5!important><a target=_blank title=复制代码 style=color:#1a8bc8;border:none!important><img src=http://common.cnblogs.com/images/copycode.gif alt=复制代码 style=border:none!important></a></span></div><blockquote style="border:2px solid #efefef;color:#333;margin-left:25px;padding:5px 10px;margin-top:10px;margin-bottom:10px"><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important">Deferred: <span style=color:#00f;line-height:1.5!important>function</span><span style=color:#000;line-height:1.5!important>( func ) {</span><span style=color:#00f;line-height:1.5!important>var</span> tuples =<span style=color:#000;line-height:1.5!important>[</span><span style=color:green;line-height:1.5!important>//</span><span style=color:green;line-height:1.5!important>action, add listener, listener list, final state</span>
[ &ldquo;resolve&rdquo;, &ldquo;done&rdquo;, jQuery.Callbacks(&ldquo;once memory&rdquo;), &ldquo;resolved&rdquo;<span style=color:#000;line-height:1.5!important> ],
[ </span>&ldquo;reject&rdquo;, &ldquo;fail&rdquo;, jQuery.Callbacks(&ldquo;once memory&rdquo;), &ldquo;rejected&rdquo;<span style=color:#000;line-height:1.5!important> ],
[ </span>&ldquo;notify&rdquo;, &ldquo;progress&rdquo;, jQuery.Callbacks(&ldquo;memory&rdquo;<span style=color:#000;line-height:1.5!important>) ]
],
state </span>= &ldquo;pending&rdquo;<span style=color:#000;line-height:1.5!important>,
promise </span>=<span style=color:#000;line-height:1.5!important> {
state: </span><span style=color:#00f;line-height:1.5!important>function</span><span style=color:#000;line-height:1.5!important>() {},
always: </span><span style=color:#00f;line-height:1.5!important>function</span><span style=color:#000;line-height:1.5!important>() {},
then: </span><span style=color:#00f;line-height:1.5!important>function</span>( <span style=color:green;line-height:1.5!important>/<em></span><span style=color:green;line-height:1.5!important>fnDone, fnFail, fnProgress </span><span style=color:green;line-height:1.5!important></em>/</span><span style=color:#000;line-height:1.5!important>) { },</span><span style=color:green;line-height:1.5!important>//</span><span style=color:green;line-height:1.5!important>Get a promise for this deferred</span>
<span style=color:green;line-height:1.5!important>//</span><span style=color:green;line-height:1.5!important> If obj is provided, the promise aspect is added to the object</span>
promise: <span style=color:#00f;line-height:1.5!important>function</span><span style=color:#000;line-height:1.5!important>( obj ) {}
},
deferred </span>=<span style=color:#000;line-height:1.5!important> {};
jQuery.each( tuples, </span><span style=color:#00f;line-height:1.5!important>function</span><span style=color:#000;line-height:1.5!important>( i, tuple ) {
deferred[ tuple[</span>0] + &ldquo;With&rdquo; ] =<span style=color:#000;line-height:1.5!important> list.fireWith;
});
promise.promise( deferred );
</span><span style=color:green;line-height:1.5!important>//</span><span style=color:green;line-height:1.5!important>All done!</span>
<span style=color:#00f;line-height:1.5!important>return</span><span style=color:#000;line-height:1.5!important> deferred;
},</span></pre></blockquote><div class=cnblogs_code_toolbar style=margin-top:5px><span class=cnblogs_code_copy style=padding-right:5px;line-height:1.5!important><a target=_blank title=复制代码 style=color:#1a8bc8;border:none!important><img src=http://common.cnblogs.com/images/copycode.gif alt=复制代码 style=border:none!important></a></span></div></div><ol style=padding-left:50px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;line-height:24px><li style=list-style-type:decimal><span style=color:#9b00d3><span style=color:#000><span style=color:red>显而易见Deferred是个工厂类，返回的是内部构建的deferred对象</span></span></span></li><li style=list-style-type:decimal><span style=color:red>tuples 创建三个$.Callbacks对象，分别表示成功，失败，处理中三种状态</span></li><li style=list-style-type:decimal><span style=color:red>创建了一个promise对象，具有state、always、then、primise方法</span></li><li style=list-style-type:decimal><span style=color:red>扩展primise对象生成最终的Deferred对象，返回该对象</span></li></ol><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">这里其实就是3个处理,但是有个优化代码的地方,就是把共性的代码给抽象出来,通过动态生成了</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><hr style=font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;line-height:24px><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><strong>具体源码分析:</strong></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><strong><span style=color:red>Deferred自身则围绕这三个对象进行更高层次的抽象</span></strong></p><ul style="list-style-position:initial;margin:0 0 10px 45px;padding-left:5px;font-family:微软雅黑,PTSans,Arial,sans-serif;line-height:24px"><li style=list-style:inherit!important;font-size:16px>触发回调函数列表执行(函数名)</li><li style=list-style:inherit!important;font-size:16px>添加回调函数（函数名）</li><li style=list-style:inherit!important;font-size:16px>回调函数列表（jQuery.Callbacks对象）</li><li style=list-style:inherit!important;font-size:16px>deferred最终状态（第三组数据除外）</li></ul><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><div class=cnblogs_code_toolbar style=margin-top:5px><span class=cnblogs_code_copy style=padding-right:5px;line-height:1.5!important><a target=_blank title=复制代码 style=color:#1a8bc8;border:none!important><img src=http://common.cnblogs.com/images/copycode.gif alt=复制代码 style=border:none!important></a></span></div><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important"><span style=color:#00f;line-height:1.5!important>var</span> tuples =<span style=line-height:1.5!important>[</span><span style=color:green;line-height:1.5!important>//</span><span style=color:green;line-height:1.5!important>action, add listener, listener list, final state</span>
[ &ldquo;resolve&rdquo;, &ldquo;done&rdquo;, jQuery.Callbacks(&ldquo;once memory&rdquo;), &ldquo;resolved&rdquo;<span style=line-height:1.5!important> ],
[ </span>&ldquo;reject&rdquo;, &ldquo;fail&rdquo;, jQuery.Callbacks(&ldquo;once memory&rdquo;), &ldquo;rejected&rdquo;<span style=line-height:1.5!important> ],
[ </span>&ldquo;notify&rdquo;, &ldquo;progress&rdquo;, jQuery.Callbacks(&ldquo;memory&rdquo;<span style=line-height:1.5!important>) ]
],</span></pre><div class=cnblogs_code_toolbar style=margin-top:5px><span class=cnblogs_code_copy style=padding-right:5px;line-height:1.5!important><a target=_blank title=复制代码 style=color:#1a8bc8;border:none!important><img src=http://common.cnblogs.com/images/copycode.gif alt=复制代码 style=border:none!important></a></span></div></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><span style=color:red>这里抽象出2组阵营：</span></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><strong>1组：回调方法/事件订阅  </strong></p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><span style=color:red;line-height:1.5!important>done，fail，progress</span></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><strong>2组：通知方法/事件发布    </strong></p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><span style=color:red;line-height:1.5!important>resolve，reject，notify，resolveWith，rejectWith，notifyWith</span></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">tuples 元素集 其实是把相同有共同特性的代码的给合并成一种结构，然后通过一次处理</p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><div class=cnblogs_code_toolbar style=margin-top:5px><span class=cnblogs_code_copy style=padding-right:5px;line-height:1.5!important><a target=_blank title=复制代码 style=color:#1a8bc8;border:none!important><img src=http://common.cnblogs.com/images/copycode.gif alt=复制代码 style=border:none!important></a></span></div><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important">jQuery.each( tuples, <span style=color:#00f;line-height:1.5!important>function</span><span style=line-height:1.5!important>( i, tuple ) {</span><span style=color:#00f;line-height:1.5!important>var</span> list = tuple[ 2<span style=line-height:1.5!important> ],
stateString </span>= tuple[ 3<span style=line-height:1.5!important> ];
promise[ tuple[</span>1] ] =<span style=line-height:1.5!important>list.add;</span><span style=color:#00f;line-height:1.5!important>if</span><span style=line-height:1.5!important> ( stateString ) {
list.add(</span><span style=color:#00f;line-height:1.5!important>function</span><span style=line-height:1.5!important>() {
state </span>=<span style=line-height:1.5!important>stateString;</span><span style=color:green;line-height:1.5!important>//</span><span style=color:green;line-height:1.5!important>[ reject_list | resolve_list ].disable; progress_list.lock</span>
}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2<span style=line-height:1.5!important> ].lock );
}
deferred[ tuple[</span>0] ] = <span style=color:#00f;line-height:1.5!important>function</span><span style=line-height:1.5!important>() {
deferred[ tuple[</span>0] + &ldquo;With&rdquo; ]( <span style=color:#00f;line-height:1.5!important>this</span> === deferred ? promise : <span style=color:#00f;line-height:1.5!important>this</span><span style=line-height:1.5!important>, arguments );</span><span style=color:#00f;line-height:1.5!important>return</span> <span style=color:#00f;line-height:1.5!important>this</span><span style=line-height:1.5!important>;
};
deferred[ tuple[</span>0] + &ldquo;With&rdquo; ] =<span style=line-height:1.5!important> list.fireWith;
});</span></pre><div class=cnblogs_code_toolbar style=margin-top:5px><span class=cnblogs_code_copy style=padding-right:5px;line-height:1.5!important><a target=_blank title=复制代码 style=color:#1a8bc8;border:none!important><img src=http://common.cnblogs.com/images/copycode.gif alt=复制代码 style=border:none!important></a></span></div></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">对于tuples的3条数据集是分2部分处理的</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><hr style=font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;line-height:24px><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><span style=color:#9b00d3><strong>第一部分将回调函数存入</strong></span></p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important">promise[ tuple[1] ] = list.add;</pre></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">其实就是给promise赋予3个回调函数</p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important">promise.done = $.Callbacks(&ldquo;once memory&rdquo;).add</pre></div><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important">promise.fail = $.Callbacks(&ldquo;once memory&rdquo;).add</pre></div><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important">promise.progressl = $.Callbacks(&ldquo;memory&rdquo;).add</pre></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">如果存在deferred最终状态</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">默认会预先向doneList,failList中的list添加三个回调函数</p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><div class=cnblogs_code_toolbar style=margin-top:5px><span class=cnblogs_code_copy style=padding-right:5px;line-height:1.5!important><a target=_blank title=复制代码 style=color:#1a8bc8;border:none!important><img src=http://common.cnblogs.com/images/copycode.gif alt=复制代码 style=border:none!important></a></span></div><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important"><span style=color:#00f;line-height:1.5!important>if</span><span style=line-height:1.5!important> ( stateString ) {
list.add(</span><span style=color:#00f;line-height:1.5!important>function</span><span style=line-height:1.5!important>() {</span><span style=color:green;line-height:1.5!important>//</span><span style=color:green;line-height:1.5!important>state = [ resolved | rejected ]</span>
state =<span style=line-height:1.5!important>stateString;</span><span style=color:green;line-height:1.5!important>//</span><span style=color:green;line-height:1.5!important>[ reject_list | resolve_list ].disable; progress_list.lock</span>
}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2<span style=line-height:1.5!important> ].lock );
}</span></pre><div class=cnblogs_code_toolbar style=margin-top:5px><span class=cnblogs_code_copy style=padding-right:5px;line-height:1.5!important><a target=_blank title=复制代码 style=color:#1a8bc8;border:none!important><img src=http://common.cnblogs.com/images/copycode.gif alt=复制代码 style=border:none!important></a></span></div></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">*************************************************************<br>这里有个小技巧</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">i ^ 1 
<a target=_blank href=https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Operators/Bitwise_Operators style=color:#1a8bc8;text-decoration:none>按位异或运算符</a></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">所以实际上第二个传参数是1、0索引对调了，所以取值是failList.disable与doneList.disable</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">*************************************************************</p><p align=right style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><strong><span style=color:red>通过stateString有值这个条件，预先向doneList,failList中的list添加三个回调函数</span></strong></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">分别是:</p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important"><span style=line-height:1.5!important>doneList : [changeState, failList.disable, <span style=color:#9b00d3;line-height:1.5!important>processList.lock</span>]
failList : [changeState, doneList.disable, <span style=color:#9b00d3;line-height:1.5!important>processList.lock</span>]</span></pre></div><pre style=margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-size:16px;line-height:24px;background-color:#fff></pre><ul style="list-style-position:initial;margin:0 0 10px 45px;padding-left:5px;font-family:微软雅黑,PTSans,Arial,sans-serif;line-height:24px"><li style=list-style:inherit!important;font-size:16px>changeState 改变状态的匿名函数，deferred的状态，分为三种：pending(初始状态), resolved(解决状态), rejected(拒绝状态)</li><li style=list-style:inherit!important;font-size:16px>不论deferred对象最终是resolve（还是reject），在首先改变对象状态之后，都会disable另一个函数列表failList(或者doneList)</li><li style=list-style:inherit!important;font-size:16px>然后lock processList保持其状态，最后执行剩下的之前done（或者fail）进来的回调函数</li></ul><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><span style=color:#9b00d3>所以第一步最终都是围绕这add方法</span></p><ul style="list-style-position:initial;margin:0 0 10px 45px;padding-left:5px;font-family:微软雅黑,PTSans,Arial,sans-serif;line-height:24px"><li style=list-style:inherit!important;font-size:16px>done/fail/是list.add也就是
<a target=_blank href=http://www.cnblogs.com/snandy/archive/2012/11/15/2770237.html#add style=color:#1a8bc8;text-decoration:none>callbacks.add</a>
，将回调函数存入回调对象中</li></ul><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><span style=color:#9b00d3>第二部分很简单，给deferred对象扩充6个方法</span></p><ul style="list-style-position:initial;margin:0 0 10px 45px;padding-left:5px;font-family:微软雅黑,PTSans,Arial,sans-serif;line-height:24px"><li style=list-style:inherit!important;font-size:16px>resolve/reject/notify 是 
<a target=_blank href=http://www.cnblogs.com/snandy/archive/2012/11/15/2770237.html#fireWith style=color:#1a8bc8;text-decoration:none>callbacks.fireWith</a>
，执行回调函数</li><li style=list-style:inherit!important;font-size:16px>resolveWith/rejectWith/notifyWith 是 
<a target=_blank href=http://www.cnblogs.com/snandy/archive/2012/11/15/2770237.html#fireWith style=color:#1a8bc8;text-decoration:none>callbacks.fireWith</a>
 队列方法引用</li></ul><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">最后合并promise到deferred</p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important"><span style=line-height:1.5!important>promise.promise( deferred );
jQuery.extend( obj, promise )</span></pre></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">所以最终通过工厂方法Deferred构建的异步对象带的所有的方法了</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">return 内部的deferred对象了</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><a target=_blank href=http://images.cnitblog.com/blog/329084/201310/03131510-2375bbda3f2f4524a53e5c5df5eccda0.png style=color:#1a8bc8;text-decoration:none><img title=image src=http://images.cnitblog.com/blog/329084/201310/03131518-8caf4716aa724a66af4e53291e9a408d.png alt=image width=414 height=207 border=0 style=border:0;padding-left:0;padding-right:0;display:inline;padding-top:0></a></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">由此可见我们在</p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important"><span style=color:#00f;line-height:1.5!important>var</span> defer = $.Deferred(); <span style=color:green;line-height:1.5!important>//</span><span style=color:green;line-height:1.5!important>构建异步对象</span></pre></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">的时候,内部的对象就有了4个属性方法了</p><ol style=padding-left:50px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;line-height:24px><li style=list-style-type:decimal>deferred: Object<ol style=padding-left:50px><li style=list-style-type:decimal>always: function () {</li><li style=list-style-type:decimal>done: function () {</li><li style=list-style-type:decimal>fail: function () {</li><li style=list-style-type:decimal>notify: function () {</li><li style=list-style-type:decimal>notifyWith: function ( context, args ) {</li><li style=list-style-type:decimal>pipe: function ( /* fnDone, fnFail, fnProgress */ ) {</li><li style=list-style-type:decimal>progress: function () {</li><li style=list-style-type:decimal>promise: function ( obj ) {</li><li style=list-style-type:decimal>reject: function () {</li><li style=list-style-type:decimal>rejectWith: function ( context, args ) {</li><li style=list-style-type:decimal>resolve: function () {</li><li style=list-style-type:decimal>resolveWith: function ( context, args ) {</li><li style=list-style-type:decimal>state: function () {</li><li style=list-style-type:decimal>then: function ( /* fnDone, fnFail, fnProgress */ ) {</li></ol></li><li style=list-style-type:decimal>promise: Object<ol style=padding-left:50px><li style=list-style-type:decimal>always: function () {</li><li style=list-style-type:decimal>done: function () {</li><li style=list-style-type:decimal>fail: function () {</li><li style=list-style-type:decimal>pipe: function ( /* fnDone, fnFail, fnProgress */ ) {</li><li style=list-style-type:decimal>progress: function () {</li><li style=list-style-type:decimal>promise: function ( obj ) {</li><li style=list-style-type:decimal>state: function () {</li><li style=list-style-type:decimal>then: function ( /* fnDone, fnFail, fnProgress */ ) {</li></ol></li><li style=list-style-type:decimal>state: &ldquo;pending&rdquo;</li><li style=list-style-type:decimal>tuples: Array[3]</li></ol><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">构造图</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><img src=http://images.cnitblog.com/blog/329084/201310/07212451-50defafec7bc468f817adb82476c9bb9.jpg alt style=border:0></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">以上只是在初始化构建的时候，我们往下看看动态执行时候的处理</p><hr style=font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;line-height:24px><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><strong><span style=color:red>*****************执行期***********************</span></strong></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">一个最简单的demo为例子</p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><div class=cnblogs_code_toolbar style=margin-top:5px><span class=cnblogs_code_copy style=padding-right:5px;line-height:1.5!important><a target=_blank title=复制代码 style=color:#1a8bc8;border:none!important><img src=http://common.cnblogs.com/images/copycode.gif alt=复制代码 style=border:none!important></a></span></div><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important"><span style=color:#00f;line-height:1.5!important>var</span> d =<span style=line-height:1.5!important> $.Deferred();</p>
<p>setTimeout(</span><span style=color:#00f;line-height:1.5!important>function</span><span style=line-height:1.5!important>(){
d.resolve(</span>22<span style=line-height:1.5!important>)
},</span>0<span style=line-height:1.5!important>);</p>
<p>d.then(</span><span style=color:#00f;line-height:1.5!important>function</span><span style=line-height:1.5!important>(val){
console.log(val);
})</span></pre><div class=cnblogs_code_toolbar style=margin-top:5px><span class=cnblogs_code_copy style=padding-right:5px;line-height:1.5!important><a target=_blank title=复制代码 style=color:#1a8bc8;border:none!important><img src=http://common.cnblogs.com/images/copycode.gif alt=复制代码 style=border:none!important></a></span></div></div><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><span style=color:#9b00d3;line-height:1.5!important>当延迟对象被 resolved 时，任何通过 deferred.then或deferred.done 添加的 doneCallbacks，都会被调用。回调函数的执行顺序和它们被添加的顺序是一样的。传递给 deferred.resolve() 的 args 参数，会传给每个回调函数。当延迟对象进入 resolved 状态后，再添加的任何 doneCallbacks，当它们被添加时，就会被立刻执行，并带上传入给
.resolve()的参数</span></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">换句话说，我们调用d.resolve(22) 就等于是调用</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">匿名函数并传入参数值 22</p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important"><span style=color:#00f;line-height:1.5!important>function</span><span style=line-height:1.5!important>(val){
console.log(val); //22
}</span></pre></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">当前实际的使用中会有各种复杂的组合情况，但是整的外部调用流程就是这样的</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><span style=color:red><strong>***************** resolve的实现 *******************</strong></span></p><hr style=font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;line-height:24px><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><span style=color:red>我们回顾下，其实Deferred对象，内部的实现还是Callbacks对象，只是在外面再封装了一层API，供接口调用</span></p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important">d.resolve(22)</pre></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">实际上调用的就是通过这个代码生成的</p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important">deferred[ tuple[0] ] = <span style=color:#00f;line-height:1.5!important>function</span><span style=line-height:1.5!important>() {
deferred[ tuple[</span>0] + &ldquo;With&rdquo; ]( <span style=color:#00f;line-height:1.5!important>this</span> === deferred ? promise : <span style=color:#00f;line-height:1.5!important>this</span><span style=line-height:1.5!important>, arguments );</span><span style=color:#00f;line-height:1.5!important>return</span> <span style=color:#00f;line-height:1.5!important>this</span><span style=line-height:1.5!important>;
};</span></pre><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important">deferred[ tuple[0] + &ldquo;With&rdquo; ] = list.fireWith;</pre></div><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important">deferred.resolveWith()</pre></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">最终执行的就是
<span style=color:#9b00d3> list.fireWith</span></p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><span style=color:red;line-height:1.5!important>callbacks.fireWith()</span></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">所以最终又回到回调对象
<span style=color:red>callbacks中的私有方法</span>
<span style=color:red>fire()了</span></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><hr style=font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;line-height:24px><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">Callbacks会通过</p><h3 style="margin:10px 0;font-size:14px;color:#666;font-family:Verdana;line-height:24px"><a name=t1></a><a target=_blank href=http://www.css88.com/jqapi-1.9/callbacks.add/ style=color:#1a8bc8;text-decoration:none>callbacks.add()</a></h3><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">把回调函数给注册到内部的
<span style=color:red>list = []</span>
上,我们回来过看看</p><h3 style="margin:10px 0;font-size:14px;color:#666;font-family:Verdana;line-height:24px"><a name=t2></a><a target=_blank href=http://www.css88.com/jqapi-1.9/deferred.then/ style=color:#1a8bc8;text-decoration:none>deferred.then()</a></h3><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important">d.then(<span style=color:#00f;line-height:1.5!important>function</span><span style=line-height:1.5!important>(val){
console.log(val);
})</span></pre></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><span style=color:red><strong>***************** then的实现 *******************</strong></span></p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><div class=cnblogs_code_toolbar style=margin-top:5px><span class=cnblogs_code_copy style=padding-right:5px;line-height:1.5!important><a target=_blank title=复制代码 style=color:#1a8bc8;border:none!important><img src=http://common.cnblogs.com/images/copycode.gif alt=复制代码 style=border:none!important></a></span></div><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important">then: <span style=color:#00f;line-height:1.5!important>function</span>( <span style=color:green;line-height:1.5!important>/*</span><span style=color:green;line-height:1.5!important>fnDone, fnFail, fnProgress </span><span style=color:green;line-height:1.5!important>*/</span><span style=line-height:1.5!important>) {</span><span style=color:#00f;line-height:1.5!important>var</span> fns =<span style=line-height:1.5!important>arguments;</span><span style=color:#00f;line-height:1.5!important>return</span> jQuery.Deferred(<span style=color:#00f;line-height:1.5!important>function</span><span style=line-height:1.5!important>( newDefer ) {
jQuery.each( tuples, </span><span style=color:#00f;line-height:1.5!important>function</span><span style=line-height:1.5!important>( i, tuple ) {</span><span style=color:#00f;line-height:1.5!important>var</span> action = tuple[ 0<span style=line-height:1.5!important> ],
fn </span>= jQuery.isFunction( fns[ i ] ) &amp;&amp;<span style=line-height:1.5!important>fns[ i ];</span><span style=color:green;line-height:1.5!important>//</span><span style=color:green;line-height:1.5!important> deferred[ done | fail | progress ] for forwarding actions to newDefer</span>
deferred[ tuple[1] ](<span style=color:#00f;line-height:1.5!important>function</span><span style=line-height:1.5!important>() {</span><span style=color:green;line-height:1.5!important>//</span><span style=color:green;line-height:1.5!important>省略&hellip;&hellip;&hellip;&hellip;</span>
<span style=line-height:1.5!important>            });
});
fns </span>= <span style=color:#00f;line-height:1.5!important>null</span><span style=line-height:1.5!important>;
}).promise();
},</span></pre><div class=cnblogs_code_toolbar style=margin-top:5px><span class=cnblogs_code_copy style=padding-right:5px;line-height:1.5!important><a target=_blank title=复制代码 style=color:#1a8bc8;border:none!important><img src=http://common.cnblogs.com/images/copycode.gif alt=复制代码 style=border:none!important></a></span></div></div><ul style="list-style-position:initial;margin:0 0 10px 45px;padding-left:5px;font-family:微软雅黑,PTSans,Arial,sans-serif;line-height:24px"><li style=list-style:inherit!important;font-size:16px>递归jQuery.Deferred</li><li style=list-style:inherit!important;font-size:16px>传递了func</li><li style=list-style:inherit!important;font-size:16px>链式调用了promise()</li></ul><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><hr style=font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;line-height:24px><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><strong>因为在异步对象的方法都是嵌套找作用域属性方法的</strong></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><strong>这里我额外的提及一下作用域</strong></p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important"><span style=color:#00f;line-height:1.5!important>var</span> d = $.Deferred();</pre></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">这个异步对象d是作用域是如何呢？</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">第一层：无可争议，浏览器环境下最外层是 window</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">第二层：jquery本身是一个闭包</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">第三层: Deferred工厂方法产生的作用域</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">如果用d.then()方法呢？</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">很明显then方法又是嵌套在内部的函数，所以执行的时候都默认会包含以上三层作用域+自己本身函数产生的作用域了</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">我们用个简单图描绘下</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><a target=_blank href=http://images.cnitblog.com/blog/329084/201310/03210232-7602c75e6dab41b6bff219c0a288f7d3.jpg style=color:#1a8bc8;text-decoration:none><img title=演示文稿1 src=http://images.cnitblog.com/blog/329084/201310/03210240-ff84208212224cbe8700048def6bf0dc.jpg alt=演示文稿1 width=680 height=384 border=0 style=border:0;padding-left:0;padding-right:0;display:inline;padding-top:0></a></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><strong><span style=color:#9b00d3>根据规则，在最内部的函数能够访问上层作用域的所有的变量</span></strong></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><hr style=font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;line-height:24px><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><strong>我们先从使用的层面去考虑下结构设计:</strong></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><strong>demo 1</strong></p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><div class=cnblogs_code_toolbar style=margin-top:5px><span class=cnblogs_code_copy style=padding-right:5px;line-height:1.5!important><a target=_blank title=复制代码 style=color:#1a8bc8;border:none!important><img src=http://common.cnblogs.com/images/copycode.gif alt=复制代码 style=border:none!important></a></span></div><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important"><span style=color:#00f;line-height:1.5!important>var</span> defer =<span style=line-height:1.5!important>$.Deferred();</span><span style=color:#00f;line-height:1.5!important>var</span> filtered = defer.then(<span style=color:#00f;line-height:1.5!important>function</span><span style=line-height:1.5!important>( value ) {</span><span style=color:#00f;line-height:1.5!important>return</span> value * 2<span style=line-height:1.5!important>;
});</p>
<p>defer.resolve( </span>5<span style=line-height:1.5!important> );</p>
<p>filtered.done(</span><span style=color:#00f;line-height:1.5!important>function</span><span style=line-height:1.5!important>( value ) {
console.log(value) //10
});</span></pre><div class=cnblogs_code_toolbar style=margin-top:5px><span class=cnblogs_code_copy style=padding-right:5px;line-height:1.5!important><a target=_blank title=复制代码 style=color:#1a8bc8;border:none!important><img src=http://common.cnblogs.com/images/copycode.gif alt=复制代码 style=border:none!important></a></span></div></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><strong>demo 2</strong></p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><div class=cnblogs_code_toolbar style=margin-top:5px><span class=cnblogs_code_copy style=padding-right:5px;line-height:1.5!important><a target=_blank title=复制代码 style=color:#1a8bc8;border:none!important><img src=http://common.cnblogs.com/images/copycode.gif alt=复制代码 style=border:none!important></a></span></div><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important"><span style=color:#00f;line-height:1.5!important>var</span> defer =<span style=line-height:1.5!important> $.Deferred();</p>
<p>defer.then(</span><span style=color:#00f;line-height:1.5!important>function</span><span style=line-height:1.5!important>(value) {</span><span style=color:#00f;line-height:1.5!important>return</span> value * 2<span style=line-height:1.5!important>;
}).then(</span><span style=color:#00f;line-height:1.5!important>function</span><span style=line-height:1.5!important>(value) {</span><span style=color:#00f;line-height:1.5!important>return</span> value * 2<span style=line-height:1.5!important>;
}).done(</span><span style=color:#00f;line-height:1.5!important>function</span><span style=line-height:1.5!important>(value) {
alert(value)  </span><span style=color:green;line-height:1.5!important>//</span><span style=color:green;line-height:1.5!important>20</span>
<span style=line-height:1.5!important>  });</p>
<p>defer.resolve( </span>5 );</pre><div class=cnblogs_code_toolbar style=margin-top:5px><span class=cnblogs_code_copy style=padding-right:5px;line-height:1.5!important><a target=_blank title=复制代码 style=color:#1a8bc8;border:none!important><img src=http://common.cnblogs.com/images/copycode.gif alt=复制代码 style=border:none!important></a></span></div></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><strong>其实这里就是涉及到defer.then().then().done()  链式调用了</strong></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><strong>API是这么定义的:</strong></p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important">deferred.then( doneFilter [, failFilter ] [, progressFilter ] )</pre></div><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><span style=color:#9b00d3;line-height:1.5!important>从jQuery 1.8开始, 方法返回一个新的promise（承诺），通过一个函数，可以过滤deferred（延迟）的状态和值。替换现在过时的deferred.pipe()方法。 doneFilter 和 failFilter函数过滤原deferred（延迟）的解决/拒绝的状态和值。 progressFilter 函数过滤器的任何调用到原有的deferred（延迟）的notify 和 notifyWith的方法。
这些过滤器函数可以返回一个新的值传递给的 promise（承诺）的.done() 或 .fail() 回调，或他们可以返回另一个观察的对象（递延，承诺等）传递给它的解决/拒绝的状态和值promise（承诺）的回调。 如果过滤函数是空，或没有指定，promise（承诺）将得到与原来值相同解决（resolved）或拒绝（rejected）。</span></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">我们抓住几点：</p><ul style="list-style-position:initial;margin:0 0 10px 45px;padding-left:5px;font-family:微软雅黑,PTSans,Arial,sans-serif;line-height:24px"><li style=list-style:inherit!important;font-size:16px>返回的是新的promise对象</li><li style=list-style:inherit!important;font-size:16px>内部有一个滤器函数</li></ul><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">从demo 1中我们就能看到</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">经过x.then()方法处理的代码中返回的this（filtered ）,不是原来的$.Deferred()所有产生的那个异步对象(defer )了</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><span style=color:red>所以，每经过一个then那么内部处理的this都要被重新设置，那么为什么要这样处理呢？</span></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">源码</p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><div class=cnblogs_code_toolbar style=margin-top:5px><span class=cnblogs_code_copy style=padding-right:5px;line-height:1.5!important><a target=_blank title=复制代码 style=color:#1a8bc8;border:none!important><img src=http://common.cnblogs.com/images/copycode.gif alt=复制代码 style=border:none!important></a></span></div><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important">then: <span style=color:#00f;line-height:1.5!important>function</span>( <span style=color:green;line-height:1.5!important>/<em></span><span style=color:green;line-height:1.5!important>fnDone, fnFail, fnProgress </span><span style=color:green;line-height:1.5!important></em>/</span><span style=line-height:1.5!important>) {</span><span style=color:#00f;line-height:1.5!important>var</span> fns =<span style=line-height:1.5!important>arguments;</span><span style=color:green;line-height:1.5!important>//</span><span style=color:green;line-height:1.5!important>分别为deferred的三个callbacklist添加回调函数，根据fn的是否是函数，分为两种情况</span>
<span style=color:#00f;line-height:1.5!important>return</span> jQuery.Deferred(<span style=color:#00f;line-height:1.5!important>function</span><span style=line-height:1.5!important>( newDefer ) {
jQuery.each( tuples, </span><span style=color:#00f;line-height:1.5!important>function</span><span style=line-height:1.5!important>( i, tuple ) {</span><span style=color:#00f;line-height:1.5!important>var</span> action = tuple[ 0<span style=line-height:1.5!important> ],
fn </span>= jQuery.isFunction( fns[ i ] ) &amp;&amp;<span style=line-height:1.5!important>fns[ i ];</span><span style=color:green;line-height:1.5!important>//</span><span style=color:green;line-height:1.5!important> deferred[ done | fail | progress ] for forwarding actions to newDefer</span>
deferred[ tuple[1] ](<span style=color:#00f;line-height:1.5!important>function</span><span style=line-height:1.5!important>() {</span><span style=color:#00f;line-height:1.5!important>var</span> returned = fn &amp;&amp; fn.apply( <span style=color:#00f;line-height:1.5!important>this</span><span style=line-height:1.5!important>, arguments );</span><span style=color:#00f;line-height:1.5!important>if</span> ( returned &amp;&amp;<span style=line-height:1.5!important> jQuery.isFunction( returned.promise ) ) {
returned.promise()
.done( newDefer.resolve )
.fail( newDefer.reject )
.progress( newDefer.notify );
} </span><span style=color:#00f;line-height:1.5!important>else</span><span style=line-height:1.5!important> {
newDefer[ action </span>+ &ldquo;With&rdquo; ]( <span style=color:#00f;line-height:1.5!important>this</span> === promise ? newDefer.promise() : <span style=color:#00f;line-height:1.5!important>this</span>, fn ?<span style=line-height:1.5!important> [ returned ] : arguments );
}
});
});
fns </span>= <span style=color:#00f;line-height:1.5!important>null</span><span style=line-height:1.5!important>;
}).promise();
},</span></pre><div class=cnblogs_code_toolbar style=margin-top:5px><span class=cnblogs_code_copy style=padding-right:5px;line-height:1.5!important><a target=_blank title=复制代码 style=color:#1a8bc8;border:none!important><img src=http://common.cnblogs.com/images/copycode.gif alt=复制代码 style=border:none!important></a></span></div></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">在Deferred传递实参的时候，支持一个flag，jQuery.Deferred(func)</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">传递一个回调函数</p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important"><span style=color:green;line-height:1.5!important>//</span><span style=color:green;line-height:1.5!important>Call given func if any</span>
<span style=color:#00f;line-height:1.5!important>if</span><span style=line-height:1.5!important> ( func ) {
func.call( deferred, deferred );
}</span></pre></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">所以newDefer可以看作是</p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important">newDefer = $.Deferred();</pre></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">那么func回调的处理的就是过滤函数了</p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><div class=cnblogs_code_toolbar style=margin-top:5px><span class=cnblogs_code_copy style=padding-right:5px;line-height:1.5!important><a target=_blank title=复制代码 style=color:#1a8bc8;border:none!important><img src=http://common.cnblogs.com/images/copycode.gif alt=复制代码 style=border:none!important></a></span></div><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important">deferred[ tuple[1] ](<span style=color:#00f;line-height:1.5!important>function</span><span style=line-height:1.5!important>() {</span><span style=color:#00f;line-height:1.5!important>var</span> returned = fn &amp;&amp; fn.apply( <span style=color:#00f;line-height:1.5!important>this</span><span style=line-height:1.5!important>, arguments );</span><span style=color:#00f;line-height:1.5!important>if</span> ( returned &amp;&amp;<span style=line-height:1.5!important> jQuery.isFunction( returned.promise ) ) {
returned.promise()
.done( newDefer.resolve )
.fail( newDefer.reject )
.progress( newDefer.notify );
} </span><span style=color:#00f;line-height:1.5!important>else</span><span style=line-height:1.5!important> {
newDefer[ action </span>+ &ldquo;With&rdquo; ]( <span style=color:#00f;line-height:1.5!important>this</span> === promise ? newDefer.promise() : <span style=color:#00f;line-height:1.5!important>this</span>, fn ?<span style=line-height:1.5!important> [ returned ] : arguments );
}
});</span></pre><div class=cnblogs_code_toolbar style=margin-top:5px><span class=cnblogs_code_copy style=padding-right:5px;line-height:1.5!important><a target=_blank title=复制代码 style=color:#1a8bc8;border:none!important><img src=http://common.cnblogs.com/images/copycode.gif alt=复制代码 style=border:none!important></a></span></div></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">这里其实也有编译函数的概念，讲未来要执行的代码，预先通过闭包函数也保存起来，使其访问各自的作用域</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">第一步</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">分解tuples元素集</p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important">jQuery.each( tuples, <span style=color:#00f;line-height:1.5!important>function</span><span style=line-height:1.5!important>( i, tuple ) {</span><span style=color:green;line-height:1.5!important>//</span><span style=color:green;line-height:1.5!important>过滤函数第一步处理</span>
}）</pre></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">第二步</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">分别为deferred[ done | fail | progress ]执行对应的add方法，增加过滤函数给done | fail | progress 方法</p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important">deferred[ tuple[1] ]（</pre><span style=color:red;line-height:1.5!important>传入过滤函数</span><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important">）//过滤函数 执行的时候在分解</pre></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">代码即</p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important">deferred[done] = list.add = callback.add</pre></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">第三步</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">返回return jQuery.Deferred().promise()</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">此时构建了一个新的Deferred对象，但是返回的的是经过promise()方法处理后的，返回的是一个受限的promise对象</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">所以整个then方法就处理了2个事情</p><ul style="list-style-position:initial;margin:0 0 10px 45px;padding-left:5px;font-family:微软雅黑,PTSans,Arial,sans-serif;line-height:24px"><li style=list-style:inherit!important;font-size:16px>构建一个新的deferred对象，返回受限的promise对象</li><li style=list-style:inherit!important;font-size:16px>给父deferred对象的[ done | fail | progress ]方法都增加一个过滤函数的方法</li></ul><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">我们知道defer.then方法返回的是一个新的jQuery.Deferred().promise()对象</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">那么我们把defer.then返回的称之为子对象,那么如何与父对象
<span style=color:#00f>var</span>
 defer = $.Deferred() 关联的起来的</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">我看看源码</p><div class=cnblogs_code style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;overflow:auto;margin:5px 0;line-height:24px;font-family:courier new!important"><pre style="margin-top:0;margin-bottom:0;white-space:pre-wrap;word-wrap:break-word;font-family:courier new!important">deferred[ tuple[1] ](<span style=color:green;line-height:1.5!important>//</span><span style=color:green;line-height:1.5!important>过滤函数//)</span></pre></div><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">deferred其实就是根级父对象的引用,所以就嵌套再深,其实都是调用了父对象deferred[ done | fail | progress 执行add罢了</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><img src=http://images.cnitblog.com/blog/329084/201310/07212521-e2749ec11b1c44049e104d9124320667.jpg alt style=border:0></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">从图中就能很明显的看到 2个不同的deferred对象中 done fail progress分别都保存了不同的处理回调了</p><hr style=font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;line-height:24px><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><h6 style=font-family:微软雅黑,PTSans,Arial,sans-serif;line-height:24px><a name=t3></a><span style=font-size:14px>deferred.resolve( args )</span></h6><ul style="list-style-position:initial;margin:0 0 10px 45px;padding-left:5px;font-family:微软雅黑,PTSans,Arial,sans-serif;line-height:24px"><li style=list-style:inherit!important;font-size:16px>当延迟对象被 resolved 时，任何通过 
<code><a target=_blank href=http://www.css88.com/jqapi-1.9/deferred.then style=color:#1a8bc8;text-decoration:none>deferred.then</a></code>
或
<a target=_blank href=http://www.css88.com/jqapi-1.9/deferred.done style=color:#1a8bc8;text-decoration:none><code>deferred.done</code></a>
 添加的
doneCallbacks，都会被调用</li><li style=list-style:inherit!important;font-size:16px>回调函数的执行顺序和它们被添加的顺序是一样的</li><li style=list-style:inherit!important;font-size:16px>传递给 
<code>deferred.resolve()</code>
 的 
<code>args</code>
 参数，会传给每个回调函数</li><li style=list-style:inherit!important;font-size:16px>当延迟对象进入 resolved 状态后，再添加的任何 doneCallbacks，当它们被添加时，就会被立刻执行，并带上传入给
<code>.resolve()</code>
的参数</li></ul><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">流程如图</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><img src=http://images.cnitblog.com/blog/329084/201310/07212507-bba369612b92425a908b5bbb2977b586.jpg alt style=border:0></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">流程解析：</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">1 执行fire()方法，递归执行list所有包含的处理方法</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">2 执行了默认的 changeState, disable, lock 方法、</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">3 执行过滤函数</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">      根据 var returned = fn.apply( this, arguments )的返回值(称作returnReferred)是否是deferred对象</p><ul style="list-style-position:initial;margin:0 0 10px 45px;padding-left:5px;font-family:微软雅黑,PTSans,Arial,sans-serif;line-height:24px"><li style=list-style:inherit!important;font-size:16px>返回值是deferred对象，那么在returnReferred对象的三个回调函数列表中添加newDeferred的resolve(reject,notify)方法，也就是说newDeferrred的执行依赖returnDeferred的状态</li><li style=list-style:inherit!important;font-size:16px>不是函数的情况（如值为undefined或者null等），直接链接到newDeferred的resolve(reject,notify)方法，也就是说  newDeferrred的执行依赖外层的调用者deferred的状态或者说是执行动作（resolve还是reject或者是notify）  此时deferred.then()相当于将自己的callbacklist和newDeferred的callbacklist连接起来</li></ul><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><a target=_blank href=http://images.cnitblog.com/blog/329084/201310/07224100-f83ea4187cc74c05baec6eaf437efb2c.png style=color:#1a8bc8;text-decoration:none><img title=image src=http://images.cnitblog.com/blog/329084/201310/07224128-b173cd377afd4ea9bf6caf1bf449872e.png alt=image width=689 height=369 border=0 style=border:0;padding-left:0;padding-right:0;display:inline;padding-top:0></a></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">下面就是嵌套deferred对象的划分了</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"><a target=_blank href=http://images.cnitblog.com/blog/329084/201310/08084453-a88aa66681f542548f2878fb4e932a56.png style=color:#1a8bc8;text-decoration:none><img title=image src=http://images.cnitblog.com/blog/329084/201310/08084454-e443324b4f894f809174a49590366a0d.png alt=image width=382 height=480 style=border:0;display:inline></a></p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">源码还是要靠自己去折腾的</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">思想的提高比较难的，我们可以借鉴设计的思路，代码书写方式都是有益无害的</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">流程的分析已经比较透彻了，下一章在讲解when的实现</p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important"> </p><p style="line-height:24px;font-family:微软雅黑,PTSans,Arial,sans-serif;font-size:16px;margin:10px auto!important">写这东西太耗精力了，如果对您有帮助，请点击
<strong><span style=line-height:27px;color:red;font-size:18px>推荐支持</span></strong>
一下……………</p><br></div>非常感谢《 jQuery 2.0.3 源码分析 Deferred（最细的实现剖析，带图）》转载文章和Aaron的教程图示，如对你有用，请推荐一把。
<a href=http://blog.csdn.net/yixuan_1/article/details/12836379 target=_blank rel="noopener noreffer">阅读原文</a></p><script type=text/javascript src=/js/jquery.min.js></script><script type=text/javascript>$(function(){$('img').each(function(index,element){if($(this).attr('alt')=='复制代码'){$(this).hide();}});});</script><blockquote></blockquote></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2016-08-03</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/js/>JS</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/2016/07/javascript-%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1-01/ class=prev rel=prev title="JavaScript 模式设计-01"><i class="fas fa-angle-left fa-fw"></i>JavaScript 模式设计-01</a>
<a href=/posts/2016/09/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%A4%A7%E5%85%A8/ class=next rel=next title=JS正则表达式大全>JS正则表达式大全<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2016 - 2020</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=bingerambo.com target=_blank>Binge</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=http://bingerambo.com/ target=_blank>bingerambo.com</a></span></div><div class=footer-line><i class="fa fa-eye"></i>本站总访问量<span id=busuanzi_value_site_pv></span>次
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/css/lightgallery.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/js/lightgallery.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lg-thumbnail.js@1.2.0/dist/lg-thumbnail.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lg-zoom.js@1.2.0/dist/lg-zoom.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true}};</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','UA-81425808-1',{'anonymize_ip':true});</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=UA-81425808-1" async></script><script src=https://libs.baidu.com/jquery/2.1.4/jquery.min.js></script><script src=https://cdn.bootcdn.net/ajax/libs/jquery-backstretch/2.1.18/jquery.backstretch.min.js></script><script type=text/javascript src=/js/custom.js></script><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?c0176279eee823ce422da4e8d06708f9";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script></body></html>